## 소프트웨어 공학 개요 및 시스템 기본 요소
*   **소프트웨어 공학**: 소프트웨어를 만들기 위한 전체적인 학문 [1]. 소프트웨어는 스마트폰 앱, 윈도우 등 프로그램 포함 [1].
*   **소프트웨어 특징**: 상품성, 복잡성, 변경 가능, 복제 및 유통 용이 [2].
*   **시스템**: 하나의 조직 또는 컴퓨터 시스템 [2, 3].
*   **시스템 기본 요소**: 입력 -> 처리 -> 출력, 제어, 피드백 [2, 4].
*   **소프트웨어 위기 원인**:
    *   개발 비용 증가 (규모 증대, 복잡도 증가, 다양한 인력 필요) [4, 5].
    *   개발 기간 지연 [4].
    *   개발 인력 부족 [4].
    *   인건비 상승 [6].
    *   성능 및 신뢰성 부족 [6].
    *   유지보수 어려움 및 높은 비용 (가장 중요) [6].
*   **소프트웨어 공학의 목표**: 적은 비용으로 빠르고 쉽고 정확하게 소프트웨어를 만듦 [6].
*   **소프트웨어 공학 기본 원칙**: 현대적 프로그래밍 기술 적용, **신뢰성** (믿고 맡길 수 있는지) [5, 6], 사용 편의성 및 유지보수성 향상, 지속적인 검증 [5].

## 재공학 (Reengineering)
*   **목표**: 개발 시간/비용 감소, 품질/생산성/효율성 향상, 지식 공유, 프로젝트 실패 위험 감소 (기존 검증된 SW 재사용) [7, 8], 유지보수성 향상, 잃어버린 정보 복구, 재사용 용이, SW 수명 연장 [8].
*   **과정**: 분석 -> 구성 (구조 변경) -> **역공학** (분석 기법, 기존 SW 코딩/작동 방식 역분석) -> 적용 [8, 9]. 핵심은 **문서화 재수행** [9].

## CASE (Computer-Aided Software Engineering)
*   **개념**: 소프트웨어 엔지니어링 자동화 도구, SW 개발 도움 [9, 10]. (CAD와 유사) [9].
*   **기능**: 개발 신속성/정확성, 품질 향상, SW 생명주기 단계 연결/자동화/통합, 문서화/명세화 그래픽 기능 제공, 개발 단계 표준화, 자료 흐름도 작성, 모델 모순 검사, 다양한 개발 모형 지원 [9, 10].
*   **장점**: 기간/비용 단축, 생산성 향상 [10]. 총괄 관리 및 문서화 도구 역할 [10].
*   **분류**:
    *   **상위 CASE**: 개발 초기 (요구 분석, 설계) 지원 [10, 11].
    *   **하위 CASE**: 실제 구현 (코딩) 지원 [11].
    *   **통합 CASE**: SW 개발 주기 전체 과정 관리 [10, 11].
*   **SADT (Structured Analysis and Design Technique)**: 케이스 프로그램 중 하나, 시스템 정의/요구사항 분석/설계에 사용되는 구조적 설계 도구 [11]. 블록 다이어그램 지원 [12].

## 소프트웨어 생명주기 모형 (SDLC)
*   **개념**: SW 생성부터 폐기까지 과정 [13]. 타당성 검토 -> 개발 계획/요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 운용/유지보수 [14].
*   **폭포수 모형 (Waterfall Model)**: 가장 전통적, 선형 순차 모델 [14]. 순서대로 진행 (역행 불가) [14].
    *   *장점*: 소규모 SW 개발에 적합 (정확한 계획, 빠른 개발) [14].
    *   *단점*: 중간 요구사항 변경 또는 이벤트 발생 시 적용 어려움 [14, 15].
*   **나선형 모형 (Spiral Model)**: 보헴(Boehm) 제시, 반복적 작업 [15].
    *   핵심: **위험 분석** 단계 포함 [15, 16]. (계획 -> 위험 분석 -> 개발 -> 고객 평가 반복) [15, 16].
    *   프로토타입 사용 [16]. 대규모 프로젝트에 적합 [16].
*   **프로토타입 모형 (Prototype Model)**: 실제 개발될 시스템의 견본품/시제품 제작 [17, 18].
    *   *장점*: 고객과의 커뮤니케이션 원활, 요구사항 명확화 도구 [17]. 최종 결과물 미리 확인 가능 [16].
    *   *활용*: 프로토타입 개선하여 최종 제품 개발 가능 (소규모) 또는 폐기 후 본 개발 [18].
*   **HIPO (Hierarchical Input Process Output)**: 계층적 입력 처리 출력 [18]. 폭포수 모형과 유사한 시스템 분석/설계/문서화 과정 [18, 19]. 하향식 개발 문서화에 사용 [19].
    *   구성: 가시적 도표 (Visual Table of Contents), 총체 다이어그램 (Overview Diagram), 세부 다이어그램 (Detail Diagram) [18].
    *   *장점*: 순서대로 나열, 가시적 도표로 보기 쉽고 이해하기 쉬움, 유지보수 용이 [19].
*   **V-모델**: 폭포수 모형에서 **시스템 검증 및 테스트 작업 강조** [19, 20]. 각 단계별 테스트 수행 [20]. (정적 테스트: 코드 분석, 동적 테스트: 실제 실행) [20].

## 애자일 방법론 (Agile Methodology)
*   **개념**: 변화에 유연하게 대응, 고객 가치에 집중 [21-23]. 절차/도구보다 개인/소통 중시 [22]. 계획보다 제대로 된 결과물 생성 중시 [22].
*   **핵심 가치 (Agile Manifesto)**: 프로세스와 도구보다 **개인과 상호작용**, 포괄적인 문서보다 **작동하는 소프트웨어**, 계약 협상보다 **고객과 협업**, 계획을 따르기보다 **변화에 대응** [23].
*   **종류**: **XP (eXtreme Programming)**, **스크럼 (Scrum)**, Lean, DSDM, FDD (기능 중심 개발), Crystal 등 [23, 24].
*   **eXtreme Programming (XP)**: 빠르고 양질의 SW 개발 [23].
    *   *핵심 가치*: 소통, 단순성, 피드백, 용기 (변화 수용), 존중 [23, 25].
    *   *절차*: 사용자 스토리 -> 릴리즈 계획 -> 이터레이션 계획 -> 이터레이션 -> 작은 릴리즈 [25, 26]. **반복 (Iteration)**과 **사용자 테스트 참여**가 핵심 [26].
        *   스파이크 (Spike): 요구사항 확인 위한 작은 프로그램 [25, 26].
        *   사용자 스토리 (User Story): 사용자가 시스템 사용하는 방식 기술 [26].
        *   릴리즈 플래닝 (Release Planning): 몇 개 스토리 적용해 부분 기능 완료 제품 제공 계획 [26].
        *   이터레이션 (Iteration): 1-3주 단위 반복, 새 스토리 추가 가능 [27].
        *   인수 테스트 (Acceptance Test): 실제 사용자 테스트 [27].
        *   스몰 릴리즈 (Small Release): 작은 단위 기능 배포 [27].
    *   *12가지 실천 사항*: 짝 프로그래밍, 계획 게임, 테스트 주도 개발 (TDD), 전체 팀 (고객 참여), 지속적인 통합 (CI), 디자인 개선 (리팩토링), 작은 릴리즈, 코딩 표준, 공동 코드 소유, 단순한 디자인, 시스템 은유 (구조 기술), 지속 가능한 속도 [27-29].
*   **스크럼 (Scrum)**: 반복적/점진적 프레임워크 [30].
    *   *기본 원리*: 기능 협업 기반, 스프린트 단위 개발 [31].
    *   *팀 역할*:
        *   **제품 책임자 (Product Owner)**: 개발 목표 이해도 높음 (클라이언트 측 대표), 요구사항 파악/기능 목록 작성 (제품 백로그), 우선순위 지정, 테스트 수행 [31, 32].
        *   **스크럼 마스터 (Scrum Master)**: 개발팀 조력자, 업무 배분 (강요X), 장애 요소 제거, 훌륭한 감독 역할 [30-32].
        *   **스크럼 팀 (Development Team)**: 제품 책임자/스크럼 마스터 제외한 개발자 (디자이너, 검사자, 코더 등), 5-9명 내외, 요구사항 사용자 스토리로 도출, 일정 추정, 스프린트 결과 시연, 데일리 스크럼 참석 [30].
    *   *과정/이벤트*:
        *   **스프린트 (Sprint)**: 2-4주 고정 기간 반복 개발 주기 (전력 질주) [30, 31, 33].
        *   **데일리 스크럼 미팅 (Daily Scrum Meeting)**: 매일 15분 내외 짧은 회의, 진행 상황/완료 내용 공유 [30, 31, 33].
        *   **소멸 차트 (Burndown Chart)**: 작업 목록 중 매일 완료된 일 소거하며 진행 상황/남은 작업 시각화 [31, 33].
        *   **제품 백로그 (Product Backlog)**: 제품 개발 필요한 모든 요구사항 우선순위 나열 목록 [33].
    *   *작업 흐름도*: 제품 백로그 -> 스프린트 계획 회의 -> 스프린트 백로그 -> 스프린트 (데일리 스크럼 포함) -> 완료된 증분 (potentially shippable product increment) -> 스프린트 검토 회의 -> 스프린트 회고 [그림 참조 - 30].

## 현행 시스템 분석
*   **목적**: 개발 시스템의 개발 범위 확인, 방향성 설정 (회사가 어떻게 돌아가는지 파악) [34].
*   **파악 절차**:
    1.  **시스템 구성 파악**: 회사 조직, 업무 흐름, 부서별 기능, 데이터 교환 파악 [34, 35].
    2.  **시스템 아키텍처 파악**: 회사 전체 구조/조직도, 운영 SW 구성 파악 [3, 35, 36]. (핵심 기관 업무처리 시스템 기준) [3].
    3.  **하드웨어/소프트웨어/네트워크 파악**: 사용 OS, HW 사양, 네트워크 구성 등 파악 [35, 37].
*   **중요성**: 문서화, 공유, 개발 방향 설정에 필수 [36, 38].

## 시스템 인터페이스 현황 파악
*   **목적**: 시스템 구성/기능 파악, 시스템 간 데이터 교환 현황 파악 [38, 39].
*   **EAI (Enterprise Application Integration)**: 기업 내 다양한 애플리케이션 통합/조정 도구 [39, 40].
*   **FEP (Front-End Processor)**: 전위 처리기, 입력 데이터 사전 처리하여 프로세서 부하 감소 [39, 40].

## 개발 기술 환경 분석
*   **분석 항목**: 소프트웨어/하드웨어/네트워크 구성, DBMS, 미들웨어, 플랫폼 [41].
*   **플랫폼 (Platform)**: SW 개발 위한 기반 시설 (땅바닥) [41, 42]. (예: Java, .NET, OS, iOS, Android, Windows) [41, 42].
*   **플랫폼 성능 특성 분석**: 현행 플랫폼 성능 문제 유기 시 파악 [42].
    *   **측정 항목**: **응답 시간**, **가용성**, **사용률** [42, 43].
    *   *분석 방법*: 기능 테스트, 사용자 인터페이스/문서 점검 [43].
*   **운영체제 (OS) 분석**: 사용 OS 종류/버전/패치/백업 주기 등 고려 [43].
    *   **TCO (Total Cost of Ownership)**: 시스템 소유 총 비용 [44].
    *   **메모리 누수 (Memory Leak)**: SW 종료 후 메모리 반환 X [44].
*   **오픈 소스 라이선스**: 공개된 소스 코드 SW [44, 45].
    *   **GNU GPL**: 소스 코드 공개 의무 [46].
    *   **BSD**: 수정/배포 자유, 상용 SW에 사용 가능 (소스 코드 공개 의무 X) [46].
    *   **Apache 2.0**: 아파치 재단 라이선스, 하둡(Hadoop)과 연관 (빅데이터 분석 처리 기술) [47].
*   **DBMS (Database Management System) 분석**: 사용 DBMS 파악 [47].
    *   **개념**: 데이터베이스 관리 시스템 [47].
    *   **역할**: 종속성 및 중복성 문제 해결 [47].
    *   **고려 사항**: 가용성, 성능, 상호 호환성, 기술 지원 등 (네트워크 구성도는 DBMS 분석과 무관) [48].

## 요구사항 공학 (Requirements Engineering)
*   **목적**: 고객이 원하는 것을 정확하게 파악/도출 (요구사항 개발) [48, 49]. 이해관계자 간 원활한 의사소통, 요구사항 누락/오류 제거 (경제성), 요구사항 변경 이력 관리 (비용/시간 절감), 문서화 (SW 개발 핵심의 약 60%), 비용/일정 제약 설정 및 타당성 조사 [49-51].
*   **요구 공학 프로세스**: 요구사항 도출 -> 분석 -> 명세 -> 확인/검증 [51, 52]. 체계적 도출, 분석 결과 명세서 정리, 명세서 확인/검증 [51].
*   **선행 조건**: 경제성, 기술성, 적법성, 대한성, 타당성 조사 [52].
*   **도출 단계**: 해결 문제 이해, 현 상태 파악, 문제 정의, 목표 명확화 [52, 53]. (이해관계자: SW 개발 관련 모든 팀원 및 고객) [53].
*   **도출 기법**: 고객 발표/자료 조사, 문서 조사, 설문, 업무 절차/양식 조사, 브레인스토밍, 워크숍, 인터뷰, 관찰, 모델, 프로토타입, 유즈케이스, 벤치마킹, BPR, RFP [53, 54].
*   **분석 단계**: 사용자 요구사항 걸러냄/구조화 [54]. (파악된 자료가 실제 필요한 기능인지 이해하는 단계) [54].
*   **분석 기법**: 사용자 의견 청취/인터뷰, 문서 분석, 관찰, 모델 작성, 설문조사 [54].
*   **분석 수행 단계**: 문제 인식 -> 검토 (적용 가능성) -> 문서화 [54, 55].
*   **요구사항 분류**:
    *   **기능 요구사항 (Functional Requirements)**: 시스템이 무엇을 해야 하는지 (실제 작동) [55-57].
    *   **비기능 요구사항 (Non-functional Requirements)**: 시스템이 어떻게 작동해야 하는지 (성능, 보안, 품질, 안정성 등) [55-57]. (기능을 서포트하는 부수적 요소) [57].
    *   *분류 기준*: 우선순위 결정 (상충 시 중요도 판단) [55].
*   **요구사항 명세**: 문서화 [57].
    *   **명세 기법**:
        *   **정형 명세 기법 (Formal Specification)**: 수학/모델 기반, 정확/간결, 이해 어려움 [57, 58]. (예: VDM, Z, Lotos 등) [57].
        *   **비정형 명세 기법 (Informal Specification)**: 자연어 기반, 이해 용이, 모호성 가능 [57, 58]. (예: 유즈케이스) [58].
    *   **명세서 속성**: **정확성, 명확성, 완전성, 일관성, 수정 용이성, 추적성** (RFP 통한 추적 가능) [58]. (시험 출제 빈번) [58].
*   **요구사항 확인/검증**: 문서화된 내용 확인 및 검토 [58].
    *   *필요성*: 변경으로 인한 비용/편익 분석, 변경 추적, 영향 평가 [59].
    *   *도구*: 프로토타이핑 (시제품 제작) [60, 61], 모델 검증 (모델 품질 검증) [60, 62], 인수 테스트 (고객 최종 확인) [60, 63].
    *   *형상 관리 (Configuration Management)*: SW 개발 과정의 모든 산출물 (문서, 데이터 등) 통합 관리 [59, 63].

## UML (Unified Modeling Language)
*   **개념**: 객체지향 SW 개발 방법론에서 시스템 분석/명세 위한 범용 모델링 언어 [64, 65]. 현실 세계 내용을 이해하기 쉽게 도식화 (개념 모델링) [64].
*   **중요성**: 시험 출제 빈번 [65].
*   **럼바우(Rumbaugh) 객체지향 분석 기법**:
    1.  **객체 모델링 (Object Modeling)**: 현실 세계 대상체 모델링 (정적 구조). 도출 산출물: **객체 다이어그램** [65-67].
    2.  **동적 모델링 (Dynamic Modeling)**: 대상체 상호작용 (행위). 도출 산출물: **상태 다이어그램**, **순차 다이어그램** 등 (움직임/상태 관련) [66-69].
    3.  **기능 모델링 (Functional Modeling)**: 데이터 흐름 표현. 도출 산출물: **데이터 흐름도** [66-68].
*   **UML의 장점**: 시각화, 문서화, 명세화, 구축에 사용 [68].
*   **UML 구성 요소**: 사물 (Things), 관계 (Relationships), 다이어그램 (Diagrams) [70].
*   **UML 다이어그램 분류**:
    *   **구조 다이어그램 (Structural Diagrams)**: 시스템의 정적 구조 표현. (예: **클래스 다이어그램**, 객체 다이어그램, 컴포넌트 다이어그램, 배치 다이어그램, 복합체 구조 다이어그램, 패키지 다이어그램) [69-71].
    *   **행위 다이어그램 (Behavioral Diagrams)**: 시스템의 동적 행위 표현. (예: **유스케이스 다이어그램**, 활동 다이어그램, 상태 머신 다이어그램, 상호작용 다이어그램 (순차, 통신, 상호작용 개요, 타이밍)) [69, 70, 72, 73].
*   **확장 메커니즘**: **스테레오타입 (Stereotype)** (<< >> 기호로 표현) [67, 70].
*   **가시성 (Visibility)**: 멤버 접근 수준 제어. public (+), private (-), protected (#), package (~) [74].
*   **관계 표현**:
    *   **연관 (Association)**: 객체 간 구조적 관계 (방향성 표현 가능) [73, 75, 76].
    *   **의존 (Dependency)**: 한 객체 변경이 다른 객체 영향 (짧은 시간 유지) [75, 77].
    *   **일반화 (Generalization)**: 상속 관계 [75-78]. 빈 화살표 사용 [75].
    *   **집합 (Aggregation/Composition)**: 전체-부분 관계 (Aggregation: 빈 마름모, Composition: 채워진 마름모 - 더 강한 포함 관계) [76, 77, 79].
    *   **실체화 (Realization)**: 인터페이스 구현 관계 (점선 화살표) [76, 79].
*   **유스케이스 다이어그램 (Use Case Diagram)**: 사용자 (Actor) 관점에서 시스템 행위 표현 [69, 73, 79, 80].
    *   **구성 요소**: 시스템 경계, 액터, 유스케이스 (행위), 관계 (연관, 포함(include), 확장(extend), 일반화) [80].
    *   **작성 단계**: 액터 식별 -> 유스케이스 식별 -> 관계 정의 -> 구조화 [78].

## 소프트웨어 아키텍처 품질 특성
*   **개념**: SW의 기능/성능 만족도 등 품질 수준 정의 [81]. SW 아키텍처가 잘 구성되어야 품질 확보 [81].
*   **ISO/IEC 9126 품질 모델**: SW 품질 평가 국제 표준 [81, 82].
    *   **내/외부 품질 (Internal/External Quality)**:
        *   **기능성 (Functionality)**: 적합성, 정확성, 상호 운용성, 보안성, 규정 준수 등 [81-83].
        *   **신뢰성 (Reliability)**: 성숙성, 결함 허용성, 회복성 등 [81-83].
        *   **사용성 (Usability)**: 이해성, **학습성**, 운용성, 친밀성 등 [81-84].
        *   **효율성 (Efficiency)**: 시간 특성, 자원 활용도 등 (성능, 자원 소요) [81-83, 85].
        *   **유지보수성 (Maintainability)**: 분석성, 변경성, 안정성, 시험성 등 [81-83].
        *   **이식성 (Portability)**: 적응성, 설치성, 공존성, 대체성 등 [81-83].
    *   **사용 품질 (Quality in Use)**: 효과성, 생산성, 안전성, 만족도 [81, 82].

## UI (User Interface) / UX (User Experience)
*   **UI (사용자 인터페이스)**: 사용자가 시스템과 상호작용하는 방식/매개체 [86, 87]. 실 사용자가 체감하는 부분, 만족도에 직접 영향 [87, 88].
    *   *분야*: 표현, 정보 제공, 기능 [87].
    *   *개발 시스템 기능*: 사용자 입력 검증, 에러 처리/메시지, 도움말/프롬프트 제공 [87, 89, 90].
    *   *설계 원칙*: **일관성**, **유효성** (버튼 크기 등), **학습성** (사용자가 익숙해짐), **유연성** (요구 수용), 오류 최소화 [89-91]. 사용자 중심, 단순성, 가시성, 표준화, 접근성, 예측 가능성, 명확성, 오류 발생 대처 [90, 91].
    *   *UI 표준/지침*: 개발자 간 협업 위한 최소한의 규칙 [91, 92]. SW 아키텍처 숙지 필요 [87].
    *   *한국형 웹 컨텐츠 접근성 지침 2.1 (4가지 원칙)*: **인식의 용이성**, **운용의 용이성**, **이해의 용이성**, **견고성** [92, 93].
*   **UX (사용자 경험)**: 사용자가 제품/시스템 사용하며 느끼고 생각하는 전체적 경험 [90, 94, 95].
    *   **감성 공학**과 관련: 인간의 감성/소망을 공학적으로 실현 (수치화 노력) [94, 96, 97].
    *   **HCI (Human-Computer Interaction)**: 인간과 컴퓨터 상호작용 연구 (목표: 컴퓨터 사용 용이성 증대) [97].
*   **UI 설계 단계**:
    1.  문제 정의 (시스템 목적, 해결 방안) [93, 98].
    2.  사용자 모델 정의 (사용자 특징, 학력 등) [98].
    3.  작업 분석 (사용자 작업 흐름, 유스케이스) [98, 99].
    4.  컴퓨터 오브젝트 및 기능 정의 [98].
    5.  사용자 인터페이스 정의 (디자인) [98].
    6.  **디자인 평가**:
        *   **GOMS**: 인지적/경험적/사회적 관점, 소요 시간/학습 시간 평가 [98, 100].
        *   **휴리스틱**: 논리적 근거 아닌 어림짐작 [98].
*   **UI 상세 설계 단계**:
    1.  **UI 메뉴 구조 설계** (가장 중요, 트리 구조 등) [99, 101].
    2.  내/외부 화면 및 폼 설계 [99].
    3.  검토 [99].
*   **시나리오 작성**: 사용자의 특정 작업 흐름 구체적 기술 [99, 102].
    *   *원칙*: 개발자 이해 용이성, 대표 화면 레이아웃/하위 기능 정의, 트리/플로 차트 이용, 공통 UI 요소/상호작용 규칙 정의, 상호작용 흐름/순서/분기/루프 명시 [99, 102].
    *   *작성 요건*: 완전성, 일관성, 이해성, 가독성, 수정 용이성, 추적성 [100, 102].
*   **UI 설계 도구**:
    *   **와이어프레임 (Wireframe)**: 기획 초기, 개략적 레이아웃/구성 손 또는 툴로 그림 [102, 103].
    *   **목업 (Mockup)**: 실제 제품과 유사한 시각적 모형 (기능 X) [101-104].
    *   **프로토타입 (Prototype)**: 상호작용/실제 작동 가능한 시제품 [95, 96, 100, 102, 103]. 요구사항 도출/분석/설계 등 다양한 단계에 사용 [96].
    *   **스토리보드 (Storyboard)**: 시간/흐름 기반 화면/상호작용 순서 나열 [101, 102, 104]. (핵심: 프로세스) [102].
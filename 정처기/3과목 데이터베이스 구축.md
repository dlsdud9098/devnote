1.  **자료구조 (Data Structures)**
    *   데이터를 어떻게 구성하느냐에 따라 달라집니다.
    *   **선형 자료구조 (Linear Data Structures)**: 데이터 요소들이 일직선 형태로 연결되는 구조입니다. 리스트 (목록), 스택 (Stack), 큐 (Queue), 데크 (Deque) 등이 해당됩니다.
        *   **리스트 (List)**: 순서대로 나열하는 선형 리스트와 중간에 주소(링크)를 넣어 연결하는 연결 리스트가 있습니다. 연결 리스트는 중간에 새로운 자료를 끼워 넣기 용이합니다.
        *   **스택 (Stack)**: 한쪽 끝(밑)이 막혀 있고, 입력된 순서의 역순으로 데이터가 출력되는 **후입선출 (LIFO: Last-In, First-Out)** 구조입니다. 메모리 상에서 복귀 주소나 특정 값을 저장해 두었다가 사용하며, **운영체제에서 인터럽트 처리 후 복귀 주소를 찾을 때 주로 사용**됩니다. 스택이 가득 찬 상태에서 데이터를 추가하려 할 때 **오버플로 (Overflow)**가 발생하며, 스택이 비어있는 상태에서 데이터를 삭제하려 할 때 **언더플로 (Underflow)**가 발생합니다. 삽입 시에는 탑(Top) 위치를 높여가며 데이터를 넣고, 삭제 시에는 탑 위치를 낮춰가며 데이터를 지웁니다.
        *   **큐 (Queue)**: 양쪽 끝이 열려 있고, 먼저 들어간 데이터가 먼저 나가는 **선입선출 (FIFO: First-In, First-Out)** 구조입니다. 프론트(Front)로 나가고 리어(Rear)에서 삽입됩니다.
        *   **데크 (Deque)**: 양쪽 끝에서 삽입과 삭제가 모두 가능한 구조입니다.
    *   **비선형 자료구조 (Non-linear Data Structures)**: 데이터 요소들이 복잡하게 연결되어 일직선 형태가 아닌 구조입니다. 트리 (Tree), 그래프 (Graph) 등이 해당됩니다.
        *   **트리 (Tree)**: 계층적인 구조를 가지며, 부모-자식 관계의 형태로 표현됩니다. 사이클(Cycle)이 없는 구조입니다. 주요 용어로는 노드 (Node), 레벨 (Level), 조상 노드, 부모 노드, 자식 노드, 차수 (Degree - 가장 많은 자식 수), 단말 노드 (Leaf Node) 등이 있습니다. 이진 트리 (Binary Tree)는 차수가 2 이하인 노드로만 구성된 트리입니다.
        *   **트리 순회 (Tree Traversal)**: 트리의 노드들을 특정 순서로 방문하는 방법입니다. **전위 순회 (Preorder Traversal)**는 루트(Root)를 먼저 방문한 후 왼쪽 서브트리, 오른쪽 서브트리 순서로 방문합니다. **중위 순회 (Inorder Traversal)**는 왼쪽 서브트리, 루트, 오른쪽 서브트리 순서입니다. **후위 순회 (Postorder Traversal)**는 왼쪽 서브트리, 오른쪽 서브트리, 루트 순서입니다. 루트가 앞에 오면 전위, 중간에 오면 중위, 뒤에 오면 후위라고 기억하면 쉽습니다. 수식의 표기 방법에도 전위, 중위, 후위 표기법이 있으며, 이때 연산자(+, -, *, / 등)가 루트의 역할을 합니다.
        *   **그래프 (Graph)**: 노드(정점)와 간선으로 구성되며, 사이클이 존재할 수 있는 구조입니다.

2.  **인덱스 (Index) 및 파일 편성 (File Organization)**
    *   **인덱스 (Index)**: 데이터베이스에서 **데이터를 빨리 검색할 수 있도록 도와주는 별도의 테이블 (인덱스 테이블)**입니다. 책의 맨 뒤에 있는 찾아보기와 같은 역할을 합니다. 데이터의 검색 성능에 영향을 줍니다. 인덱스 구성 방식에는 B-트리 방식과 B+트리 방식 등이 있으며, 현재는 B+트리 방식을 주로 사용합니다.
    *   **파일 편성 (File Organization)**: 데이터를 저장하는 방식입니다.
    *   **색인 순차 파일 (Indexed Sequential File - ISAM)**: 인덱스를 적용하여 사용하는 파일 방식입니다. 기본 영역 (데이터 본문), 색인 영역 (인덱스), **오버플로 영역 (Overfow Area)**이 필요합니다. 색인 영역은 디스크의 물리적 특성에 따라 트랙 색인, 실린더 색인, 마스터 색인의 3단계로 구성됩니다. 레코드 삽입/삭제 시 파일 전체를 재구성할 필요 없이 인덱스와 오버플로 영역을 활용합니다.
    *   **VSAM (Virtual Storage Access Method)**: 동적인 인덱스 방식을 사용하며, 기본 영역과 오버플로 영역의 범위를 별도로 지정하지 않습니다.
    *   **직접 파일 (Direct File)**: 해싱 함수를 사용하여 레코드 키에 의한 주소 계산을 통해 레코드에 직접 접근하는 방식입니다.
    *   **역 파일 (Inverted File)**: 특정 파일을 여러 개의 색인으로 만들고 항목별 특성에 맞게 작업하도록 한 것입니다.
    *   **정적 인덱싱 (Static Indexing)**과 **동적 인덱싱 (Dynamic Indexing)**: 정적 인덱싱은 데이터 변경 시 인덱스 내용은 변하지만 구조는 변하지 않습니다. 동적 인덱싱은 데이터 변경 시 인덱스 구조도 함께 변경될 수 있습니다.

3.  **정렬 (Sorting)**
    *   어떤 값들을 순서대로 나열하는 것입니다. 내부 정렬 (메모리 내부)과 외부 정렬 (보조기억장치)이 있습니다.
    *   **삽입 정렬 (Insertion Sort)**: 정렬된 부분에 새로운 데이터를 삽입하며 정렬합니다. 키 값(보통 두 번째 값부터 시작)을 기준으로 자신보다 앞에 있는 데이터와 비교하며 적절한 위치에 삽입합니다.
    *   **버블 정렬 (Bubble Sort)**: 인접한 두 개의 데이터를 비교하여 자리를 바꾸는 과정을 반복합니다. 한 번의 회전마다 가장 큰(또는 작은) 값이 뒤(또는 앞)로 정렬됩니다.
    *   **선택 정렬 (Selection Sort)**: 데이터에서 가장 작은(또는 큰) 값을 찾아 맨 앞(또는 뒤)으로 옮기는 과정을 반복합니다. 한 번의 회전마다 가장 작은(또는 큰) 값이 맨 앞으로(또는 뒤로) 정렬됩니다.
    *   **시간 복잡도 (Time Complexity)**: 정렬 알고리즘의 효율성을 나타내는 지표입니다. 선택 정렬과 퀵 정렬의 최악 시간 복잡도는 O(n^2) 입니다. 병합 정렬과 힙 정렬의 평균 시간 복잡도는 O(n log n) 입니다. 퀵 정렬도 평균적으로는 O(n log n) 입니다.
    *   정렬된 n개의 데이터를 처리하는 데 O(n log n)의 시간 복잡도를 갖는 대표적인 정렬 알고리즘은 **병합 정렬, 힙 정렬, 퀵 정렬**입니다.

4.  **검색 (Search) 및 해싱 (Hashing)**
    *   **검색 (Search)**: 자료를 찾는 것입니다. 이분 검색 (이진 검색), 선형 검색 (순차 검색), 피보나치 검색 등이 있습니다. **이진 검색은 기본적으로 데이터가 정렬되어 있어야 합니다**.
    *   **해싱 (Hashing)**: 데이터를 해싱 함수를 사용하여 고정된 크기의 홈 주소(Home Address)로 변환하여 저장하고 검색하는 기법입니다. 데이터를 빠르게 찾아낼 때 사용합니다. 해싱 과정에서 서로 다른 키가 같은 홈 주소를 가지는 **충돌 (Collision)** 현상이 발생할 수 있으며, 이때 **오버플로 (Overflow)**가 발생할 수 있습니다. 충돌로 인해 동일한 홈 주소를 갖는 레코드 집합을 **동의어 (Synonym)**라고 합니다. 슬롯 (Slot)은 한 개의 레코드를 저장할 수 있는 공간이며, 버킷 (Bucket)은 여러 개의 슬롯으로 구성된 공간입니다.

5.  **데이터베이스 시스템 (Database System)**
    *   **데이터베이스 (Database - DB)**: 여러 곳에 나눠져 있던 자료를 통합하여 저장하고, 운영하며, 여러 사람이 공유하기 위해 모아 놓은 관련 있는 데이터들의 집합입니다.
    *   **데이터베이스의 특성**: **실시간 접근 가능**, **내용에 의한 참조** (주소에 의한 것이 아님), **동시 공유 가능**, **계속적인 변화** (갱신).
    *   **DBMS (Database Management System)**: 데이터베이스를 관리하는 소프트웨어(일종의 서버)입니다.
    *   **DBMS의 필수 기능**:
        *   **정의 기능 (DDL)**: 데이터베이스 구조(스키마), 데이터 타입, 제약조건 등을 정의합니다. 테이블 구조를 만드는 것과 같습니다.
        *   **조작 기능 (DML)**: 데이터 삽입, 삭제, 수정, 검색 등을 수행합니다. 표에 데이터를 넣거나 빼거나 검색하는 것과 같습니다.
        *   **제어 기능 (DCL)**: 데이터 보안 (권한 제어), 무결성 유지, 병행 제어 등을 수행합니다. 중요한 정보에 대한 접근 권한을 제어하거나, 여러 사람이 동시에 데이터를 공유할 때 문제가 발생하지 않도록 제어합니다.
    *   **DBMS 사용 시 장점**: 데이터 중복 및 종속성 최소화, 데이터 공유, 무결성 보장, 일관성 유지, 데이터 보안.
    *   **DBMS 사용 시 단점**: 데이터 손실 위험, 전문가 부족, 시스템 복잡성, 전산화 비용 발생.
    *   **데이터 웨어하우스 (Data Warehouse)**: 대량의 데이터를 모아 놓은 저장소로, 분석에 사용됩니다. **OLAP (Online Analytical Processing)**은 데이터 웨어하우스의 데이터를 분석하는 도구이며, 롤업 (Roll-up), 드릴다운 (Drill-down), 다이싱 (Dicing), 슬라이싱 (Slicing) 등의 연산을 수행합니다.
    *   **데이터 마이닝 (Data Mining)**: 대량의 데이터에서 의미 있는 패턴이나 관계를 찾아내는 기법입니다.
    *   **하둡 (Hadoop)**: 빅데이터 분산 처리를 위한 오픈 프레임워크입니다. 슈퍼컴퓨터가 아닌 소규모 컴퓨터들을 연결하여 사용합니다.
    *   **스키마 (Schema)**: 데이터베이스의 **구조 및 제약조건에 대한 정의**입니다.
        *   **스키마 3단계**:
            *   **외부 스키마 (External Schema)**: 사용자나 응용 프로그래머에게 보여지는 데이터베이스의 부분적인 뷰를 정의합니다. 사용자에 따라 다를 수 있습니다.
            *   **개념 스키마 (Conceptual Schema)**: 데이터베이스 전체의 논리적인 구조를 정의합니다. 모든 사용자가 보는 통합된 뷰이며, **가장 중요**합니다.
            *   **내부 스키마 (Internal Schema)**: 물리적 저장 장치에 데이터가 실제로 어떻게 저장되는지를 정의합니다.
    *   **데이터 모델 (Data Model)**: 현실 세계의 데이터를 컴퓨터에 저장하기 쉽도록 구조화하는 논리적 개념입니다. 데이터 구조, 연산, 제약조건 등의 요소를 포함합니다.
    *   **데이터 모델 종류**:
        *   **개념적 데이터 모델 (Conceptual Data Model)**: 현실 세계를 이해하고 도식화합니다. **ER 모델 (Entity-Relationship Model)**이 대표적이며, 피터 첸(Peter Chen)이 제안했습니다. 개체 (Entity - 사각형), 속성 (Attribute - 타원), 관계 (Relationship - 마름모), 연결선 등으로 표현합니다.
        *   **논리적 데이터 모델 (Logical Data Model)**: 개념적 모델을 특정 DBMS가 지원하는 데이터 모델로 변환합니다. **관계형 모델 (Relational Model - 테이블 형태)**, 계층형 모델 (Hierarchical Model - 트리 형태), 네트워크형 모델 (Network Model - 망 형태), 객체지향형 모델 (Object-Oriented Model), 객체-관계형 모델 (Object-Relational Model - ORDBMS) 등이 있습니다.

6.  **관계형 데이터베이스 모델 (Relational Database Model)**
    *   데이터를 **테이블 (Table) 형태로 표현**합니다.
    *   **용어**:
        *   **릴레이션 스키마 (Relation Schema)**: 릴레이션(테이블)의 구조를 정의합니다 (예: 학번, 이름, 학과, 학년).
        *   **속성 (Attribute)**: 테이블의 열(Column)입니다 (예: 학번, 이름). 파일 시스템에서는 필드(Field)라고 합니다.
        *   **투플 (Tuple)**: 테이블의 행(Row)입니다 (예: 특정 학생의 학번, 이름, 학과, 학년 정보 한 줄). 파일 시스템에서는 레코드(Record)라고 합니다.
        *   **도메인 (Domain)**: 하나의 속성이 가질 수 있는 값의 범위입니다 (예: 학년 속성은 1~4학년만 가능).
        *   **차수 (Degree)**: 릴레이션에 포함된 **속성의 개수**입니다.
        *   **카디널리티 (Cardinality)**: 릴레이션에 포함된 **투플의 개수**입니다.
    *   **릴레이션의 특징**: 투플은 유일해야 합니다. 투플 순서는 의미 없습니다. 속성의 원자성 (하나의 속성은 하나의 값만 가짐).
    *   **키 (Key)**: 릴레이션에서 각 투플을 유일하게 식별하거나, 다른 릴레이션의 투플을 참조하는 데 사용되는 하나 이상의 속성 집합입니다.
        *   **슈퍼 키 (Super Key)**: 릴레이션 내의 모든 투플을 유일하게 식별할 수 있는 속성들의 집합입니다. 유일성은 만족하지만 최소성은 만족하지 않을 수 있습니다.
        *   **후보 키 (Candidate Key)**: 투플을 유일하게 식별할 수 있으면서, 최소성을 만족하는 속성들의 집합입니다. 즉, 슈퍼 키 중에서 속성 하나를 제거해도 유일성이 유지되면 후보 키가 아닙니다. 유일성과 최소성을 모두 만족해야 합니다.
        *   **기본 키 (Primary Key)**: 후보 키 중에서 **선택된 하나**의 키입니다.
        *   **대체 키 (Alternate Key)**: 후보 키 중에서 기본 키로 선택되지 않은 나머지 후보 키들입니다.
        *   **외래 키 (Foreign Key)**: **다른 릴레이션의 기본 키를 참조**하는 속성 또는 속성 집합입니다. 릴레이션들 간의 관계를 표현하는 데 사용됩니다.
    *   **무결성 제약조건 (Integrity Constraints)**: 데이터베이스에 저장된 데이터의 정확성과 일관성을 유지하기 위한 규칙입니다.
        *   **개체 무결성 (Entity Integrity)**: **기본 키**에 대한 제약조건입니다. 기본 키를 구성하는 어떤 속성도 **널(NULL) 값이거나 중복된 값을 가질 수 없습니다**.
        *   **참조 무결성 (Referential Integrity)**: **외래 키**에 대한 제약조건입니다. 외래 키 값은 **참조하는 릴레이션의 기본 키 값으로 존재**하거나 **널(NULL) 값**이어야 합니다. 참조하는 테이블에 없는 데이터가 참조되는 테이블에 존재할 수 없다는 의미입니다.
        *   **도메인 무결성 (Domain Integrity)**: 특정 속성 값이 **도메인 범위 내에** 있어야 한다는 제약조건입니다.

7.  **데이터베이스 설계 (Database Design) 및 정규화 (Normalization)**
    *   **데이터베이스 설계 단계**:
        *   **요구사항 분석**: 사용자의 요구사항을 수집하고 분석합니다.
        *   **개념 설계 (Conceptual Design)**: 현실 세계의 데이터를 개념적으로 표현합니다. **ER 모델**을 사용하여 도식화합니다.
        *   **논리 설계 (Logical Design)**: 개념적 모델을 특정 DBMS의 논리적 모델(예: 관계형 모델)로 매핑합니다. 테이블 구조를 설계합니다.
        *   **물리 설계 (Physical Design)**: 논리적 모델을 실제 물리적 저장 장치에 저장하기 위한 세부 사항을 정의합니다. 파일 구조, 인덱스, 접근 경로, 저장 방식 등을 결정합니다.
        *   **구현 (Implementation)**: 설계된 데이터베이스를 실제 DBMS를 사용하여 구축합니다.
        *   **운영 및 유지보수**: 구축된 데이터베이스 시스템을 운영하고 관리합니다.
        *   **설계 순서**: **요구사항 분석 -> 개념 설계 -> 논리 설계 -> 물리 설계 -> 구현 -> 운영 및 유지보수**. "개.논.물"로 기억하면 쉽습니다.
    *   **정규화 (Normalization)**: 관계형 데이터베이스 설계 시 데이터 중복을 최소화하고, 이상 현상(Anomalies)을 제거하여 데이터 구조의 안정성을 확보하는 과정입니다. 비정규 릴레이션을 여러 개의 정규화된 릴레이션으로 분해합니다.
    *   **이상 현상 (Anomalies)**: 정규화되지 않은 테이블에서 데이터 삽입, 삭제, 갱신 시 발생하는 논리적인 모순입니다. 삽입 이상, 삭제 이상, 갱신 이상이 있습니다.
    *   **함수적 종속 (Functional Dependency)**: 속성 집합 X가 속성 집합 Y를 결정하는 경우, X를 결정자(Determinant), Y를 종속자(Dependent)라고 합니다. "X -> Y"로 표기하며, Y가 X에 함수적으로 종속된다고 합니다.
    *   **정규형 (Normal Forms)**: 정규화의 단계입니다.
        *   **1차 정규형 (1NF)**: 모든 속성 값이 원자 값(Atomic Value)이어야 합니다. 반복 그룹이나 복합 속성을 분해합니다.
        *   **2차 정규형 (2NF)**: 1차 정규형을 만족하고, **부분 함수적 종속 (Partial Functional Dependency)**을 제거해야 합니다. 기본 키의 일부에만 종속되는 속성이 없어야 합니다.
        *   **3차 정규형 (3NF)**: 2차 정규형을 만족하고, **이행 함수적 종속 (Transitive Functional Dependency)**을 제거해야 합니다. 결정자가 후보 키가 아닌 속성에 종속되는 다른 속성이 없어야 합니다. (X -> Y, Y -> Z 일 때 X -> Z 관계).
        *   **BCNF (Boyce-Codd Normal Form)**: 3차 정규형보다 강화된 형태입니다. 모든 **결정자(Determinant)가 후보 키(Candidate Key)**여야 합니다. '강한 3차 정규형'이라고도 합니다.
        *   **4차 정규형 (4NF)**: BCNF를 만족하고, 다치 종속 (Multi-valued Dependency)을 제거해야 합니다.
        *   **5차 정규형 (5NF)**: 4차 정규형을 만족하고, 조인 종속 (Join Dependency)을 제거해야 합니다.

8.  **반정규화 (Denormalization) 및 클러스터링 (Clustering)**
    *   **반정규화 (Denormalization)**: 정규화된 테이블을 다시 통합하거나 분할하여 **데이터 중복을 의도적으로 허용**함으로써 **성능 향상**과 개발 및 운영의 단순화를 목표로 하는 기법입니다. 데이터 무결성 보장과는 거리가 있습니다.
    *   **반정규화 기법**:
        *   **테이블 병합**: 1:1 관계, 1:N 관계의 일부, 슈퍼-서브 타입 관계 등을 병합합니다.
        *   **테이블 분할 (Partitioning)**: 디스크 입출력량 감소, 특정 트랜잭션 집중 방지 등을 위해 테이블을 나눕니다. 수직 분할 (Vertical Partitioning - 속성/열 기준 분할), 수평 분할 (Horizontal Partitioning - 투플/행 기준 분할). 수평 분할 기법에는 범위 분할, 해시 분할, 합성 분할, 라운드 로빈 분할 등이 있습니다.
        *   **테이블 추가**: 중복 테이블, 집계 테이블 (합계, 평균 등 미리 계산), 이력 테이블, 진행 테이블, 부분 테이블 등을 추가합니다.
        *   **컬럼 반정규화**: 중복 컬럼, 파생 컬럼 등을 추가합니다.
        *   **관계 반정규화**: 관계 중복 관계를 추가합니다.
    *   **클러스터링 (Clustering)**: 데이터 조회의 속성을 높이기 위해 자주 함께 사용되는 데이터를 물리적으로 인접하게 저장하는 기법입니다.

9.  **관계 대수 (Relational Algebra) 및 SQL (Structured Query Language)**
    *   **관계 대수 (Relational Algebra)**: 관계형 데이터베이스에서 원하는 결과를 얻기 위해 데이터를 처리하는 **절차적 언어**입니다.
        *   **순수 관계 연산자**: 선택(Select - σ), 프로젝트(Project - π), 조인(Join - ⋈), 디비전(Division - ÷). **선택**은 투플(행)을 검색하는 **수평적 연산**. **프로젝트**는 속성(열)을 추출하는 **수직적 연산**. **조인**은 두 릴레이션을 공통 속성으로 연결하여 합치는 연산.
        *   **집합 연산자**: 합집합(Union - ∪), 교집합(Intersection - ∩), 차집합(Difference - -), 교차곱(Cartesian Product - ×). 교차곱은 두 릴레이션의 모든 투플을 조합하여 새로운 투플을 생성합니다. 결과 투플 수는 두 릴레이션의 카디널리티를 곱한 값이고, 결과 속성 수는 두 릴레이션의 차수를 더한 값입니다 (단, 중복 속성 제외).
    *   **SQL (Structured Query Language)**: 관계형 데이터베이스를 조작하기 위한 **비절차적 언어**입니다. 표준화되어 있으며, DDL, DML, DCL 기능을 제공합니다.
        *   **DDL (Data Definition Language)**: CREATE (생성 - 테이블, 뷰, 인덱스 등), ALTER (변경 - 테이블 구조 변경, 컬럼 추가/삭제 등), DROP (삭제 - 테이블, 뷰, 인덱스 등). DROP 시 다른 개체와 연결되어 있는 경우 CASCADE (연쇄 삭제) 또는 RESTRICT (삭제 금지) 옵션을 사용할 수 있습니다.
        *   **DCL (Data Control Language)**: 데이터 보안, 무결성, 병행 제어 등을 위한 명령어입니다. GRANT (권한 부여), REVOKE (권한 해제). 트랜잭션 제어 (COMMIT - 확정, ROLLBACK - 취소/되돌림)도 DCL에 포함됩니다.
        *   **DML (Data Manipulation Language)**: 데이터 검색, 삽입, 삭제, 갱신 등을 위한 명령어입니다.
            *   **SELECT**: 데이터 검색. `SELECT [DISTINCT] 속성 FROM 테이블 [WHERE 조건] [GROUP BY 속성] [HAVING 조건] [ORDER BY 속성]`. **WHERE 절**은 조건에 맞는 **투플(행)을 검색**할 때 사용하며, 내용에 의한 참조 방식입니다. **GROUP BY 절**은 특정 속성을 기준으로 **그룹화**할 때 사용합니다. **HAVING 절**은 **그룹화된 데이터에 대한 조건**을 지정할 때 사용하며, 반드시 GROUP BY 절과 함께 사용해야 합니다. **ORDER BY 절**은 결과를 특정 속성으로 정렬(ASC: 오름차순, DESC: 내림차순)합니다. **DISTINCT**는 중복된 결과를 제거합니다.
            *   **INSERT**: 데이터 삽입. `INSERT INTO 테이블 (속성1, 속성2, ...) VALUES (값1, 값2, ...)` 또는 `INSERT INTO 테이블 SELECT ...`.
            *   **UPDATE**: 데이터 갱신. `UPDATE 테이블 SET 속성1 = 값1, 속성2 = 값2, ... [WHERE 조건]`.
            *   **DELETE**: 데이터 삭제. `DELETE FROM 테이블 [WHERE 조건]`.
            *   **전치사**: SQL 문법에서 사용되는 중요한 키워드입니다. `SELECT ~ FROM`, `INSERT INTO ~ VALUES`, `DELETE FROM`, `UPDATE ~ SET`.
            *   **집계 함수 (Aggregate Functions)**: 그룹별 통계 계산에 사용됩니다. COUNT (개수), SUM (합계), AVG (평균), MAX (최대값), MIN (최소값) 등이 있습니다.
            *   **LIKE**: 문자열 검색 시 패턴 매칭에 사용됩니다.
            *   **BETWEEN A AND B**: A부터 B까지의 범위 조건을 지정할 때 사용됩니다. A와 B를 포함합니다.
            *   **하위 질의 (Subquery)**: 다른 SQL 문 내에 포함되는 SELECT 문입니다. 조건절(WHERE, HAVING)이나 FROM 절 등에서 사용될 수 있습니다. `IN` 연산자와 함께 자주 사용됩니다.

10. **뷰 (View) 및 시스템 카탈로그 (System Catalog)**
    *   **뷰 (View)**: 하나 이상의 기본 테이블로부터 유도된 **가상의 테이블**입니다. 물리적으로 데이터를 저장하고 있지 않습니다. 사용자에게 기본 테이블의 특정 부분만 보여주어 보안을 제공하고 데이터 접근을 편리하게 합니다. **ALTER 문을 사용하여 뷰 구조를 변경할 수 없으며, 삭제 후 다시 생성해야 합니다**. 뷰 위에 다른 뷰를 생성할 수 있습니다.
    *   **시스템 카탈로그 (System Catalog)**: DBMS가 데이터베이스에 저장된 모든 데이터 개체(테이블, 뷰, 인덱스 등) 및 그들의 구조, 제약조건, 권한 등에 대한 정보를 저장하는 **시스템 테이블**입니다. **데이터 사전 (Data Dictionary)** 또는 **메타데이터 (Metadata)**라고도 합니다. **DBMS가 스스로 관리하며, 사용자가 직접 내용을 갱신할 수 없습니다**.

11. **트랜잭션 (Transaction) 및 병행 제어 (Concurrency Control)**
    *   **트랜잭션 (Transaction)**: 데이터베이스의 **논리적인 작업 단위**입니다. 완전히 성공하거나 완전히 실패해야 합니다. 예를 들어, 계좌 이체 시 출금과 입금이 모두 성공하거나, 둘 다 실패하여 원래 상태로 되돌아가야 합니다.
    *   **트랜잭션의 특성 (ACID)**:
        *   **원자성 (Atomicity)**: 트랜잭션 내의 모든 연산은 완전히 실행되거나 전혀 실행되지 않아야 합니다. 트랜잭션은 더 이상 분해될 수 없는 원자적인 단위입니다.
        *   **일관성 (Consistency)**: 트랜잭션 실행 전후에 데이터베이스는 항상 일관된 상태를 유지해야 합니다. 무결성 제약조건 등을 위반하지 않아야 합니다.
        *   **고립성 / 격리성 (Isolation)**: 여러 트랜잭션이 동시에 실행될 때, 서로에게 영향을 주지 않고 독립적으로 수행되는 것처럼 보여야 합니다.
        *   **지속성 / 영속성 (Durability)**: 트랜잭션이 성공적으로 완료(COMMIT)된 후에는 시스템 오류가 발생하더라도 그 결과가 영구적으로 데이터베이스에 반영되어야 합니다.
    *   **CRUD 매트릭스 (CRUD Matrix)**: 데이터베이스 시스템에서 개체(테이블)와 프로세스(트랜잭션) 간의 상호작용(Create, Read, Update, Delete)을 분석하기 위한 도구입니다.
    *   **회복 (Recovery)**: 시스템 장애 발생 시 데이터베이스를 일관된 상태로 복구하는 작업입니다. 즉각 갱신법 (Immediate Update)은 트랜잭션 완료 전에 데이터베이스에 반영하며, 회복을 위해 로그 기록이 필요합니다.
    *   **트랜잭션 상태**: 시작 (Start) -> 활동 (Active) -> 부분 완료 (Partially Committed) -> 완료 (Committed) 또는 실패 (Failed) -> 처리 (Aborted).
    *   **병행 제어 (Concurrency Control)**: 여러 트랜잭션이 동시에 데이터베이스에 접근할 때, 데이터의 일관성을 유지하고 트랜잭션의 고립성을 보장하기 위한 제어 기법입니다. **동시성 제어**라고도 합니다.
    *   **병행 제어 기법**:
        *   **로킹 (Locking)**: 트랜잭션이 데이터를 접근할 때, 다른 트랜잭션이 접근하지 못하도록 해당 데이터에 잠금을 설정하는 기법입니다. 로킹 단위(파일, 테이블, 레코드, 필드 등)에 따라 관리 용이성과 병행성 수준이 달라집니다. 로킹 단위가 클수록 관리 용이하나 병행성이 떨어지고, 작을수록 관리 복잡성이 증가하나 병행성은 높아집니다.
        *   **2단계 로킹 (Two-Phase Locking - 2PL)**: 트랜잭션이 모든 잠금을 획득하는 **확장 단계 (Expanding Phase)**와 모든 잠금을 해제하는 **축소 단계 (Shrinking Phase)**로 나뉩니다. 직렬성(Serializability)을 보장하지만, 교착 상태(Deadlock - 서로 필요한 자원을 무한정 기다리는 상태)가 발생할 수 있습니다.
        *   **타임스탬프 기법 (Timestamp Ordering)**: 트랜잭션마다 고유한 시간 스탬프를 부여하여, 그 순서대로 작업을 수행하도록 제어합니다. 직렬화를 보장하며, 교착 상태가 발생하지 않습니다.

12. **데이터베이스 보안 (Database Security) 및 분산 데이터베이스 (Distributed Database)**
    *   **데이터베이스 보안**: 데이터의 무결성, 기밀성, 가용성 등을 유지하기 위한 기술입니다.
    *   **암호화 (Encryption)**: 데이터를 제3자가 읽을 수 없는 형태로 변환하는 기법입니다.
        *   **비밀 키 암호화 (Secret Key Encryption)**: 암호화 키와 복호화 키가 **동일**합니다. **대칭 키 암호화**라고도 합니다. DES, AES 등이 있습니다.
        *   **공개 키 암호화 (Public Key Encryption)**: 암호화 키와 복호화 키가 **서로 다릅니다**. **비대칭 키 암호화**라고도 합니다. RSA 등이 있습니다. 공개 키는 공개되어도 안전합니다.
    *   **접근 제어 (Access Control)**: 데이터베이스 객체에 대한 사용자별 권한을 부여하고 관리합니다. GRANT (권한 부여), REVOKE (권한 해제) 명령어를 사용합니다. `WITH GRANT OPTION`을 사용하면 권한을 부여받은 사용자가 다른 사용자에게도 해당 권한을 부여할 수 있습니다.
    *   **트리거 (Trigger)**: 특정 이벤트(INSERT, UPDATE, DELETE 등) 발생 시 DBMS가 자동으로 수행하는 절차입니다. 데이터 무결성 유지 등을 위해 사용될 수 있습니다.
    *   **분산 데이터베이스 (Distributed Database - DDB)**: 지리적으로 분산된 여러 컴퓨터에 데이터베이스를 저장하고 관리하는 시스템입니다.
    *   **분산 데이터베이스의 목표 (투명성 - Transparency)**:
        *   **위치 투명성 (Location Transparency)**: 사용자는 데이터가 어디에 저장되어 있는지 몰라도 접근할 수 있습니다.
        *   **중복 투명성 / 복제 투명성 (Replication Transparency)**: 동일한 데이터가 여러 곳에 중복되어 저장되어 있음을 사용자가 몰라도 됩니다.
        *   **병행 투명성 (Concurrency Transparency)**: 여러 사용자가 동시에 데이터에 접근하더라도 문제없이 트랜잭션을 수행할 수 있습니다. 병행 제어가 필요합니다.
        *   **장애 투명성 (Failure Transparency)**: 일부 시스템에 장애가 발생해도 데이터의 무결성이 보장되며 시스템이 정상적으로 작동합니다.

이 외에도 소스에서는 데이터웨어하우스의 OLAP 연산(롤업, 드릴다운, 다이싱, 슬라이싱), 데이터 마이닝, 하둡, NoSQL 등 빅데이터 관련 개념들도 다루고 있습니다.

3과목은 데이터베이스의 기본적인 개념부터 설계, 구현, 활용, 관리, 보안에 이르기까지 넓은 범위를 다루고 있습니다. 특히 **자료구조 (스택, 큐, 트리 순회 등)**, **관계형 데이터베이스 모델 용어 (차수, 카디널리티, 키 종류)**, **무결성 제약조건**, **데이터베이스 설계 단계**, **정규화 단계와 이상 현상/함수적 종속**, **관계 대수 연산자**, **SQL 기본 문법 (SELECT, INSERT, UPDATE, DELETE, WHERE, GROUP BY, HAVING, ORDER BY 등)**, **트랜잭션 특성 (ACID)**, **병행 제어 (로킹, 2단계 로킹, 타임스탬프)**, **분산 데이터베이스 투명성** 등은 시험에 자주 출제되는 핵심 개념들이니 꼼꼼히 학습하시는 것이 좋습니다.

이 내용들이 3과목을 학습하는 데 도움이 되기를 바랍니다. 추가로 궁금한 점이 있으시면 언제든지 질문해주세요.
### 1. 소프트웨어 공학 개요

*   **소프트웨어(Software) 개념**: 어플리케이션, 프로그램 등 컴퓨터에서 사용되는 모든 프로그램.
*   **소프트웨어 특징**:
    *   상품성: 만들었을 때 구매자가 있어야 함.
    *   복잡성: 개발 과정이 다양한 단계를 가짐.
    *   변경 가능성: 업데이트를 통해 변경 가능.
    *   복제 및 유통 용이성: 쉽게 복제하고 유통할 수 있음.
*   **시스템(System) 개요**: 하나의 조직을 의미 (예: 컴퓨터 시스템).
*   **시스템 기본 요소**: 시험 문제 출제 빈도 높음.
    *   **입력 (Input)** -> **처리 (Process)** -> **출력 (Output)**.
    *   내부에서 **제어 (Control)** 발생.
    *   결과에 대한 **피드백 (Feedback)**.
    *   이 그림(입력-처리-출력, 제어, 피드백)을 기억할 것.
*   **소프트웨어 위기 (Software Crisis)**:
    *   **원인**:
        *   개발 비용 초과 및 증가 (소프트웨어 복잡도 증가, 많은 개발 인력 필요).
        *   개발 기간 지연.
        *   개발 인력 부족.
        *   인건비 상승.
        *   성능 및 신뢰성 부족.
        *   유지보수 어려움 및 엄청난 비용 발생.
    *   **소프트웨어에서 가장 중요한 부분은 유지보수 비용** (개발 비용보다 더 많이 들 수 있음). (예: 윈도우즈 업데이트 비용).
*   **소프트웨어 공학(Software Engineering)**:
    *   소프트웨어 위기 상황에서 적은 비용으로 빠르고, 쉽게, 정확하게 소프트웨어를 만드는 방법에 대한 학문.
    *   소프트웨어 개발, 운영, 유지보수, 폐기까지의 전체적인 체계적인 접근 방법.
    *   소프트웨어 제품을 체계적으로 생산/유지보수하는 기술 및 경영 학문.
    *   과학적 지식을 컴퓨터 프로그램 설계/제작에 적용하는 것.
    *   **소프트웨어 위기를 *해결한* 학문이 아님**.
*   **소프트웨어 공학 기본 원칙**:
    *   현대적인 프로그래밍 기술 적용.
    *   **신뢰성(Reliability)**: 소프트웨어가 예상대로 정확하게 작동하는 능력. (예: 구구단 계산 결과의 정확성).
    *   사용의 편의성.
    *   유지 보수성 향상.
    *   지속적인 검증.
*   **소프트웨어 위기를 가져온 원인으로 옳지 않은 것**: 수요 감소. (현실에서는 소프트웨어 수요가 많음).
*   **소프트웨어 공학의 기본 원칙으로 볼 수 없는 것**: 최대한 많은 인력 투입 (비용 증가).

---

### 2. 소프트웨어 재공학 및 CASE

*   **소프트웨어 재공학(Software Reengineering)**:
    *   기존에 만들어진 소프트웨어를 다시 사용하여 개발 시간, 비용 감소, 품질 및 생산성 향상, 프로젝트 실패 위험 감소 등을 목표로 함.
    *   **프로젝트 실패 위험 감소**: 이미 한번 검증된 소프트웨어를 다시 사용하기 때문.
    *   **최우선 목표**: 소프트웨어 유지 보수성 향상.
    *   복잡한 시스템 처리, 다른 뷰 생성, 잃어버린 정보 복구, 재사용 용이성을 통해 소프트웨어 수명 연장.
    *   **결론**: 잘 바꿔서 다시 사용하자는 의미.
*   **소프트웨어 재공학 과정**:
    *   **분석(Analysis)**: 재사용 가능성 분석.
    *   **구성 변경(Restructuring)**: 구조 변경.
    *   **역공학(Reverse Engineering)**: 기존 소프트웨어를 거꾸로 분석하여 코드, 작동 방식 등을 파악. (핵심은 문서화).
    *   **순공학(Forward Engineering)**: 분석된 내용을 실제 적용.
*   **재공학 vs 재개발**: 재개발은 아예 처음부터 다시 만드는 것 (다 부시고 다시 짓는 것).
*   **재공학의 장점 (재개발 대비)**: 위험 부담 감소, 비용 절감, 명세 오류 억제, **개발 시간 감소**. (개발 시간 증가는 잘못된 설명).
*   **CASE (Computer-Aided Software Engineering)**:
    *   소프트웨어 엔지니어링을 도와주는 자동화 도구. (CAD: 컴퓨터 설계 도와주는 도구).
    *   소프트웨어 개발의 속도, 정확성, 품질 향상.
    *   소프트웨어 생명 주기 전체 단계를 연결하고 자동화/통합.
    *   문서화 및 명세화를 위한 그래픽 기능 제공.
    *   개발 단계 표준화, 자료 흐름도 작성, 모델 간 모순 검사 기능 제공.
    *   다양한 소프트웨어 개발 모형 지원.
    *   **원천 기술**: 구조적 기법, 프로토타입 기법, 정보 저장소 기술.
    *   **장점**: 개발 기간/비용 감소, 생산성 향상.
    *   **역할**: 소프트웨어 설계, 구현, 유지보수 등 전체 관리 및 문서화 지원.
*   **CASE 분류**:
    *   **상위 CASE (Upper CASE)**: 요구 분석 및 설계 등 초기 단계 지원.
    *   **하위 CASE (Lower CASE)**: 구현(코딩) 등 실제 개발 단계 지원.
    *   **통합 CASE (Integrated CASE)**: 소프트웨어 개발 주기 전체 과정 관리.
*   **구조적 분석 및 설계 도구**: **SADT (Structured Analysis and Design Technique)**.
    *   SoftTech 사에서 개발.
    *   시스템 정의, 요구사항 분석, 소프트웨어 설계에 사용되는 구조적 설계 도구.
    *   구조적 요구 분석을 위해 **블록 다이어그램** 채택.
    *   CASE 프로그램 중 하나.
*   **CASE 주요 기능으로 옳지 않은 것**: 언어 번역 (이것은 컴파일러 등 프로그래밍 언어가 하는 일).

---

### 3. 소프트웨어 개발 방법론 (고전적 & 최신)

*   **소프트웨어 생명주기(Software Life Cycle)**: 소프트웨어가 만들어져서 폐기될 때까지의 과정.
    *   단계: 타당성 검토 -> 개발 계획 -> 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 운용 -> 유지보수.
*   **폭포수 모형(Waterfall Model)**:
    *   가장 전통적이고 고전적인 모형. 선형 순차 모델이라고도 함.
    *   단계별로 순차적으로 진행 (거꾸로 돌아가지 못함).
    *   **소규모 소프트웨어 개발에 적합**.
    *   **단점**: 중간에 요구사항 변경이나 이벤트 발생 시 적용하기 어려움.
*   **나선형 모형(Spiral Model)**:
    *   Boehm이 제시.
    *   **반복적 작업**을 수행.
    *   **가장 큰 특징: 위험 분석(Risk Analysis) 과정 포함**. (위험 관리가 중심인 모형).
    *   단계: 계획 수립 -> 위험 분석 -> 개발 -> 고객 평가.
    *   프로토타입을 만들어 고객에게 보여주고 검증.
*   **프로토타입 모형(Prototype Model)**:
    *   실제 개발될 시스템의 견본품(시제품)을 만드는 것.
    *   **장점**:
        *   고객과의 커뮤니케이션 원활.
        *   고객이 원하는 것을 더 확실하게 파악 가능.
        *   **요구사항 도출 및 분석에 유용**.
        *   실제로 보여주므로 요구사항 가변성 감소.
        *   빠른 제작, 반복 제작 가능.
        *   **개발 시간 감소**, **오류 사전 발견 용이**.
    *   **단점**:
        *   시제품이므로 품질이 떨어질 수 있음.
        *   오해 발생 가능성 (실제 품질과 다름).
        *   제작 비용 발생.
        *   일부 기능만 만들 경우 사용성이 과대평가될 수 있음.
    *   작은 프로젝트에서는 프로토타입을 계속 개선하여 최종 제품을 만들기도 함.
*   **설계 방식**:
    *   **하향식 설계(Top-Down Design)**: 가장 중요한 기능(주 사용자 함수)부터 만들고 나머지 세부 기능을 만들어 나가는 방식. (뿌리를 만들고 겨가지 만듦).
    *   **상향식 설계(Bottom-Up Design)**: 아주 단순하고 기초적인 기능부터 만들고 이를 모아 통합하여 전체 시스템을 만들어 나가는 방식.
*   **HIPO (Hierarchy plus Input-Process-Output)**:
    *   폭포수 모형과 유사.
    *   **하향식 소프트웨어 개발을 위한 문서 도구**.
    *   입력, 처리, 출력으로 구성되는 시스템 분석/설계 및 문서화 과정.
    *   **구성**: 가시적 도표, 총체 다이어그램, 세부 다이어그램.
    *   **장점**: 절차대로 나열되어 있어 보기 쉽고 이해하기 쉬움, 유지 보수 용이.
*   **V 모델(V-Model)**:
    *   폭포수 모형에서 시스템 검증 및 테스트 작업을 강조한 모형.
    *   개발 단계(좌측)와 테스트 단계(우측)가 V자 형태로 연결.
    *   각 개발 단계에 대응하는 테스트 단계가 존재.
    *   **테스트 종류 강조**: 정적 테스트(코드 분석) 및 동적 테스트(실제 실행).
*   **최신 소프트웨어 개발 방법론**:
    *   **애자일 방법론(Agile Methodologies)**:
        *   **핵심**: 빠르고 정확하게 고객이 원하는 것(목표)을 적용하여 소프트웨어를 만드는 것.
        *   절차, 도구보다 **개인과 소통**을 중요시 여김.
        *   계획에 중점 두지 않음.
        *   **애자일 선언문**: 고객과 제대로 의사소통하여 고객이 원하는 것을 만들어주자.
        *   **종류 (시험 출제 빈도 높음)**: **XP (eXtreme Programming)**, **스크럼(Scrum)**, Lean, DSDM, FDD (Feature Driven Development), Crystal, ASD.
    *   **XP (eXtreme Programming)**:
        *   애자일 방법론 중 가장 대표적이며, 아주 빠르게 양질의 소프트웨어를 만드는 방법론.
        *   **핵심 가치**: 소통(Communication), 단순성(Simplicity), 피드백(Feedback), 용기(Courage), 존중(Respect). (정형 분석은 XP의 가치가 아님).
        *   **절차**: User Story -> Release Planning -> Iteration (반복) -> Small Releases.
        *   **핵심**: **반복(Iteration)**, **사용자의 테스트 참여**.
        *   **용어**:
            *   Spike: 요구사항 확인을 위한 작은 프로그램.
            *   User Story: 사용자가 소프트웨어를 어떻게 사용할지에 대한 설명.
            *   Release Planning: 여러 스토리가 적용된 제품을 제공하기 위한 계획.
            *   Iteration: 하나의 릴리즈를 세분한 단위 (1~3주). 새로운 스토리가 추가될 수 있음.
            *   Acceptance Test: 사용자가 원하는 대로 만들어지는지 확인.
            *   Small Release: 작은 단위별로 프로그램을 실행 가능한 단위로 만듦.
        *   **12가지 실천 방법 (시험 출제)**: Pair Programming (짝 프로그래밍), Planning Game (계획 게임), Test Driven Development (테스트 기반 개발 - 코드 작성 전 단위 테스트 작성), Whole Team (전체 팀 - 사용자가 팀에 속함), Continuous Integration (지속적인 통합 - 항상 배포 가능한 상태 유지), Design Improvement (기능 변경 없이 재구성), Small Releases (작은 주기로 릴리즈), Coding Standards (표준 코딩 기법 준수), Collective Code Ownership (모든 코드를 모든 팀원이 같이 볼 수 있음), Simple Design (간결한 설계), System Metaphor (시스템 구조 기술), Sustainable Pace (과도한 업무 방지).
    *   **스크럼(Scrum)**:
        *   애자일 방법론 중 하나. 요구사항을 빠르게 적용하여 빠르게 소프트웨어를 개발하는 방식.
        *   **스크럼 팀 역할**:
            *   Product Owner (제품 책임자): 개발 목표 이해도가 높은 개발 의뢰자(사용자). 제품 요구사항 파악, 기능 목록 작성, 테스트 수행, 요구사항 우선순위 갱신 등의 역할. 스프린트 계획 수립 시까지만 임무 수행.
            *   Scrum Master (스크럼 마스터): 개발팀의 마스터. 업무 배분(강요x), 개발 과정의 장애 요소 제거 역할 (훌륭한 감독).
            *   Scrum Team (스크럼 팀): 개발자(디자이너, 검사자, 코더 등). 5~9명 내외로 구성. 기능 분류, 사용자 스토리 도출, 일정 추정, 시연, 데일리 스크럼 참석.
        *   **스크럼 과정**: **스프린트(Sprint)**라고 하는 과정이 반복됨 (2~4주).
        *   **데일리 스크럼 미팅(Daily Scrum Meeting)**: 매일 약속된 시간에 짧은 시간(약 15분) 서서 진행. 어제 한 일, 오늘 할 일 공유.
        *   **소멸 차트(Burndown Chart)**: 작업해야 할 목록을 만들어 놓고 매일 완료된 일을 소거하는 형태.
        *   **Product Backlog (제품 백로그)**: 제품 개발에 필요한 모든 요구사항을 우선순위에 따라 나열한 목록.
        *   **Sprint (스프린트)**: 전력 질주. 고정된 기간의 반복 (11일 반복 아님).
*   **소프트웨어 프로젝트 관리를 위한 3P**: **People (사람)**, **Process (프로세스)**, **Problem (문제)**.

---

### 4. 현행 시스템 분석

*   **현행 시스템 분석 목적**:
    *   개발할 시스템의 개발 범위를 확인.
    *   이해 및 방향성 설정 (필요한 것, 하는 일, 시스템 현황 파악).
*   **현행 시스템 파악 절차 (시험 출제)**:
    *   **1단계: 시스템 구성 파악**: 회사 조직의 업무 흐름 파악. 각 부서의 구성, 기능, 데이터 흐름 파악.
    *   **2단계: 시스템 아키텍처 파악**: 회사의 전체 구조(조직도), 현재 운영 중인 소프트웨어 구성 파악. (핵심 기관 업무 처리 시스템 기준).
    *   **3단계: 소프트웨어, 하드웨어, 네트워크 현황 파악**: 사용 중인 OS, 하드웨어 사양, 네트워크 구성 파악.
*   **시스템 아키텍처(System Architecture)**:
    *   시스템 전체의 구조나 행위, 행위 원리 표현. 작동 방식 설명.
    *   소프트웨어 아키텍처와 소프트웨어 상세 설계는 상호 관계가 있음.
*   **현행 시스템 인터페이스 현황 파악**:
    *   각 시스템이 서로 데이터를 주고받는 현황 파악. (예: 영업부서와 재고부서 연결).
    *   **인터페이스(Interface)**: 서로 마주보고 대화하며 자료를 교환하는 것.
    *   **EAI (Enterprise Application Integration)**: 기업 내 다양한 애플리케이션을 통합하고 조정하는 도구.
    *   **FEP (Front-End Processor)**: 전위 처리기. 입력 데이터를 프로세서 처리 전에 미리 처리하여 처리 시간을 줄이는 프로그램. (데이터 파일의 연구 보존은 FEP 기능 아님).
*   **개발 기술 환경 분석**:
    *   **소프트웨어 구성**: 업무 처리용 소프트웨어 이름, 용도, **라이선스(License)** 파악 (예산 비중 높음).
    *   **하드웨어 구성**: 컴퓨터 사양, 서버 이중화 여부 등 파악.
    *   **네트워크 구성**: 네트워크 종류, 구성 파악.
    *   **DBMS 분석**: 사용 중인 DBMS 종류 파악 (DBMS마다 접근 명령어 차이 발생 가능).
        *   **DBMS (Database Management System)**: 데이터베이스 관리 시스템. 종속성/중복성 문제 해결, 응용 프로그램과 데이터 간 중재자 역할.
        *   **고려사항**: 가용성, 성능, 기술 지원, 상호 호환성, 구축 비용.
    *   **미들웨어(Middleware)**: 분산 컴퓨팅 환경에서 응용 프로그램 간 통신 지원.
    *   **플랫폼(Platform)**: 소프트웨어를 개발하기 위한 기본 환경 (기반 시설). (예: Java 기반, .NET 기반, OS 기반 등).
    *   **플랫폼 성능 특성 분석**: 플랫폼의 종류, 사용자 요구사항 분석 통해 성능 문제 파악/개선 방향 제시.
        *   **측정 항목**: **응답 시간(Response Time)**, **가용성(Availability)**, **사용률(Usage Rate)**.
        *   **분석 방법**: 기능 테스트, 사용자 인터페이스/문서 점검, 인터뷰, 기존 플랫폼 분석.
    *   **운영체제(OS) 분석**: 사용 중인 OS 종류, 버전, 패치 일정, 백업 주기 등 파악.
        *   **TCO (Total Cost of Ownership)**: 자산 획득에 필요한 직/간접적인 총 비용 (소유 총 비용).
        *   **메모리 누수(Memory Leak)**: 소프트웨어 비정상 종료 후 메모리 반환되지 않고 남아있는 현상.
        *   **오픈 소스 라이선스**:
            *   Open Source: 소스 코드가 공개된 소프트웨어.
            *   **GNU (GNU's Not Unix)**: 리눅스 운영체제와 관련된 개념. (유닉스는 비쌈).
            *   **Linux**: 리누스 토발즈가 개발한 오픈 소스 OS.
            *   **GPL (GNU General Public License)**: 소스 코드 공개를 의무화하는 라이선스 (실행 파일만 배포 금지).
            *   **BSD (Berkeley Software Distribution) License**: 수정 배포 제한 없음, 수정본 재배포 의무 아님, 소스 공개 없이 상용 소프트웨어 사용 가능.
            *   **Apache License 2.0**: 아파치 재단에서 만든 라이선스. Hadoop과 관련됨.
            *   **Hadoop**: 다수의 저렴한 컴퓨터를 묶어 빅데이터 분석하는 처리 기술. 코끼리 모양 아이콘.

---

### 5. 요구사항 개발

*   **요구사항 개발(Requirements Engineering)**: 사용자의 요구를 정확히 반영한 시스템 개발을 위해 요구사항을 추출, 분석, 명세, 검증, 관리하는 구조화된 활동 집합.
*   **요구 공학(Requirements Engineering)**: 고객이 원하는 것을 정확하고 확실하게 뽑아내는 방법을 연구하는 학문.
    *   **사용 도구**: 자료 흐름도(DFD), 자료 사전(DD) 등.
*   **요구 공학 목적**:
    *   이해관계자(고객, 개발자 등) 간의 원활한 의사소통 제공.
    *   요구사항 누락, 상호 이해 오류 제거 -> 경제성 제공 (요구사항 변경 비용 최소화).
    *   개발 비용 및 시간 절감.
    *   문서화 수행 (개발의 약 60%는 문서화). (CASE 도구 사용).
    *   요구사항 변경 이력 관리.
    *   비용/일정 제약 설정, 타당성 조사, 요구사항 정의 문서화.
*   **요구사항 베이스라인(Requirements Baseline)**: 만들어야 할 소프트웨어 요구사항의 기준선. 이해관계자 간 협의로 결정.
*   **요구 공학 프로세스**:
    *   **타당성 조사 선행**: 경제성, 기술성, 적법성, 대안성. (만드는 데 비용/시간이 너무 많이 들거나, 기술적으로 불가능하거나, 법적으로 문제되거나, 더 나은 대안이 없는지 등).
    *   **SWEBoK (Software Engineering Body of Knowledge) 기준 프로세스**:
        1.  **요구사항 도출(Elicitation)**: 해결할 문제 이해, 현재 상태 파악, 문제 정의, 목표 명확화. 이해관계자(모든 관련자) 포함.
        2.  **요구사항 분석(Analysis)**: 도출된 요구사항 중 실제 무엇인지, 타당한지 등을 걸러내고 이해하는 단계. (기술: 의견 청취, 인터뷰, 문서 분석, 관찰, 모델 작성, 설문 조사). 문제 인식, 상세 검토, 적용 가능성 검토.
        3.  **요구사항 명세(Specification)**: 분석된 요구사항을 문서로 작성.
        4.  **요구사항 확인/검증(Validation/Verification)**: 문서화된 내용이 올바른지 확인/검증. (요구사항 관리 도구 사용, 이해관계자 검토, 형상 관리). 표준 적합성, 이해 가능성, 일관성, 완전성 확인.
*   **요구사항 도출 기법**: 고객 발표, 문서 조사, 설문, 업무 절차/양식 조사, 자유로운 대화, 브레인스토밍, 워크숍, 인터뷰, 관찰, 모델, 프로토타입, 유즈 케이스, 벤치마킹, BPR, RFI.
*   **요구사항 분류**:
    *   **기능 요구사항(Functional Requirements)**: 시스템이 무엇을 해야 하는지, 실제 작동 방식 관련 (예: 회원가입, 로그인, 결제).
    *   **비기능 요구사항(Non-functional Requirements)**: 시스템의 품질 특성 관련 (예: 성능, 보안, 품질, 안정성, 가용성, 사용성).
*   **요구사항 명세 기법**:
    *   **정형 명세 기법(Formal Specification)**: 수학적 기반 모델링. 정확하고 명확하지만 이해하기 어려움 (낮은 이해도, 이해관계자 부담 가중). (예: VDM, Petri-Net, Z, CSP).
    *   **비정형 명세 기법(Informal Specification)**: 자연어 기반. 이해하기 쉽고 의사 전달 방법 다양하지만 불충분하거나 모호할 수 있음. (예: SADT, Use Case).
*   **요구사항 명세 속성 (시험 출제)**: **정확(Correct)**, **명확(Unambiguous)**, **완전(Complete)**, **일관성(Consistent)**, **수정 용이성(Modifiable)**, **추적성(Traceable)**.
*   **정형 분석(Formal Analysis)**: 구문/형식이 정의된 언어로 요구사항 표현. 정확하고 명확하며 오해 최소화. 요구사항 분석 마지막 단계에서 사용.
*   **요구사항 확인/검증 도구**: 프로토타이핑, 모델 검증, 요구사항 검토, 인수 테스트.
    *   **모델 검증**: 분석 단계에서 개발된 모델 품질 검증 (정적 분석: 코드 분석, 동적 분석: 실제 실행).
    *   **인수 테스트(Acceptance Testing)**: 최종 단계에서 고객에게 전달하여 사용해보고 요구사항에 맞는지 확인. (종류: 계약 인수, 규정, 알파, 베타, 사용자, 운영 인수 테스트).
*   **형상 관리(Configuration Management)**: 소프트웨어 개발 과정 중 나오는 프로그램, 문서, 데이터 등 **모든 자료의 변경을 통합 관리** (버전 관리 등).

---

### 6. UML

*   **UML (Unified Modeling Language)**:
    *   현실 세계 내용을 이해하기 쉬운 형태로 모델링하는 언어.
    *   객체 지향 소프트웨어 개발 방법론에서 시스템 분석/명세화를 위한 **범용 모델링 언어**.
    *   Booch, Rumbaugh, Jacobson이 통합 개발.
    *   **UML 문제 무조건 1문제 출제**.
*   **Rumbaugh의 객체 지향 분석(OOA) 기법 (시험 출제 빈도 높음)**:
    *   **모델링 종류**:
        1.  **객체 모델링(Object Modeling)**: 현실 세계 대상체(객체, 클래스) 추출 및 관계 연구. 시스템의 **정적 구조** 표현.
            *   **도출 다이어그램**: **객체 다이어그램**.
        2.  **동적 모델링(Dynamic Modeling)**: 객체들의 상호 작용(움직임, 상태 변화) 표현.
            *   **도출 다이어그램**: **상태 다이어그램(State Diagram)**.
        3.  **기능 모델링(Functional Modeling)**: 객체 간의 자료 흐름 표현.
            *   **도출 다이어그램**: **자료 흐름도(Data Flow Diagram, DFD)**.
*   **UML의 특징**: 시각화, 문서화, 명세화, 구축 지원.
*   **UML 소프트웨어 관점**:
    *   **기능적 관점**: 사용자의 행위 측면 (사용 사례 모델링). (Use Case Diagram 사용).
    *   **정적 관점**: 객체 사이의 구조 관계 (구조). (Class Diagram 사용).
    *   **동적 관점**: 객체의 움직임/상태 변화. (Sequence, State, Activity Diagram 사용).
*   **UML 기본 구성**: **사물(Things)**, **관계(Relationships)**, **다이어그램(Diagrams)**.
    *   정적 모델: 구조 다이어그램.
    *   동적 모델: 행위 다이어그램.
*   **UML 확장 모델 표현**: 기본 요소 외 추가 확장 요소 표현 시 **<<stereotype>>** 사용.
*   **UML 접근 제어(Access Control)**:
    *   `+` : **Public** (모든 클래스 접근 가능).
    *   `-` : **Private** (해당 클래스만 접근 가능).
    *   `#` : **Protected** (해당 클래스, 동일 패키지, 상속 관계 클래스 접근 가능).
    *   `~` : **Package** (동일 패키지 클래스 접근 가능).
*   **UML 다중성 표현(Multiplicity)**: 객체 연결 개수 표현.
    *   `*`: 0 또는 그 이상.
    *   `0..*`: 0 또는 그 이상.
    *   `1..*`: 1 또는 그 이상.
    *   `0..1`: 0 또는 1.
    *   `m..n`: m 이상 n 이하.
    *   `n`: n개.
    *   `n..*`: n 이상.
*   **UML 관계 종류**:
    *   **연관 관계(Association)**: 한 사물 객체가 다른 사물과 어떻게 연결되는지 표현. (단방향, 양방향).
    *   **의존 관계(Dependency)**: 연관 관계와 같지만 매우 짧은 시간만 유지 (메소드 사용 시 등).
    *   **일반화 관계(Generalization)**: **상속(Inheritance)** 관계 표현. (예: 자동차 <-- 버스, 트럭, 택시). 빈 화살표 머리 사용.
    *   **집합 관계(Aggregation)**: 전체-부분 관계. 부분 객체가 다른 객체와 공유 가능. 빈 마름모꼴. (예: 학교 -- 학생/교사).
    *   **포함 관계(Composition)**: 강한 집합 연관 관계. 부분 객체가 전체 객체에 강하게 속함 (전체 객체 소멸 시 부분 객체도 소멸). 채워진 마름모꼴. (예: 책상 -- 다리/상판).
    *   **실체화 관계(Realization)**: 인터페이스와 구현 클래스 간 관계 (행동 구현 표현). 점선과 빈 화살표. (예: 날 수 있는 것 -- 파리, 미사일, 나방).
*   **UML 다이어그램 분류**:
    *   **구조 다이어그램(Structure Diagrams) - 정적 모델 표현**: 클래스, 객체, 복합체 구조, 배치(Deployment), 컴포넌트, 패키지 다이어그램. (Activity 다이어그램은 행위 다이어그램임).
    *   **행위 다이어그램(Behavior Diagrams) - 동적 모델 표현**: 유스케이스, 활동, 상태 머신, 상호작용(순차, 통신, 상호작용 개요, 타이밍) 다이어그램. (배치 다이어그램은 구조 다이어그램임).
*   **클래스 다이어그램(Class Diagram)**: 시스템 구성하는 객체 관계를 추상화/요약 표현. 속성, 연산(오퍼레이션) 포함. 사각형 모양.
*   **유스케이스 다이어그램(Use Case Diagram)**: 사용자(액터) 관점에서 시스템의 행위(사용 사례) 표현.
    *   **요소**: 시스템 경계(범위), 액터(사용자), 유스케이스(행위), 접속 관계, 사용 관계(Include), 확장 관계(Extend).
    *   **작성 단계**: 액터 식별 -> 행위(유스케이스) 식별 -> 관계 정의 -> 구조화.
*   **순차 다이어그램(Sequence Diagram)**: 상호작용 다이어그램 중 하나. 객체 간 메시지 교환 순서 표현.
    *   **구성 요소**: 생명선(Lifeline), 메시지(Message), 활성 객체, 실행 상태 등.

---

### 7. 소프트웨어 아키텍처 품질 속성

*   **소프트웨어 아키텍처**: 소프트웨어의 구조, 설계도. 기능/성능 만족도를 충분히 제공해야 함.
*   **소프트웨어 품질 특성 국제 표준**: **ISO/IEC 9126**. (확장되어 현재는 ISO/IEC 25010 사용).
    *   **품질 목적 정의 및 평가 기준 마련**.
    *   **분류 (시험 출제)**:
        *   **내/외부 품질 (Internal/External Quality)**: 개발/평가자 기준. 기능성, 신뢰성, 사용성, 효율성, 유지 보수성, 이식성. (기능성 하위 특성에 학습성은 포함되지 않음 - 사용성 하위 특성).
        *   **사용 품질 (Quality in Use)**: 사용자 기준. 효과성, 생산성, 안정성, 만족도. (원문에서는 효과성, 생산성, 안정성, 만족도로 설명).
    *   **ISO 9126 하위 특성**:
        *   기능성: 적합성, 정확성, 상호 운용성, 보안성, 법규 준수성.
        *   신뢰성: 성숙성, 결함 허용성, 회복성.
        *   사용성: 이해성, 학습성, 운용성, 친밀성, 준수성.
        *   효율성: 시간 효율성, 자원 효율성, 준수성.
        *   유지 보수성: 분석성, 변경성, 안정성, 시험성, 준수성.
        *   이식성: 적응성, 설치성, 공존성, 대체성, 준수성.

---

### 8. UI/UX

*   **UI (User Interface)**: 사용자가 기계를 작동시키는 방법. 실 사용자가 체감하는 부분.
    *   **중요성**: 사용자의 만족도에 직접적인 영향. 적절한 구성으로 편리성, 가독성, 동선 축약하여 업무 효율성 높임.
    *   **UI 설계 전 소프트웨어 아키텍처 숙지 필요**.
    *   **UI 개발 시스템 기능**: 사용자 입력 검증, 에러 처리/메시지, 도움말/프롬프트(입력창) 제공.
*   **UI 설계 원칙 (시험 출제 빈도 높음)**:
    *   **직관성**: 누구나 쉽게 이해하고 사용 가능.
    *   **유효성(Usability/Efficiency)**: 버튼 크기 등 오류 나지 않도록.
    *   **학습성(Learnability)**: 쉽게 배우고 기억하여 사용 가능 (예: 로그인 창 위치).
    *   **유연성(Flexibility)**: 사용자 요구 수용, 오류 최소화.
*   **UI 설계 지침**: 사용자 중심, 일관성, 단순성, 가시성(잘 보여야 함), 표준화, 접근성(쉽게 접근), 결과 예측 가능, 명확성, 오류 발생 시 해결 가능하도록 표시.
*   **UI 표준**: 개발자 간 협업 시 화면 간 최소한의 UI 요소, 배치 규칙 등. (소프트웨어 아키텍처 필요한 이유 중 하나).
*   **한국형 웹 콘텐츠 접근성 지침 2.1 (4가지 원칙)**: 인식의 용이성, 운용의 용이성, 이해의 용이성, 견고성.
*   **UX (User Experience)**: 사용자가 제품 사용 시 직/간접적으로 느끼고 생각하고 반응하는 **전체적인 경험**. (감성공학과 관련). 행정안전부 고시.
*   **감성공학(Emotional Engineering)**: 인간의 감각/감성 등 주관적인 것을 공학적으로 접근 (수치화). (예: 아이폰 사용 경험).
    *   **접근 방법 분류**: 1류, 2류, 3류.
*   **HCI (Human-Computer Interaction)**: 인간과 컴퓨터 간 상호작용. 목적은 인간이 컴퓨터를 쉽게 쓸 수 있도록 하는 것.
*   **UI 설계 단계**:
    1.  문제 정의.
    2.  사용자 모델 정의.
    3.  작업 분석 (유스케이스 활용).
    4.  컴퓨터 오브젝트 및 기능 정의.
    5.  사용자 인터페이스 정의.
    6.  디자인 평가.
        *   **평가 방법론**: GOMS (소요 시간, 학습 시간 평가), 휴리스틱 (어림짐작으로 문제 해결).
*   **UI 상세 설계 단계 (순서 기억)**:
    1.  **UI 메뉴 구조 설계 (제일 중요)**.
    2.  내/외부 화면 및 폼 설계.
    3.  검토.
*   **UI 시나리오 작성 원칙**: UI 기능/작동 방식 구체적 작성 (개발자 이해 용이), 대표 화면/하위 기능 정의, 트리 구조/플로 차트 활용, 공통 UI 요소/상호작용 규칙 정의, 상호작용 흐름/순서/분기/루프 명시, 관련 사례 정의, UI 규칙 준수.
    *   **시나리오 문서 작성 요건**: 완전성, 일관성, 이해성, 가독성, 수정 용이성, 추적 용이성.
*   **UI 설계 도구 (시험 출제)**:
    *   **와이어프레임(Wireframe)**: 기획 초기에 작성. 화면의 개략적인 레이아웃 구성 (손 그림, 파워포인트, 스케치 등).
    *   **목업(Mockup)**: 와이어프레임보다 실제 제품과 유사. 실제 크기의 정적인 모델로 시각적 구현. (예: 스마트폰 매장 전시폰).
    *   **프로토타입(Prototype)**: 도출된 요구사항을 시제품으로 만듦. **실제 작동 가능**하며 상호작용 적용. (와이어프레임, 스토리보드에 인터랙션 적용). (장/단점은 앞의 프로토타입 모형과 동일).
    *   **스토리보드(Storyboard)**: 프로세스 흐름 표현. 사용자의 작업, 인터페이스 상호작용, 개발/디자인 간 의사소통 도구. 절차별 그림/화면을 만들어 나감.

## 1. 소프트웨어 설계 모델링

*   **소프트웨어 설계**: 소프트웨어를 만들기 위해 구성 요소(애플리케이션 등)를 어떻게 배치할 것인지 보는 것.
    *   모델링 필요.
    *   청사진을 만드는 단계.
*   **설계 구분**:
    *   **상위 설계 (예비 설계)**: 전체 뼈대를 세우는 단계. 약간 큰 개념에서의 설계.
        *   포함 내용: 아키텍처 설계, 데이터 설계, 인터페이스 정의, 사용자 인터페이스 설계 등.
    *   **하위 설계**: 실제로 구현되는 모듈의 배치 등 구체적이고 디테일하게 보는 단계.
        *   포함 내용: 모듈 설계, 모듈 내 자료구조, 알고리즘 설계 등.
*   **소프트웨어 설계 대상 (모델링)**:
    *   **구조 모델링**: 컴포넌트의 유형, 인터페이스, 내부 설계 구조 등 상호 연결에 대한 것. 모듈들의 연결 구조를 보는 것. (예: 사람이 살기 위한 집의 틀).
    *   **행위 모델링**: 실제로 소프트웨어가 어떻게 움직이는지 보는 것. (예: 집 안에서 사람들이 어떤 행위를 하는지 고려).
*   **컴포넌트 vs 모듈**:
    *   둘 다 하나의 작은 기능을 하는 단위로 비슷함.
    *   **모듈**: 하나의 기능을 하는 단위. 소스 코드의 집합. 실행 코드 의미. 자체 컴파일 가능. 재사용이 가장 큰 특징.
    *   **컴포넌트**: 하나의 기능을 하지만 **인터페이스**를 가지고 있어서 다른 모듈들과 연결할 수 있음. 모듈의 집합을 컴포넌트라고 생각하기도 함 (정확한 정의는 아님). 결제 시스템 컴포넌트 안에 다양한 기능의 모듈들이 있다고 생각하면 이해하기 쉬움.
    *   컴포넌트의 집합을 애플리케이션이라고 이야기할 수 있음.

## 2. 소프트웨어 설계 방법

*   **구조적 설계**: 기능별 처리 과정, 알고리즘 등을 중심으로 시스템을 나눠 설계하는 방식. 전통적인 방식.
*   **자료 중심 설계**: 입력/출력 자료를 중심으로 설계. (출제된 적 없음).
*   **객체지향 설계**: 자료와 자료에 적용 가능한 기능을 묶어 추상화하는 개념. 현실 세계 대상을 객체로 보고 모델링.

## 3. 추상화 (Abstraction)

*   **정의**: 요약, 함축하는 것. 필요없는 것을 걷어내고 우리가 필요한 것들만 끄집어내는 것.
*   **목적**: 복잡성 감소.
*   **종류**: 과정 추상화, 데이터 추상화, 제어 추상화.

## 4. 소프트웨어 구조도

*   **소프트웨어 구조도**: 모듈 간의 연결 방식을 보는 것. 시험 출제됨.
*   **Fan-in (팬인)**: 해당 모듈을 제어하는 **상위 모듈의 수**.
    *   높을수록 좋음 (재사용 측면에서 잘 설계).
    *   시스템 구성 요소 중 일부가 동작하지 않으면 시스템 중단될 수 있는 단일 장애 발생 가능성 있음. 중점 관리 필요.
*   **Fan-out (팬아웃)**: 해당 모듈이 제어하는 **하위 모듈의 수**.
    *   낮을수록 좋음 (단순하고 손쉽게).
    *   불필요한 타 모듈 호출 여부 확인.
*   **복잡도 최적화 조건**: Fan-in은 높이고, Fan-out은 낮춘다 (하위 모듈 수 줄이는 것).
*   **Depth (뎁스)**: 상위 모듈에서 마지막 하위 모듈까지의 층 수.
*   **Width (위스)**: 폭.

## 5. 코드 설계 (자료 배열/분류 기술)

*   **목적**: 자료를 분류하기 위한 기술. 시험 개정 전 산업기사 범위.
*   **기본 기능**: 표준화, 사용 용이.
*   **3대 기능**: **분류 기능**, **식별 기능**, **배열 기능**.
*   **부가 기능**: 연상 기능, 암호화, 오류 검출.
*   **코드 설계 목적 중요**: 고유성, 분류, 편리성.
*   **코드 종류**:
    *   **순차 코드 (일련번호 코드)**: 1234 또는 ABC 순서대로 나열.
        *   장점: 한복수가 좋고 변경이 적은 자료에 적합.
        *   단점: 중간 삽입/삭제 어려움.
        *   활용: 오래된 자료, 보관 자료.
    *   **블록 코드**: 공통 특성에 따라 임의의 큰 기준별로 블록을 만들고 그 안에 숫자를 배치.
    *   **그룹 분류식 코드**: 항목을 대분류, 중분류, 소분류 등으로 그룹 만들어 분류.
    *   **십진 분류 코드 (도서 분류 코드)**: 계층적으로 분류 (예: 국문학 100번대, 철학 300번대 등). 하위 분류 가능.
    *   **표의 숫자 코드**: 숫자가 어떤 **의미**를 가짐 (예: 크기, 면적, 용량 등 물리적 수치 이용).
    *   **연상 코드 (기호 코드)**: 코드를 보고 연상 가능 (예: 냉장고 REF, 모니터 MT).
*   **코드 오류 종류**:
    *   **필사 오류**: 잘못 입력 (예: 1234 → 1237).
    *   **전의 오류 (Transposition Error)**: 인접한 두 자릿수 바뀜.
    *   **이중 오류**: 두 자릿수 모두 바뀜.
    *   **생략**: 일부 자리 빠뜨림 (예: 1234 → 123).
    *   **추가**: 불필요한 자리 추가 (예: 1234 → 12345).
    *   **임의 오류**: 위에 속하지 않는 모든 오류.

## 6. 구조적 개발 방법론

*   **구조적 분석**: 자료의 흐름 등을 통해 전체 시스템 일관성 파악. 정형화된 분석 절차에 따라 사용자 요구사항 파악 및 문서화. 전통적인 방법.
*   **구조적 분석 도구 중요**:
    *   **자료 흐름도 (Data Flow Diagram - DFD) / 버블 차트**: 자료가 어떻게 흘러가는지 그림 중심으로 표현.
        *   작성 원칙: 출력 자료 흐름은 입력 자료 흐름 이용.
        *   **구성 요소 (도형으로 표현, 시험 출제)**:
            *   **프로세스 (Process)**: 자료의 **처리**. (원으로 표시).
            *   **자료 흐름 (Data Flow)**: 자료 이동. (화살표로 표시).
            *   **자료 저장소 (Data Store)**: 자료 **보관** 장소. (두 줄 평행선으로 표시).
            *   **단말 (Terminator)**: 자료 **입/출력** 주체 (외부 엔티티). (사각형으로 표시).
    *   **소단위 명세서 (Mini-Specification / Process Specification)**: 세분화된 자료 흐름도 최하위 단계 프로세스 처리 절차 설명. 분석가의 문서. 자료 흐름도 지원.
        *   표현 방법: 술 문장, 구조적 언어, 의사 결정 나무, 의사결정 표, 그래프 등.
        *   **구조적 언어**: 자연어 일부 한정 단어/구문, 제한된 구조 이용 명세 언어.
        *   **의사결정 나무**: 현재/목표 상황 관련성 나무가지 이용 분석.
        *   **의사결정 표**: 복잡한 의사결정 표로 표현.
    *   **자료 사전 (Data Dictionary) 중요**: 자료 흐름도에 기술된 모든 자료 정의 기술. 구조적 시스템 방법론에서 중요한 도구.
        *   **표기법 (코드 기억, 자주 출제)**:
            *   `=` : 정의 (A=10).
            *   `+` : 연결 (A+B).
            *   `()` : 생략 (A()).
            *   `[]` : 선택 (A [|] B). 둘 중 하나 선택.
            *   `{}` : 반복 ({A}). 지정 횟수 반복 ({A} 1 to 4).
            *   `* *` : 주석 (* 설명 *).
        *   자료 사전 기술 대상: 자료 흐름 항목, 저장소 항목, 의미, 원소 단위 값 등.

## 7. 모듈 (Module)

*   **정의**: 전체 프로그램에서 어떤 기능을 수행할 수 있는 실행 코드. 코드의 집합. 하나의 기능을 하는 작은 프로그램.
*   **가장 큰 특징**: **재사용**.
*   **이점**: 시스템 개발 기간/노동력 절감. 독립성 강해야 함. 기억장치 유용하게 사용. 각 모듈의 기능은 서로 다른 모듈과 과도한 상호작용 회피 (기능적 독립적).
*   **독립성 측정 기준 중요**: **결합도**와 **응집도**.
*   **결합도 (Coupling) 중요**: 모듈 간의 **관계**. 모듈 자체(A와 B)가 얼마나 비슷한가.
    *   **목표**: **낮을수록 좋다**. 낮을수록 모듈 독립성 향상, 유지보수 쉬움.
    *   **결합도 강한 순서 (낮은/좋은 ← 높은/나쁜) 암기: 자스제외공내 (자료, 스탬프, 제어, 외부, 공통, 내용)**.
        *   **자료 결합도 (Data Coupling)**: 모듈 간 인터페이스가 **자료 요소**로만 구성. 서로 다른 모듈 영향 X, 가장 바람직.
        *   **스탬프 결합도 (Stamp Coupling)**: 모듈 간 **같은 자료구조** 공유. 자료구조 변화 시 영향 미침. (자료 결합도보다 강함). (예: 배열, 레코드).
        *   **제어 결합도 (Control Coupling)**: 어떤 모듈이 다른 모듈의 내부 논리 구조를 **제어**하기 위해 제어 신호 이용.
        *   **외부 결합도 (External Coupling)**: 어떤 모듈이 외부에 선언된 **변수**를 함께 사용.
        *   **공통 결합도 (Common Coupling)**: 여러 모듈이 **공통 자료 영역** (메모리, 저장소) 공유. 결합도 높음.
        *   **내용 결합도 (Content Coupling)**: 한 모듈이 다른 모듈의 **내부 기능/자료** 참조. 가장 강한 결합도 (가장 나쁨). 모듈 독립성 보장 안됨.
*   **응집도 (Cohesion) 중요**: 모듈 **내부** 요소(코드, 제어 문구 등) 간의 **관련성**. 독립적 기능으로 구성된 정도.
    *   **목표**: **높을수록 좋다**.
    *   **응집도 약한 순서 (높은/좋은 ← 낮은/나쁜) 암기: 기능순교절시간논우 (기능적, 순차적, 교환적, 절차적, 시간적, 논리적, 우연적)**.
        *   **기능적 응집도 (Functional Cohesion)**: 모듈 내 모든 기능 요소들이 **하나의 문제 해결**을 위해 존재. (예: 결제 해결). (가장 좋음).
        *   **순차적 응집도 (Sequential Cohesion)**: 모듈 내부 한 기능 요소의 **출력 자료가 다음 기능 요소의 입력 자료**로 제공.
        *   **교환적 응집도 (Communicational Cohesion)**: **같은 입력과 출력을 사용**하는 소자료가 모인 경우.
        *   **절차적 응집도 (Procedural Cohesion)**: 모듈이 다수 기능 가질 때 내부 기능 요소들이 **기능을 순차적으로 수행**.
        *   **시간적 응집도 (Temporal Cohesion)**: **특정 시간**에 처리되는 여러 기능 모아 한 개 모듈로 작성.
        *   **논리적 응집도 (Logical Cohesion)**: 유사한 성격 갖거나 특정 형태로 분류된 처리 요소들이 하나의 모듈 형성.
        *   **우연적 응집도 (Coincidental Cohesion)**: 모듈 내부 기능들이 **서로 관련 없는 애들**이 모여 있음. (가장 안 좋음).

## 8. 소프트웨어 아키텍처 (Software Architecture)

*   **정의**: 소프트웨어의 뼈대. 컴포넌트들의 상호 작용 관계, 특성 등을 유기적으로 결합하는 여러 원칙 집합. 큰 틀에서 컴포넌트를 어떻게 조립할 것인지 보는 것.
*   **역할**: 설계/구현 위한 구조적/비구조적 틀 제공.
*   **품질 속성 (Quality Attributes / -ility)**: 성능, 운용성, 보안성, 시험 용이성, 가용성, 변경 용이성, 사용성 등.
*   **특징**: 간결, 추상화, 가시성.
*   **복잡도 관리**: 추상화 (과정, 데이터, 제어 추상화) 통해 복잡성 감소.
*   **평가 기준**: 시스템 구성 모듈, 실행 시 행동/연결, 비소프트웨어 요소(CPU, 파일시스템, 네트워크 등) 관계 등 살펴봄.
*   **아키텍처 프레임워크 (Architecture Framework)**: 복잡한 소프트웨어 구조 해결/서술에 필요한 기본 구조 제공. 건물의 골조와 비슷.
    *   **구성 요소 중요**:
        *   **Architecture Description (설계 설명서)**.
        *   **Stakeholder (이해관계자)**.
        *   **Concern (관심사)**.
        *   **View (관점)**.
        *   **Viewpoint (관점)**.
*   **4+1 View Model (포플러스 원 뷰 모델) 중요**: 소프트웨어 아키텍처를 5개 뷰로 표현 (자주 출제). 부치 형님 제안.
    *   **Logical View (논리적 뷰)**: 기능 요구사항 (설계/분석).
    *   **Implementation View (구현 뷰)**: 소프트웨어 구현 (프로그래머 코딩).
    *   **Process View (프로세스 뷰)**: 병행성, 동기화 (시스템 통합).
    *   **Deployment View (배치 뷰)**: 물리적 환경 (시스템 엔지니어).
    *   **Use Case View (유스케이스 뷰)**: 최종 사용자 기능 (사용자 관점). (+1에 해당).
*   **설계 원리**: 단순성, 효율성, 분할, 계층화, 추상화, 모듈화.
*   **평가 방법론**: SAM, ATAM, CBAM, ARID.

## 9. 소프트웨어 아키텍처 패턴 (Software Architecture Pattern)

*   **정의**: 설계 시 발생하는 문제 해결 위한 일반화되고 재사용 가능한 솔루션 (미리 구성된 설계도). 자주 사용하는 기능들을 요렇게 하자고 정해 놓은 것.
*   **이점**: 개발 시간 단축, 소프트웨어 고품질, 안정적, 표준화, 관계자 간 의사소통 편이, 구조 이해도 높음, 유지보수 유리.
*   **동의어**: 아키텍처 스타일, 표준 아키텍처.
*   **디자인 패턴과 비교**: 아키텍처 패턴은 전체적인 구조(건물 골조), 디자인 패턴은 내부 상세(인테리어) 표준.
*   **종류 (자료에 언급된 것)**:
    *   **계층 패턴 (Layered Pattern)**: 소프트웨어를 계층 단위로 분할 (N-Tier: 여러 개의 층).
    *   **클라이언트-서버 패턴 (Client-Server Pattern)**: 하나의 서버와 다수의 클라이언트 형태.
    *   **MVC 패턴 (Model-View-Controller Pattern) 중요**: 모델, 뷰, 컨트롤러로 구성. (시험 출제 가능성 언급).
        *   **Model (모델)**: 핵심 기능 및 데이터.
        *   **View (뷰)**: 사용자에게 정보 표시 방법.
        *   **Controller (컨트롤러)**: 사용자 입력 처리.
        *   장점: 다수 뷰 생성 가능, 실행 시간 동적 연결/해제.
        *   단점: 불편한 업데이트 발생 가능, 복잡성 증가.
    *   **파이프-필터 패턴 (Pipe-Filter Pattern) 중요**: 자료 흐름과 처리 변환에 사용.
        *   **Pipe (파이프)**: **자료를 보내는** 관. 데이터 흐름. (버퍼링/동기화 목적 사용 가능).
        *   **Filter (필터)**: 파이프 통해 받은 데이터를 **변경**시키는 것. 각 처리 과정. (정수기 필터 생각).
        *   특징: 각 처리 과정은 필터 컴포넌트, 데이터는 파이프 통해 흐름.
        *   장점: 필터 교환/재조합 통해 높은 유연성.
        *   단점: 상태 정보 분유 비용, 데이터 변환 과부하 가능성.
        *   활용: 컴파일러 (어휘/구문/의미 분석, 코드 생성).
    *   **피어 투 피어 패턴 (Peer-to-Peer - P2P)**: 동등한 연결. 서버/클라이언트 역할 상황 따라 바뀜. 분산 컴퓨팅에 사용.
    *   **브로커 패턴 (Broker Pattern)**: 컴포넌트(컴퓨터, 사용자)를 연결해주는 중개 역할. 요청/응답 컴포넌트 여러 개 존재 시 적합.
    *   **블랙보드 패턴 (Blackboard Pattern)**: 결정적 해결 전략 없을 때 사용. (예: 음성 인식, 신호 해석).
    *   **이벤트 버스 패턴 (Event Bus Pattern)**: 소스 이벤트 메시지 발생 시 구독자가 메시지 수신 후 이벤트 처리. 소스, 이벤트 버스, 리스너 3가지 컴포넌트. 소스는 채널 발행, 리스너는 채널 구독.
    *   **인터프리터 패턴 (Interpreter Pattern)**: 특정 언어 프로그램 해석 컴포넌트 설계. (동시 통역사 생각).

## 10. 객체지향 설계 (Object-Oriented Design - OOD)

*   **객체지향 분석 (Object-Oriented Analysis - OOA)**: 현실 세계 대상체를 객체로 보고 분석/모델링. 현실 세계를 정확하게 대응 가능.
*   **객체지향 구성요소 중요**:
    *   **객체 (Object)**: 현실 세계 대상체. 데이터(속성)와 함수(메소드)를 묶어 캡슐화 대상. 속성(Attribute)과 메소드(Method), 메시지로 구성.
    *   **클래스 (Class)**: 유사한 객체들을 묶어 놓은 것. 하나의 틀 또는 타입. 구조적 기법의 단위 테스트 개념과 유사. 상위 클래스와 하위 클래스로 나뉨.
    *   **메시지 (Message)**: 객체 간의 통신 수단. 객체가 메시지를 받아서 실행해야 할 구체적 연산 (메소드).
*   **객체지향 특징 중요**:
    *   **캡슐화 (Encapsulation)**: 관련성 높은 요소(데이터, 메소드)를 하나의 캡슐로 묶는 것. **정보 은닉** 가능. 결합도 낮아져 재사용성 높아짐.
    *   **정보 은닉 (Information Hiding)**: 객체 내부 속성/메소드를 외부에 숨기는 것. 인터페이스 단순화 목적. 사이드 이펙트(예기치 못한 문제) 방지.
    *   **추상화 (Abstraction)**: 전체 시스템에서 필요한 것만 추출하여 표현. 현실 세계를 컴퓨터에 자연스럽게 표현. (종류: 기능, 제어, 자료 추상화).
    *   **상속성 (Inheritance)**: 상위 클래스에서 정의된 속성/메소드를 하위 클래스에 물려주는 것. 코드 재사용 증가.
    *   **다형성 (Polymorphism)**: 하나의 메시지에 대해 각 객체가 **다양한 형태로 응답**할 수 있는 능력. 상속 관계에서 객체 모양/크기 등 다양하게 변환. (예: 고양이과에 고양이와 사자).
*   **객체지향 관계성**:
    *   **참조 이용 관계 (Number of / uses)**.
    *   **집단화 (Aggregation / has a)**: 전체와 부분 관계 (Part of).
    *   **일반화 (Generalization / is a member of)**: 상속과 유사.
*   **오버로딩 (Overloading) vs 오버라이딩 (Overriding) 중요**:
    *   **오버로딩**: **한 클래스 내**에서 **같은 이름의 메소드**를 여러 번 정의. **매개변수의 개수나 타입이 달라야 함**. (예: 더하기(정수, 정수), 더하기(실수, 실수), 더하기(정수, 정수, 정수))
    *   **오버라이딩**: **상속 관계**에서 사용. 상위 클래스 메소드를 하위 클래스에서 **변경하여 재정의 (덮어쓰기)**. **메소드 이름, 매개변수 개수/타입이 같아야 함**. (예: 부모 클래스의 '걷다' 메소드를 자식 클래스에서 '뛰다'로 재정의)
*   **객체지향 설계 원칙 (SOLID) 중요**:
    *   **단일 책임 원칙 (Single Responsibility Principle)**: 모든 클래스는 **단일 목적**으로 생성.
    *   **개방 폐쇄 원칙 (Open/Closed Principle)**: 확장에는 개방, 수정에는 폐쇄.
    *   **리스코프 치환 원칙 (Liskov Substitution Principle)**: 부모 클래스가 들어갈 자리에 **자식 클래스 대체해도 계획대로 작동**. (상속 관계에서 사용).
    *   **인터페이스 분리 원칙 (Interface Segregation Principle)**: 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계 X.
    *   **의존 역전 원칙 (Dependency Inversion Principle)**: 의존 관계 시 변하기 어려운 것(추상)에 의존.
*   **객체지향 개발 방법론 종류**: Booch, OSE, OMT(객체, 동적, 기능 모델링), Coad-Yourdon 등.
*   **Coad-Yourdon 기법**: ER 다이어그램 사용.

## 11. 디자인 패턴 (Design Pattern)

*   **정의**: 객체지향 설계 및 구현 시 자주 발생하는 문제 해결 위한 **표준화된 해결책**. 재사용에 관한 유용한 설계 패턴화. (아파트 인테리어 표준과 유사).
*   **이점**: 개발자 간 의사소통 원활, SW 구조 파악 용이, 재사용 통한 개발 시간 단축, 설계 변경 요청 유연 대처, 객체지향 생산성 향상.
*   **단점**: 객체지향 설계/구현 위주 사용, 초기 투자 비용 발생.
*   **구성 요소 중요**:
    *   **필수 요소**: 패턴의 **이름**, **문제**, **배경**, **해법**, **결과**.
    *   **추가 요소**: 알려진 사례, 샘플 코드, 원리/근거.
*   **GOF 디자인 패턴 (Gang of Four) 중요**: 객체지향 설계 재사용 관련 유용한 설계 패턴 제안.
*   **GOF 디자인 패턴 분류 중요**:
    *   **생성 패턴 (Creation Pattern)**: 객체 **생성** 관련. (예: **팩토리 메소드(Factory Method - 객체 만들 때)**, **싱글톤(Singleton - 객체 하나만 사용)**, **프로토타입(Prototype - 시제품 복사)**, 빌더(Builder - 작게 모아 완성), 추상 팩토리(Abstract Factory)).
    *   **구조 패턴 (Structural Pattern)**: 클래스나 객체들을 **조합**하여 더 큰 구조를 만듦. (예: **아답터(Adapter - 서로 다른 인터페이스 연결)**, 브릿지(Bridge), 컴포지트(Composite), 데코레이터(Decorator), 파사드(Facade), 플라이웨이트(Flyweight), 프록시(Proxy)).
    *   **행위 패턴 (Behavioral Pattern)**: 객체 간의 **상호작용 및 책임 분배** 관련. (예: **체인 오브 리스폰스빌리티(Chain of Responsibility - 책임 연쇄)**, 커맨드(Command - 명령), 인터프리터(Interpreter), 이터레이터(Iterator), **중재자(Mediator - 통제/지시)**, 메멘토(Memento), 옵저버(Observer), 상태(State), 전략(Strategy), 템플릿 메소드(Template Method), 방문자(Visitor)).
*   **중재자 패턴 vs 아답터 패턴**:
    *   **중재자**: 통제와 지시 역할.
    *   **아답터**: 원활한 연결.

## 12. 인터페이스 요구사항 확인

*   **인터페이스 (Interface)**: 각각의 모듈 또는 컴포넌트가 어떻게 **연결**되는지 정의.
*   **요구사항 파악**: 현재 시스템 확인, 원하는 것 파악.
*   **요구사항 종류**:
    *   **기능적 요구사항**: 시스템이 수행해야 하는 기능.
    *   **비기능적 요구사항**: 성능, 보안, 품질 등 시스템 제약사항. (기능과 관련되지 않는 사항).
*   **요구사항 명세서**: 약속된 양식은 아니지만 인터페이스 요구사항 기술.
*   **요구사항 검증 방법**:
    *   **프로토타이핑 (Prototyping)**: 시제품 만들어 검증.
    *   **테스트 설계 (Test Design)**: 정상 동작 여부 테스트 케이스 생성.
    *   **요구사항 검토 (Requirements Review) 중요**: 도구를 이용하거나 수동으로 검토. (CASE 도구 이용 가능).
        *   **동료 검토 (Peer Review)**: 같은 부서 사람들끼리 검토.
        *   **워크 스루 (Walkthrough)**: 검토 전에 자료 배포, 짧은 회의로 문제점 대화로 찾음. (미리 걸어다니며 배포).
        *   **인스펙션 (Inspection)**: 전문가가 감사하며 잘못된 부분 찾음.

## 13. 인터페이스 대상 식별 및 연계 기술

*   **대상 식별**: 시스템 아키텍처 요구사항 분석, 현재 시스템 인터페이스 식별. 원하는 것이 정확히 무엇인지 파악.
*   **인터페이스 시스템 구성**: 보내는 애, 받는 애, 중계 시스템.
*   **인터페이스 데이터 표준**: 통일된 언어로 자료 교환 (표준화).
*   **내/외부 송수신 방식**:
    *   **직접 연계**: 중계 솔루션 **없음**.
    *   **간접 연계**: 중계 솔루션 **존재**.
*   **인터페이스 연계 기술 중요**: 두 컴포넌트/클래스/모듈 연결 방법.
    *   **DB Link**: 데이터베이스 객체 이용.
    *   **DB Connection (WAS)**: 웹 애플리케이션 서버(WAS) 부분에서 DB 커넥션 풀 생성 연결.
    *   **API (Application Programming Interface)**: 애플리케이션 프로그램 인터페이스. 소스 제공 (예: 카카오페이, 네이버페이). 오픈 API 통해 누구나 연결 가능.
    *   **JDBC (Java Database Connectivity)**: 자바 데이터베이스 연결.
    *   **Hyperlink**: 인터넷에서 클릭 시 연결.
    *   **Socket**: 통신 위한 연결 (콘센트/인터넷 선과 유사). 서버 통신 위해 생성/포트 할당, 클라이언트 통신 요청.
    *   **Web Service**: 웹 서비스 이용 (WSDL, UDDI, SOAP).
        *   **WSDL (Web Services Description Language)**: 웹 서비스 제공 **기술 언어**.
        *   **UDDI (Universal Description, Discovery, and Integration)**: 인터넷 비즈니스 목록(웹 서비스) **검색/홍보**. 기본 확장 형식: XML.
        *   **SOAP (Simple Object Access Protocol)**: 웹 서비스 이용 위한 객체 간 **통신 규약**. (실기 출제 가능성 언급).
    *   **EAI (Enterprise Application Integration)**: 기업 내 모든 애플리케이션 통합 이용.

## 14. 미들웨어 솔루션 (Middleware Solution)

*   **정의**: 애플리케이션 연결 중간에서 **중재**하는 역할. 자료 통일성 없을 때 통신 중재. 일종의 운영 체제, 서버와 유사.
*   **종류 중요**:
    *   **Database (DBMS)**: DBMS 통해 자료 교환.
    *   **TP Monitor (Transaction Processing Monitor) 중요**: **트랜잭션** (자료 교환 사이클)이 올바르게 처리되는지 **모니터링**.
    *   **ORB (Object Request Broker) 중요**: 객체지향 미들웨어, 코바 표준 스펙 구현. 객체들 사이 통신 담당 핵심. 브로커 역할.
    *   **RPC (Remote Procedure Call)**: **원격지**에서 프로시저 호출 방식.
    *   **MOM (Message Oriented Middleware)**: **메시지 기반** 미들웨어.
    *   **WAS (Web Application Server) 중요**: **웹을 통해** 다양한 애플리케이션 연계 역할. HTTP 이용. 서버 단에서 애플리케이션 동작 지원, 데이터 접근/세션/트랜잭션 관리 라이브러리 제공.
    *   **OTM (Object Transaction Monitor)**: TP Monitor 기능과 ORB 통합 형태.
*   **미들웨어 솔루션 분류**:
    *   DB 기반 (애플리케이션 ↔ 데이터 방식). (예: ODBC, JTA, JDBC, DA, OLE DB).
    *   통신 미들웨어 (애플리케이션 ↔ 애플리케이션 통신 연결). (예: RPC, MOM, ORB, OTM, DC).
*   **웹서버 vs WAS 구성**: 웹서버는 정적 콘텐츠, WAS는 동적 콘텐츠 처리 및 애플리케이션 연계 (미들웨어 역할). (WAS가 미들웨어 역할 함).

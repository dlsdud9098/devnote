**2과목: 소프트웨어 개발**

**통합 구현**
통합 구현은 기능을 하는 하나의 모듈들을 묶어서 더 큰 기능을 하도록 만드는 것입니다. 단위 모듈은 하나의 기능을 하는 프로그램으로 볼 수 있습니다.

**모듈화의 원리**
*   **분할과 지배(Divide and Conquer)**: 복잡한 문제를 분해하고 하나씩 해결해 나가는 원리입니다.
*   **정보 은폐(Information Hiding)**: 어렵거나 변경 가능성이 있는 부분을 다른 모듈로 숨기는 것입니다.
*   **자료 추상화(Data Abstraction)**: 함수 내 자료 구조 표현 변수를 은폐하고, 자료와 자료에 적용되는 오퍼레이션을 함께 정의하는 것입니다.
*   **모듈 독립성(Module Independence)**: 모듈 간의 결합도는 낮게, 응집도는 높게 유지하는 것입니다.

통합하기 전에 단위 모듈이 정상적으로 처리되는지 확인하는 **단위 모듈 테스트**를 수행합니다.

**구현 단계 작업 절차**
구현 단계는 다음과 같은 절차로 진행됩니다:
1.  계획(Plan)
2.  코딩(Coding): 명령어를 나열하는 단계입니다.
3.  컴파일(Compile): 코드를 실행할 수 있도록 만들어 주는 단계입니다.
4.  테스트(Test): 코드가 정상적으로 데이터 처리를 하는지 확인하는 단계입니다.

**통합 개발 환경 (IDE)**
IDE는 소프트웨어 개발을 지원하는 도구입니다. C++, Java 등의 언어를 이용한 소스 코딩부터 통합까지 모든 작업을 지원하는 환경을 제공합니다. 종류에는 **이클립스(Eclipse)** (Java), **비주얼 C(Visual C)** (C), **Xcode**, **안드로이드 스튜디오(Android Studio)**, **IntelliJ IDEA** 등이 있습니다.

**빌드(Build)**
빌드는 개발한 프로그램을 실제 실행될 수 있도록 만들어 주는 과정을 의미합니다. 구축한다고 표현하기도 합니다. 빌드 과정은 일반적으로 컴파일, 패키징(다음 시간에 상세히 다룸), 단위 테스트, 정적 분석, 리포팅, 최종 빌드의 순서로 진행됩니다.

**빌드 도구**
*   **그래들(Gradle)**: JVM 기반의 도구이며, Groovy 기반입니다. 안드로이드의 기본 빌드 시스템입니다.
*   **젠킨스(Jenkins)**: Java 기반의 오픈 소스 도구입니다.
*   **메이크 파일(Make file)**
*   **앤트(Ant)**: 아파치 소프트웨어 재단에서 개발했습니다.
*   **메이븐(Maven)**: 프로젝트에 필요한 모든 종속성을 리스트 형태로 관리합니다.

**제품 소프트웨어 패키징(Packaging)**
빌드하여 실행 가능한 상태로 만든 소프트웨어를 판매할 수 있도록 포장하는 과정입니다. 패키징 시 사용자의 시스템 환경을 고려해야 합니다.

**패키징 고려 사항**
*   내부 콘텐츠에 대한 **암호화 보안**이 중요합니다.
*   다양한 이기종 콘텐츠에 대한 **DRM(보안 모듈)** 적용이 필요합니다. DRM은 특정 권한이 없는 사람이 콘텐츠를 볼 수 없도록 합니다.
*   사용자 편의성을 위한 복잡성 및 비효율성 문제를 고려해야 합니다.
*   제품 소프트웨어에 적합한 **암호 알고리즘**을 적용하여 범용성에 지장이 없도록 해야 합니다.

**패키징 도구 활용 시 고려 사항**
패키징 도구는 불법 복제를 막고, 사용 권한 및 라이선스를 관리하는 등의 역할을 합니다. 패키징 도구 활용 시 고려 사항은 객관식 문제로 쉽게 풀 수 있는 상식선에서 나옵니다.

**패키징 도구 구성 요소**
*   **암호화(Encryption)**
*   **키 관리(Key Management)**: 암호화에 사용되는 키를 관리합니다.
*   **암호 파일 생성(Encrypted File Generation)**
*   **식별 기술(Identification Technology)**
*   **저작권 표현(Copyright Expression)**
*   **정책 관리(Policy Management)**
*   **크랙 방지(Crack Prevention)**: 유료 소프트웨어를 무료로 무력화시키는 것을 방지합니다.
*   **인증(Authentication)**

**모니터링 도구와 협업 도구**
*   **모니터링 도구**: 애플리케이션이 정상적으로 작동하는지 감시하며, 성능 관리 등에 사용됩니다. 대표적인 예로 **APM(Application Performance Management)**이 있습니다.
*   **협업 도구**: 소프트웨어 개발에 참여하는 여러 이해관계자(스테이크 홀더)의 문서, 소스, 아이디어, 디자인 공유, 일정 관리, 프로젝트 관리, 마인드 맵 등 관리를 위해 사용됩니다.

**제품 소프트웨어 저작권 (DRM: Digital Rights Management)**
DRM은 소프트웨어가 불법 복제되지 않도록 관리하는 기술입니다. 요즘에는 앱스토어, 플레이스토어 등 스토어에서 이러한 역할을 수행하며, 이러한 역할을 하는 주체를 **클리어링 하우스(Clearing House)**라고 합니다.

**DRM 특성**
*   거래의 투명성
*   사용 규칙 제공
*   자유로운 상거래 제공

**DRM 기술 요소**
*   **암호화(Encryption)**
*   **키 관리(Key Management)**
*   **암호 파일 생성(Encrypted File Generation)**
*   **식별 기술(Identification Technology)**
*   **저작권 표현(Copyright Expression)**
*   **정책 관리(Policy Management)**
*   **크랙 방지(Crack Prevention)**
*   **인증(Authentication)**
*   **라이선스 발급(License Issuance)**
*   **인터페이스(Interface)**: 상이한 DRM 플랫폼 간 호환성을 제공합니다.
*   **보고(Reporting)**: 문제가 발생했을 때 보고서를 생성합니다.

**DRM 유통 과정**
콘텐츠 제공자(제작자)가 패키징을 하면 분배자(유통 시스템, 쇼핑몰, 스토어)를 통해 소비자에게 전달됩니다. 클리어링 하우스는 라이선스 등록, 요청 처리, 요금 지불 및 라이선스 발급을 관리하는 정산 및 분배의 중심 주체입니다. 보안 컨테이너는 원본을 안전하게 유통시키기 위한 장치이며, DRM 컨트롤러는 전체 콘텐츠를 통제하는 역할을 합니다.

**콘텐츠 사용 권한 유형 (Permissions)**
*   **렌더 퍼미션(Render Permission)**: 콘텐츠가 표현되고 이용되는 형태를 정의합니다 (예: 문서 보기/프린트, 동영상 플레이). 일반적으로 제공되는 형태입니다.
*   **트랜스포트 퍼미션(Transport Permission)**: 콘텐츠의 교환 가능성에 대한 권리입니다 (예: 복사, 이동, 돈을 주고 권한 양도).
*   **데리버티브 퍼미션(Derivative Permission)**: 콘텐츠의 추출이나 변형이 가능한 권리입니다.

**제품 소프트웨어 매뉴얼 작성**
패키징된 소프트웨어를 사용자에게 제공할 때 필요한 설명서입니다. 요즘에는 웹이나 유튜브 영상을 통한 매뉴얼 제공이 일반적입니다.

**설치 매뉴얼**
소프트웨어를 설치하는 방법에 대한 매뉴얼입니다. 목차, 개요, 문서 이력 정보, 주석(주의/참고 사항), 설치 도구 구성, 설치 위치 등에 대한 내용이 포함될 수 있습니다.

**설치 매뉴얼 기본 사항**
소프트웨어 개요, 설치 관련 파일, 설치 아이콘, 삭제 방법, 관련 추가 정보 등이 포함됩니다.

**설치 매뉴얼 작성 절차**
1.  기능 식별
2.  UI 분류
3.  설치 파일 및 백업 파일 확인
4.  삭제 절차 확인
5.  이상 상황 확인
6.  최종 매뉴얼 적용

**사용자 매뉴얼**
설치된 소프트웨어를 실제 사용하는 방법에 대한 매뉴얼입니다. 사용자 화면 설명(버튼 기능 등), 주요 기능 설명, 응용 프로그램 설정 방법, 장치 연동 방법, 고객 지원, 보증 등에 대한 내용이 포함됩니다.

**사용자 매뉴얼 작성 절차**
1.  작성 지침 정의
2.  구성 요소 확인 (기능 등)
3.  구성 요소별 내용 작성
4.  검토
5.  실제 사용자 매뉴얼 적용

**소프트웨어 국제 표준 품질 특성**
*   **ISO/IEC 9126**: 소프트웨어 품질 특성과 측정 지표를 정의합니다.
*   **ISO/IEC 12119**: 패키지 소프트웨어의 일반적인 제품 품질 요구사항 및 테스트를 위한 국제 표준입니다 (소방 훈련 119로 기억).
*   **ISO 9001**: 설계, 개발, 생산, 설치, 서비스 전 과정에 대한 품질 보증 인증입니다.

**소프트웨어 품질 목표**
정확성, 신뢰성, 운영 용이성, 효율성, 무결성, 이식성, 상호 운용성, 재사용성, 유지 보수성, 유연성, **시험 용이성(Testability)** 등이 있습니다.

**소프트웨어 품질 측정 관점**
*   **사용자 관점**: 신뢰성, 효율성, 사용 용이성 등 간결함을 중시합니다.
*   **개발자 관점**: 검증 가능성, 유지 보수성, 이식성, 무결성, 사용성 등을 중시합니다.
*   **프로젝트 관리자 관점**: 생산성 및 제어 용이성을 중시합니다.

**릴리즈 노트(Release Note)**
소프트웨어를 배포할 때 작성하는 문서입니다. 어떤 내용이 변경, 추가, 수정되었는지 등을 기록합니다.

**릴리즈 노트 작성 항목**
문서 이름, 제품명, 배포 버전, 릴리즈 날짜, 개요, 목적, 이슈, 제언 항목, 수정 개선 내용, 최종 사용자 영향도, 면책 조항, 정보(연락처 등) 등이 포함됩니다.

**형상 관리(Configuration Management)**
개발 단계에서 생성되는 모든 작업 산출물(형상 항목)을 관리하는 것을 의미합니다.

**형상 관리 항목**
프로젝트 요구 분석서, 소스 코드, 운영 및 설치 지침서, 요구사항 명세서, 설계, 인터페이스 명세서, 테스트 설계, 소프트웨어 품질 보증, 형상 관리 계획서, V&V(확인 및 검증), 코드, 모듈 등 개발 과정의 모든 자료가 포함됩니다. 개발 비용은 포함되지 않습니다.

**형상 관리 개념**
*   **버전 관리(Version Management)**: 형상 항목의 변경 사항을 기록하고 관리합니다.
*   **변경 관리(Change Management)**: 요구사항 등 형상 항목의 변경 내용을 기록하고 통제합니다.

**형상 관리 도구**
형상 항목 관리를 지원하는 도구입니다.

**형상 관리 절차**
1.  **대상체 확인(Identification)**: 관리할 형상 항목을 확인합니다.
2.  **형상 통제 위원회(Configuration Control Board)**: 변경 사항을 통제하는 주체입니다.
3.  **형상 감사(Configuration Audit)**: 변경 사항의 정확성, 기술 검토 수행 여부, 프로세스 준수 여부 등을 확인합니다. 문제가 발견되거나 수정할 내용이 있을 경우 형상 감사를 통해 기준선을 변경합니다.
4.  **형상 기록 및 보고(Status Accounting)**: 변경에 대한 정보를 기록하고 보고합니다.
**기준선(Baseline)**: 형상 관리의 기본이 되는 시점을 의미하며, 형상 통제 위원회의 통제를 통해 변경 가능합니다.

**형상 관리, 버전 관리, 변경 관리의 관계**
형상 관리가 가장 큰 범위이며, 그 하위에 버전 관리와 변경 관리가 포함됩니다. 변경 관리는 버전 관리의 일부 내용에 해당될 수 있습니다.

**버전 관리 도구 방식**
*   **공유 폴더 방식**: 담당자 한 명이 공유 폴더에 자료를 놓고 공유합니다. 초기 형태로 파일 변경 사항을 DB에 기록하지 않습니다.
*   **클라이언트-서버 방식**: 서버와 클라이언트 형태로 사용하며, 대표적으로 **CVS(Concurrent Versions System)**와 **SVN(Subversion)**이 있습니다. SVN은 CVS보다 속도가 개선되었습니다. 네트워크가 끊기면 개발이 불가능합니다.
*   **분산 저장소 방식**: 원격 저장소와 로컬 저장소에 함께 저장되며, 대표적으로 **Git**이 있습니다. 네트워크가 끊겨도 동시 개발이 가능합니다. **GitHub** 등에서 활용됩니다.

**주요 버전 관리 도구**
*   **CVS**: 오픈 소스 프로젝트에 많이 사용되며, 여러 개발자가 협력 작업을 할 수 있습니다.
*   **RCS**: 한 사람만 파일 수정을 제한하는 형태입니다.
*   **SVN**: CVS보다 속도가 개선되었습니다.
*   **BitKeeper**: SVN과 비슷합니다.
*   **Git**: 지역 저장소와 원격 저장소 두 개가 있습니다. 리누스 토발즈가 개발했습니다.

**버전 관리 용어**
*   **Repository(저장소)**: 프로젝트 파일이 저장되는 곳.
*   **Branch(브랜치)**: 분기된 개발 소스.
*   **Fork(포크)**: 소스 코드를 통째로 복사해 오는 것.
*   **Commit(커밋)**: 저장 내역을 승인하는 것.
*   **Check-out(체크아웃)**: 저장소에서 파일을 가지고 나오는 것.
*   **Check-in(체크인)**: 개발한 내용을 저장소에 넣는 것. (SVN에서 사용되는 용어로, Git의 push/commit에 해당될 수 있음)
*   **Import(임포트)**: 저장소에 맨 처음 소스 파일을 넣는 것.
*   **Diff(디프)**: 파일 간의 차이점을 비교하는 것 (Differentiate 약자).
*   **Update(업데이트)**: 저장소의 최신 상태로 갱신하는 것.
*   **Merge(머지)**: 브랜치를 통합하는 것.
*   **Fetch(페치)**: 원격 저장소의 코드를 받아오는 것.
*   **Pull(풀)**: 원격 저장소의 코드를 받아와서 현재 브랜치에 병합하는 것.
*   **Clone(클론)**: 원격 저장소를 통째로 복사해서 내려받는 것.

**애플리케이션 테스트 관리**
소프트웨어가 정상적으로 작동하는지 확인하는 과정입니다. 품질 향상, 오류 발견 및 예방에 도움이 됩니다.

**소프트웨어 테스트 원리**
*   테스팅은 결함의 존재를 밝히는 것입니다.
*   완벽한 테스팅(모든 오류 발견)은 불가능합니다.
*   테스팅은 개발 초기부터 시작해야 합니다 (모듈 단위 테스트부터).
*   **결함 집중 원칙(Defect Clustering)**: 애플리케이션 결함의 대부분은 소수의 특정 모듈에 집중됩니다. 이는 **파레토 법칙(Pareto Principle, 80/20 법칙)**과 관련이 있으며, 전체 오류의 80%가 전체 원인의 20%에서 발생한다는 것입니다.
*   **살충제 패러독스(Pesticide Paradox)**: 동일한 테스트 케이스로 반복 테스트 시 더 이상 새로운 결함을 발견하기 어렵습니다. 주기적으로 테스트 케이스를 리뷰하고 개선해야 합니다.
*   테스팅은 정황에 의존합니다 (컨텍스트에 따라 테스트 방법 달라짐).
*   **오류 부재의 궤변(Absence-of-errors Fallacy)**: 오류가 없다고 해서 사용자의 요구사항을 모두 충족시키는 것은 아닙니다.

**테스트 케이스(Test Case)**
테스트를 수행하기 위해 사전에 정의된 입력 값, 실행 조건, 예상 결과 등의 집합입니다.

**테스트 프로세스**
계획 -> 분석 및 설계 -> 구현 및 실행 -> 평가 -> 완료 순서로 진행되며, 평가 후 문제가 있을 시 다시 계획 및 제어 단계로 돌아갑니다.

**테스트 커버리지(Test Coverage)**
테스트 수행 정도(얼마나 많은 부분을 테스트했는지)를 의미합니다. 구문, 결정, 조건, 결정/조건, 변경 조건/결정, 다중 조건 커버리지 등으로 구분됩니다.

**테스트 오라클(Test Oracle)**
테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값 또는 판단 기준을 말합니다.
*   **참 오라클(True Oracle)**: 모든 입력 값에 대해 적합한 결과를 생성하고 오류를 모두 검출할 수 있습니다.
*   **일관성 검사(Consistency Checker)**: 테스트 수행 전과 후의 결과 값이 동일한지 확인합니다.
*   **샘플링(Sampling)**: 임의로 선정한 일부 입력 값에 대해서만 올바른 결과를 확인합니다.
*   **휴리스틱 오라클(Heuristic Oracle) / 추정 오라클**: 샘플링 오라클을 개선한 것으로, 일부 값은 올바른 결과로 확인하고 나머지는 추정하여 처리합니다.

**V-모델 (테스트 레벨)**
개발 단계와 테스트 단계가 V자 형태로 연결됩니다.
*   **단위 테스트(Unit Test)**: 개별 모듈 또는 컴포넌트(객체지향에서는 클래스)를 대상으로 수행합니다. 개발자 시각의 **검증(Verification)**에 해당합니다.
*   **통합 테스트(Integration Test)**: 단위 테스트를 마친 모듈들을 인터페이스를 통해 통합하면서 수행합니다.
*   **시스템 테스트(System Test)**: 통합된 시스템이 실제 운영 환경(Windows, Linux, Android 등)에서 정상 작동하는지 확인합니다. 사용자 시각의 **확인(Validation)**에 해당합니다.
*   **인수 테스트(Acceptance Test)**: 개발 완료된 소프트웨어를 고객이 직접 테스트하여 요구사항을 충족하는지 확인합니다.
    *   **알파 테스트(Alpha Test)**: 개발사 내부에서 개발자가 아닌 다른 부서 직원이나 사용자가 개발자 앞에서 수행합니다. 개발자 관점의 검사 기법입니다.
    *   **베타 테스트(Beta Test)**: 개발사 외부의 선정된 다수의 사용자가 실제 환경에서 수행합니다.

**정적 테스트(Static Testing)와 동적 테스트(Dynamic Testing)**
*   **정적 테스트**: 소프트웨어를 실행하지 않고 명세서나 소스 코드를 분석하여 결함을 발견합니다. 개발 초기에 결함을 발견하여 개발 비용을 낮출 수 있습니다. 소스 코드 검증, 코드 리뷰 등이 있습니다.
*   **동적 테스트**: 소프트웨어를 직접 실행하여 결함을 발견합니다. 블랙박스 테스트와 화이트박스 테스트가 있습니다.

**블랙박스 테스트(Black-box Testing)**
소프트웨어의 내부 구조를 알지 못하는 상태에서 요구사항/명세서를 기반으로 입력과 출력을 비교하여 테스트합니다.

**블랙박스 테스트 기법**
*   **동등 분할(Equivalence Partitioning)**: 입력 데이터를 동등한 특성을 가진 클래스로 분할하여 각 클래스 대표 값으로 테스트 케이스를 생성합니다. 타당한 입력과 그렇지 않은 것을 반반 넣어 테스트합니다.
*   **경계값 분석(Boundary Value Analysis)**: 동등 분할 기법을 보완하여 입력 조건의 경계값 주변에서 오류가 자주 발생하므로, 경계값을 포함한 근처 값을 테스트 케이스로 사용합니다. (예: 80점 이상 합격이면 79, 80, 81점을 테스트).
*   **원인-효과 그래프(Cause-Effect Graphing)**: 입력 데이터 간 관계와 출력에 영향을 주는 상황을 체계적으로 분석하여 효율적인 테스트 케이스를 선정합니다.
*   **오류 예측(Error Guessing)**: 과거 경험을 기반으로 오류가 발생할 가능성이 높은 부분을 예측하여 테스트합니다.
*   **비교 검사(Comparison Testing)**: 동일한 테스트 데이터를 여러 버전의 프로그램에 입력하고 동일한 결과가 나오는지 비교합니다.
*   블랙박스 테스트는 루프 내 문장 수행 여부 등 내부 실행 과정은 확인할 수 없습니다.

**화이트박스 테스트(White-box Testing)**
소프트웨어의 내부 구조, 소스 코드, 논리적 경로를 오픈한 상태에서 직접 관찰하며 테스트합니다.

**화이트박스 테스트 기법**
*   **기초 경로 검사(Basis Path Testing)**: 제어 흐름 그래프를 분석하여 선형 독립적인 실행 경로를 테스트합니다.
*   **제어 구조 검사(Control Structure Testing)**:
    *   조건 검사(Condition Testing): 논리적 조건(예: 90점 이상이면)을 테스트합니다.
    *   루프 검사(Loop Testing): 반복 조건이 올바르게 수행되는지 테스트합니다.
    *   데이터 흐름 검사(Data Flow Testing): 변수의 정의와 사용 경로를 테스트합니다.

**테스트 기반**
*   **구조 기반(Structure-based)**: 소프트웨어 내부 구조를 보고 테스트합니다. (예: 구문, 결정, 데이터 흐름 커버리지).
*   **명세 기반(Specification-based)**: 요구사항 및 명세서를 보고 테스트합니다. (예: 동등 분할, 경계값 분석, 원인-결과 그래프).
*   **경험 기반(Experience-based)**: 과거 경험을 바탕으로 테스트합니다. (예: 에러 추정, 체크리스트).

**목적에 따른 테스트**
성능, 회복, 보안, 강도, 회귀, 병렬 테스트 등이 있습니다.

**테스트 시나리오(Test Scenario)**
테스트를 수행하기 위한 여러 테스트 케이스의 집합이며, 테스트 동작 순서를 기술한 문서입니다. 시스템별, 모듈별, 항목별로 분류하여 작성합니다.

**테스트 환경 구축**
소프트웨어가 운영될 실제 환경과 유사하게 하드웨어, 소프트웨어, 가상 시스템 등을 구축합니다.

**테스트 하네스(Test Harness) 도구**
테스트 수행을 지원하기 위한 도구의 집합입니다.
*   **테스트 스텁(Test Stub)**: 하향식 통합 테스트 시 아직 개발되지 않은 하위 모듈을 임시로 대체하는 가상의 모듈입니다.
*   **테스트 드라이버(Test Driver)**: 상향식 통합 테스트 시 아직 개발되지 않은 상위 모듈을 임시로 대체하는 가상의 모듈입니다.
*   **테스트 슈트(Test Suite)**: 일정한 순서로 수행되는 개별 테스트의 집합입니다.
*   **테스트 케이스(Test Case)**: 테스트에 필요한 예상 데이터 집합입니다.
*   **테스트 스크립트(Test Script)**: 테스트 자동화를 위해 테스트 절차를 자동화 언어로 작성한 것입니다.
*   **목 오브젝트(Mock Object)**: 테스트를 위해 행위를 미리 입력해 놓은 가짜 객체입니다.

**테스트 자동화 도구**
*   **정적 분석 도구**: 코딩 표준, 복잡도, 결함 등을 분석합니다. (예: Pmd, Cppcheck, SonarQube). 개발 초기에 사용됩니다.
*   **실행 도구**: 스크립트 언어를 이용하여 테스트를 실행합니다.
*   **성능 테스트 도구**: 처리량, 응답 시간 등을 측정하기 위해 부하나 스트레스를 가하여 성능을 분석합니다.
*   **테스트 통제 도구**
*   **테스트 하네스 도구**

**테스트 수행 단계별 자동화 도구**
*   계획 단계: 요구사항 관리 도구
*   분석 및 설계 단계: 테스트 케이스 생성 도구
*   수행 단계: 테스트 자동화, 정적/동적 분석, 성능 테스트, 모니터링 도구
*   관리 단계: 커버리지 분석, 형상 관리, 결함 추적 도구

**통합 테스트(Integration Test) 방식**
단위 테스트를 마친 모듈들을 통합하며 수행하는 테스트입니다.
*   **비점진적 방법(Non-incremental)**:
    *   **빅뱅(Big Bang)**: 모든 모듈을 한 번에 통합하여 테스트합니다. 규모가 작은 경우 적합하며, 오류 수정이 어렵습니다. 드라이버나 스텁을 사용하지 않습니다.
*   **점진적 방법(Incremental)**: 단계적으로 통합하며 테스트합니다. 오류 수정이 쉽고 인터페이스 관련 오류 테스트가 용이합니다.
    *   **하향식(Top-down)**: 상위 모듈부터 하위 모듈 방향으로 통합하며, 하위 모듈을 대체할 **스텁(Stub)**을 사용합니다. 깊이 우선 또는 너비 우선 방식으로 진행될 수 있습니다.
    *   **상향식(Bottom-up)**: 하위 모듈부터 상위 모듈 방향으로 통합하며, 상위 모듈을 대체할 **드라이버(Driver)**를 사용합니다.
    *   **샌드위치 통합(Sandwich Integration)**: 하향식과 상향식을 결합한 방식입니다.

**결함 관리(Defect Management)**
소프트웨어의 문제점(에러, 결함, 버그, 실패 등)을 식별, 기록, 추적하고 해결하는 일련의 과정입니다.

**결함 심각도 및 우선순위**
*   심각도: 치명적, 주요, 보통, 경미, 단순
*   우선순위: 결정적, 높음, 보통, 낮음

**결함 관리 프로세스**
계획 -> 기록 -> 검토 -> 수정 -> 재확인 -> 상태 추적/모니터링 -> 최종 결함 분석 및 보고서 작성.

**결함 추적 절차**
결함 발견 -> 등록 -> 검토 -> 담당자 할당 -> 결함 수정 -> 조치(보류 또는 해제).

**결함 관리 도구**
Mantis, Trac, Bugzilla, Redmine, Jira, TestLink 등 결함 관리 및 추적을 지원하는 도구들입니다.

**결함 관련 용어**
*   **에러(Error)**: 개발자의 실수로 인한 오타, 명세서 잘못된 이해 등으로 발생하는 부정확한 결과.
*   **오류(Fault/Defect)**: 연산자 잘못 사용, 코드 누락 등 프로그램 코드 내의 문제.
*   **실패(Failure)**: 프로그램이 정상적으로 실행되지 못하는 것.
*   **결함(Defect)**: 에러, 오류, 실패 등을 포괄하는 용어 (버그).
*   **결함 내성(Defect Tolerance) / 고장 허용성**: 일부 결함이 있더라도 프로그램 실행에 큰 문제가 없는 특성.

**애플리케이션 성능 지표**
*   **처리량(Throughput)**: 단위 시간당 처리할 수 있는 작업량.
*   **응답 시간(Response Time)**: 작업 요청 시점부터 응답이 시작될 때까지 걸리는 시간.
*   **경과 시간(Elapsed Time)**: 입력한 시점부터 출력이 완료될 때까지 걸리는 시간.
*   **자원 사용률(Resource Utilization)**: CPU, 메모리, 네트워크 등 자원 사용 정도.

**성능 분석 도구**
*   **성능 부하/스트레스 점검 도구**: 가상 사용자를 생성하여 시스템에 부하를 가하고 성능을 측정합니다.
*   **모니터링 도구**: 애플리케이션 성능 및 서비스 운영 상태를 감시합니다. (예: Scouter, Jennifer).

**성능 저하 원인**
과도한 DB Lock, 불필요한 DB Fetch, Connection 누수, 부적절한 Connection Pool 사이즈, 불필요한 Commit 발생, Thread 문제, 잘못된 환경 설정 등.

**알고리즘**
문제 해결 방법을 의미합니다. 자연어, 순서도, 의사 코드 등으로 표현할 수 있습니다. **의사 코드(Pseudo-code)**는 특정 프로그래밍 언어 문법이 아닌 일반적인 언어로 작성된 코드 표현입니다.

**알고리즘 설계 기법**
*   **분할 정복법(Divide and Conquer)**: 큰 문제를 분할이 불가능할 때까지 나누고(Divide), 나뉜 작은 문제들을 해결(Conquer)한 후, 해결한 문제들을 합쳐(Combine) 원래 문제의 해답을 얻는 기법입니다. (예: 퀵 정렬, 병합 정렬).
*   **동적 계획법(Dynamic Programming)**: 문제를 부분 문제로 분리하여 쉬운 문제부터 해결하고, 그 해답을 이용하여 상위 문제를 해결해 나가는 기법입니다. (예: 플로이드 알고리즘, 피보나치 수열).
*   **탐욕법(Greedy Method)**: 국소적인 관점에서 최적의 해결 방법을 구하는 기법입니다. 동적 계획법보다 효율적일 수 있으나 항상 전역 최적해를 보장하지는 않습니다. (예: 크루스칼, 다익스트라 알고리즘).
*   **퇴각 검색법(Backtracking)**: 문제 해결 방법을 찾기 위해 모든 가능성을 탐색하다가 해가 될 수 없다고 판단되면 이전 단계로 돌아가 다른 가능성을 탐색하는 기법입니다. (예: N-Queens 문제).
*   **분기 한정법(Branch and Bound)**: 해가 될 가능성이 없는 경로는 탐색하지 않고 가지치기하여 효율성을 높이는 기법입니다.
*   **근사 해법(Approximation Method)**: 복잡도가 높은 문제에 대해 최적해에 가까운 근사치를 구하는 기법입니다.

**시간 복잡도(Time Complexity)**
알고리즘 문제를 해결하는 데 필요한 시간 자원을 의미하며, **빅 오(Big O)** 표기법으로 나타냅니다. (예: O(1), O(log n), O(n), O(n log n), O(n^2), O(n!)). O(n log n)은 주로 퀵 정렬이나 병합 정렬에서 사용됩니다.

**순환 복잡도(Cyclomatic Complexity)**
프로그램의 이해 난이도 또는 제어 흐름 난이도를 측정하는 지표입니다. **사이클로매틱 개수**로 산정되며, 오류 개수와 밀접한 관계가 있습니다. 계산 공식은 V(G) = **간선 수(E)** - **노드 수(N)** + **2** 입니다.

**해싱 함수(Hashing Function)**
레코드 키 값을 받아 해시 테이블의 주소로 변환하는 함수로, 데이터 검색 속도를 높이는 데 사용됩니다.
*   **제산법(Division Method)**: 레코드 키를 어떤 수로 나눈 나머지를 주소로 사용합니다.
*   **중간 제곱법(Mid-square Method)**: 키 값을 제곱한 뒤 중간 부분의 몇 비트를 선택하여 주소로 사용합니다.
*   **중첩법(Folding Method)**: 레코드 키를 여러 부분으로 나눈 뒤, 이들을 더하거나 **XOR** 연산하여 주소로 사용합니다.
*   **기수 변환법(Radix Conversion Method)**: 키를 구성하는 수를 다른 기수로 변환하여 주소로 사용합니다.
*   **동의어(Synonym)**: 서로 다른 키 값이 동일한 해시 주소로 변환되어 충돌이 일어나는 경우, 해당 키 값들의 집합을 동의어라고 합니다.

**소스 코드 최적화**
소스 코드를 깔끔하고 효율적으로 개선하는 과정입니다.

**클린 코드(Clean Code) 작성 원칙**
가독성, 단순성, 의존성 배제, 중복성 최소화, 추상화 등. 공백, 주석, 들여쓰기, 빈 줄 등을 활용하여 코드 가독성을 높이는 지침이 있습니다.

**나쁜 코드(Bad Code)와 외계인 코드(Wicked Code)**
*   **나쁜 코드**: 가독성, 단순성 등이 부족한 코드입니다.
*   **외계인 코드**: 프로그램 로직이 복잡하거나, 아주 오래되었거나, 참고 문서가 부족하거나, 개발자가 없어서 유지보수가 어려운 프로그램을 의미합니다.

**소스 코드 품질 분석 도구**
소스 코드의 품질을 분석하는 도구입니다.
*   **정적 분석 도구**: 소스 코드를 실행하지 않고 분석합니다. 코딩 오류, 표준 위반, 잠재적 실행 오류, 안정성 저해 요소 등을 찾습니다. (예: Pmd, Cppcheck, SonarQube, StyleCop, Checkstyle, FindBugs). 개발 초기에 사용됩니다.
*   **동적 분석 도구**: 애플리케이션을 실제 실행하여 분석합니다. (예: Avalanche, Valgrind, IBM Rational Purify). 테스트 또는 완료 단계에서 사용됩니다.

**정적 분석과 동적 분석 비교**
*   대상: 정적 - 소스 코드, 동적 - 실제 애플리케이션.
*   기술: 정적 - 오염 분석, 패턴 비교, 동적 - 실제 실행.
*   단계: 정적 - 개발 단계, 동적 - 완료 단계.

**인터페이스 구현**
각각의 모듈 또는 컴포넌트/애플리케이션을 연결하여 서로 데이터를 주고받을 수 있도록 하는 과정입니다.

**인터페이스 설계 정의서**
인터페이스를 어떻게 연결할 것인지 정의한 문서입니다. 내외부 모듈 기능 확인, 인터페이스 기능 정의, 정형화 순서로 작성됩니다.

**모듈 연계 기술**
*   **EAI (Enterprise Application Integration)**: 기업 내 모든 애플리케이션을 통합하는 기술입니다.
    *   **Point-to-Point (점대점)**: 애플리케이션 간 1:1로 직접 연결하며, 별도의 미들웨어 솔루션이 없습니다.
    *   **Hub & Spoke**: 중앙의 허브 시스템을 통해 데이터를 전송하는 중앙 집중 방식입니다. 허브 장애 시 전체 시스템에 영향을 미칩니다. 확장 및 유지 보수가 수월합니다.
    *   **Message Bus (메시지 버스)**: 메시지 버스 라인을 통해 데이터를 주고받으며, 데이터 처리 용량 관리가 용이합니다.
    *   **Hybrid (하이브리드)**: 허브 앤 스포크와 메시지 버스 방식을 혼합한 형태입니다. 데이터 병목 현상을 최소화할 수 있습니다.
*   **ESB (Enterprise Service Bus)**: EAI보다 확장된 개념으로, 기업 내 모든 애플리케이션을 서비스 관점에서 통합하는 기술입니다. 서비스 중심 통합을 지향합니다.

**데이터 표준화**
인터페이스 시 데이터를 원활하게 주고받기 위해 JSON, XML 등 표준 언어 형식을 사용하거나 DB 연결을 활용합니다.

**데이터 통신 기술 (인터페이스 구현 시)**
*   **AJAX (Asynchronous JavaScript and XML)**: 자바스크립트를 이용하여 서버와 비동기적으로 XML 데이터를 주고받는 통신 기술입니다.
*   **JSON (JavaScript Object Notation)**: 자바스크립트 기반의 경량 데이터 교환 형식으로, **속성-값 쌍**으로 구성됩니다. 웹 환경에서 데이터 교환에 많이 사용됩니다 (전자 결제 등).

**인터페이스 구현 검증**
구현된 인터페이스가 정상적으로 통신하고 처리되는지 확인하는 과정입니다. 단위 기능 및 시나리오 기반 통합 테스트가 필요합니다.

**인터페이스 구현 검증 도구**
*   **WATIR / waitr**: 웹 애플리케이션 테스트 도구입니다.
*   **xUnit (jUnit, cUnit 등)**: 다양한 언어를 지원하는 단위 테스트 프레임워크입니다.
*   **FitNesse**: 웹 기반 테스트 케이스 도구입니다.
*   **STAF (Service Test Automation Framework) / 스타포**: 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크입니다. 분산 환경의 **데몬(Daemon)**을 지원합니다.
*   **Selenium**: 다양한 브라우저 및 언어를 지원하는 웹 애플리케이션 테스트 프레임워크입니다.

**인터페이스 구현 감시 도구**
구현된 인터페이스의 동작 상태를 감시하는 도구입니다. APM(Application Performance Management)을 활용하며, **Scouter**, **Jennifer** 등이 있습니다.

**인터페이스 보안**
데이터 통신 시 데이터 탈취 등의 위협에 대비하여 보안을 적용합니다.

**데이터 탈취 위협**
*   **스니핑(Sniffing)**: 네트워크 주변을 오가며 데이터를 몰래 엿보는 행위 (강아지가 킁킁거리는 것에 비유).
*   **스푸핑(Spoofing)**: 다른 사용자인 것처럼 가장하여 통신하는 행위.

**인터페이스 보안 적용**
*   **데이터베이스 암호화**.
*   **시큐어 코딩(Secure Coding)**: OWASP 표준 및 KISA 가이드 등을 참고하여 안전한 코드를 작성합니다.
*   **네트워크 보안 적용**:
    *   **전송 계층(Transport Layer)**: **IPSec(IP 보안)**을 적용합니다. IPSec은 인터넷 패킷을 암호화하고 인증하는 안전한 인터넷 프로토콜입니다. AH(Authentication Header) 등을 사용합니다.
    *   **응용 계층(Application Layer)**: **SSL/TLS**, **HTTPS**, **SSH** 등을 적용합니다. SSL/TLS는 웹에서 보여지는 부분을 암호화하는 인증서 기반 기술입니다.

**데이터 암호화 알고리즘 유형**
*   **대칭 키 암호화**: 암호화 키와 복호화 키가 **동일**합니다. (예: ARIA, SEED, DES, AES, RC).
*   **비대칭 키 암호화**: 암호화 키와 복호화 키가 **서로 다릅니다**. (예: RSA, ECDSA, ECC).
*   **해시 함수**: 단방향 암호화 방식으로, 입력 값으로 고정된 크기의 해시 값을 생성하며 복호화가 불가능합니다. (예: SHA, MD5).

**데이터베이스 암호화 기법**
API 방식, 필터 방식, 플러그인 방식, 하이브리드 방식 등이 있습니다.

**연계 테스트(Linkage Test)**
인터페이스를 통해 시스템 간 연계가 제대로 이루어지는지 확인하는 테스트입니다. 연계 테스트 구간, 연계 단위 테스트, 통합 테스트 등으로 진행될 수 있습니다.

제공된 소스에 기반하여 2과목의 주요 내용을 상세히 정리해 드렸습니다. 각 내용 뒤에 해당 정보를 가져온 출처([소스 번호])를 표시했습니다. 이 내용이 2과목을 이해하시는 데 도움이 되기를 바랍니다.
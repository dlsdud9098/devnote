### 과목 1: 소프트웨어 설계  

1.  다음은 TCP/IP 기반 네트워크에서 동작하는 발행-구독 기반의  
    메시징 프로토콜로 최근 IoT 환경에서 자주 사용되고 있는 프로토콜은?   
    ① MLFQ   
    ② MQTT   
    ③ Zigbee   
    ④ MTSP   

2.  **애자일(Agile) 소프트웨어 개발 방법론**에 대한 설명으로 틀린 것은?   
    ① 공정과 도구보다 개인과의 상호작용을 더 가치 있게 여긴다.   
    ② 동작하는 소프트웨어보다는 포괄적인 문서를 가치 있게 여긴다.   
    ③ 계약 협상보다는 고객과의 협력을 가치 있게 여긴다.   
    ④ 계획을 따르기보다는 변화에 대응하기를 가치 있게 여긴다.   

3.  자료 흐름도(DFD)의 구성 요소 중 자료 저장소(Data Store)를 의미하는 기호 형태는?   
    ① 화살표   
    ② 직선(Process)   
    ③ 평행선   
    ④ 오각형   

4.  HIPO(Hierarchy Input Process Output)에 대한 설명으로 거리가 먼 것은?   
    ① 상향식 소프트웨어 개발을 위한 문서화 도구이다.   
    ② HIPO 차트 종류에는 가시적 도표, 총체적 도표, 세부적 도표가 있다.   
    ③ 기능과 자료의 의존 관계를 표현할 수 있다.   
    ④ 보기 쉽고 이해하기 쉽다.   

5.  다음 중 **상태 다이어그램**에서 상태 전이(transition)의 요인이 되는 요소는?   
    ① event   
    ② state   
    ③ transition   
    ④ data   

6.  UML 모델에서 **스테레오 타입**을 표현할 때 사용되는 기호 모양은?   
    ① < >   
    ② << >>   
    ③ { }   
    ④ [ ]   

7.  객체를 생성하기 위한 인터페이스를 정의하며 어떤 클래스가 인스턴스화 될 것인지는 서브클래스가 결정하도록 하는 것과 관련된 디자인 패턴은?   
    ① Visitor 패턴   
    ② Observer 패턴   
    ③ Factory Method 패턴   
    ④ Bridge 패턴   

8.  **프로토타이핑 모델**에 대한 설명으로 옳지 않은 것은?   
    ① 설계 단계 소프트웨어에 대한 완벽한 원본(Prototype)을 만들어 최종 결과물을 예측하는 모델이다.   
    ② 의뢰자나 개발자 모두에게 공동의 참조 모델을 제공한다.   
    ③ 프로토타이핑이 진행되는 과정에서 새로운 요구사항이 도출되지 않아야 한다.   
    ④ 단기간 제작 목적으로 이하여 비용적인 언어나 알고리즘을 사용할 수 있다.   

9.  사용자 요구사항을 도출하기 위한 기법이 아닌 것은?   
    ① 사용자 인터뷰   
    ② 설문 조사   
    ③ 사용자 추적   
    ④ 래피드 프로토타이핑   

10. 다음 중 **클래스 다이어그램**에 대한 설명으로 틀린 것은?   
    ① 객체 간의 정적인 관계를 모델링하기 위해 사용한다.   
    ② 시스템의 정적인 구조를 모델링하며, 시스템 내의 클래스, 속성, 연산, 관계 등을 표현한다.   
    ③ 기능적 모델링의 일부로, 시스템의 동적인 행위를 표현하는 데 사용된다.   
    ④ 추상화된 클래스는 이탤릭체로 표시한다.   

11. UML 다이어그램 중 **활동 다이어그램**에 대한 설명으로 옳은 것은?   
    ① 시스템이나 객체들이 메시지를 주고받으며 시간의 흐름에 따라 상호작용하는 과정을 표현하는 다이어그램이다.   
    ② 하나의 객체가 자신 소유의 클래스에 속한 메소드를 수행할 때 자신에게 메시지를 전송하는 경우를 표현하는 다이어그램이다.   
    ③ 어떤 시점부터 다른 시점으로 상태가 전이되는 과정을 표현하는 다이어그램이다.   
    ④ 오퍼레이션이나 처리 과정 수행 등 활동의 흐름을 표현하는 다이어그램이다.   

12. Mockup에 대한 설명으로 옳지 않은 것은?   
    ① 스토리보드: 와이어프레임에 콘텐츠에 대한 상세 페이지 간 이동 흐름 등을 추가한 것이다.   
    ② 프로토타입: 와이어프레임이나 스토리보드 등에 인터렉션을 적용함으로써 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형이다.   
    ③ 유스케이스: 사용자가 측면에서의 요구사항이다.   
    ④ 사용자는 측면에서의 요구사항이 아닌 시스템을 사용하는 행위이다.   

13. 다음 ( ) 안에 들어갈 내용으로 옳은 것은?   
    객체지향 설계 시 ‘( )’에 의한 설계를 했을 경우, 해당 명세서에는 클래스의 오퍼레이션 수행 전/후에 반드시 만족해야 할 선/후 조건, 오퍼레이션 수행 중 항상 만족해야 할 불변 조건 등이 포함된다.   
    ① 계약(Contract)   
    ② 프로토콜(Protocol)   
    ③ 패턴(Pattern)   
    ④ 관계(Relation)   

14. 소프트웨어 아키텍처 모델 중 **MVC(Model-View-Controller)**와 관련한 설명으로 틀린 것은?   
    ① MVC 모델은 사용자 인터페이스를 담당하는 계층의 응집도를 높일 수 있고, 여러 개의 다른 UI를 만들어 그 사이에 접합점을 낮출 수 있다.   
    ② 모델(Model)은 뷰(View)와 제어기(Controller) 사이에서 전달될 데이터를 담고 있다.   
    ③ 뷰(View)는 모델(Model)에 있는 데이터를 사용자 인터페이스에 보이는 역할을 담당한다.   
    ④ 제어기(Controller)는 모델(Model)에 명령을 보냄으로써 모델의 상태를 변경할 수 있다.   

15. 다음 중 **객체지향의 행위**를 지시하도록 명령하는 것은?   
    ① Class   
    ② Object   
    ③ Instance   
    ④ Message   

16. **위험 관리(Risk Management)** 에 대한 설명으로 옳지 않은 것은?   
    ① 프로젝트 추진 과정에서 예상되는 각종 돌발 상황(위험)을 미리 예상하고 그에 대한 적절한 대책을 수립하는 일련의 활동을 의미한다.   
    ② 위험은 불확실성과 손실을 내재하고 있는데, 위험 관리는 이러한 위험의 불확실성을 감소시키고 손실에 대비하는 작업이다.   
    ③ 위험의 원천을 파악하고, 위험 분석을 수행하며, 위험 우선순위를 정하는 일련의 활동이다.   
    ④ 위험 관리의 절차는 위험 식별, 위험 분석 및 평가, 위험 관리 계획, 위험 감시 및 조치 순이다.   

17. **CASE(Computer-Aided Software Engineering)** 의 장점이 아닌 것은?   
    ① 자동화된 개발을 통해 소프트웨어 품질이 향상된다.   
    ② 소프트웨어의 유지보수를 간편하게 수행할 수 있다.   
    ③ 소프트웨어 생산성이 향상된다.   
    ④ 소프트웨어 모델의 재사용성이 줄어든다.   

18. **CRC(Class, Responsibility, Collaboration) 카드** 기법에 대한 설명으로 옳지 않은 것은?   
    ① 책임(Responsibility): 클래스가 해야 할 일을 정의한다.   
    ② 협력(Collaboration): 책임을 수행하기 위해 다른 클래스와 상호작용하는 것을 정의한다.   
    ③ 클래스(Class): CRC 카드 상단의 클래스 이름을 정의한다.   
    ④ 역할(Role): 객체가 시스템에서 수행하는 역할을 정의한다.   

19. **객체지향 설계 원칙** 중 **단일 책임 원칙(Single Responsibility Principle)** 에 대한 설명으로 옳은 것은?   
    ① 클래스는 하나 이상의 책임을 가져야 한다는 원칙이다.   
    ② 확장에 대해서는 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다는 원칙이다.   
    ③ 클라이언트가 어떤 클래스의 메소드를 사용하더라도, 그 클래스의 하위 클래스에서 해당 메소드를 오버라이드 했을 때 문제가 없어야 한다는 원칙이다.   
    ④ 자신이 사용하지 않는 인터페이스와 의존 관계를 맺지 않아야 한다는 원칙이다.   

20. **객체지향 기법**에서 클래스들 사이의 **‘부분-전체(Part-Whole)’ 관계** 또는 **‘is-a-part-of’ 관계**를 나타내는 용어는?   
    ① 일반화   
    ② 추상화   
    ③ 집합   
    ④ 의존   

---

### 과목 2: 소프트웨어 개발  

21. **소프트웨어 개발 방법론** 중 **애자일(Agile) 방법론**에 대한 설명으로 가장 옳지 않은 것은?   
    ① 빠른 반복 개발과 점진적 릴리즈를 통해 고객 요구 변화에 유연하게 대응할 수 있다.   
    ② 불확실성이 높은 프로젝트에 적합하다.   
    ③ 계획보다는 개인과 상호작용을 중요하게 생각한다.   
    ④ 문서 중심의 개발을 통해 체계적인 관리가 용이하다.   

22. **익스트림 프로그래밍(eXtreme Programming, XP)** 의 5가지 가치로 거리가 먼 것은?   
    ① 용기   
    ② 의사소통   
    ③ 존경   
    ④ 피드백   

23. 다음 중 익스트림 프로그래밍(XP)의 기본 원리로 거리가 먼 것은?   
    ① XP는 빠른 개발을 위해 단순함을 지향한다.   
    ② 변화에 대응하기 보다는 변화에 반응하는 것에 더 가치를 둔다.   
    ③ 릴리즈 기간을 짧게 반복하면서 고객의 요구사항 반영에 대한 가시성을 높인다.   
    ④ 테스트 케이스는 개발 단계 후반에 작성한다.   

24. 다음 중 **익스트림 프로그래밍(eXtreme Programming, XP)** 의 실천 방법(Practices)으로 거리가 먼 것은?   
    ① 짝 프로그래밍(Pair Programming): 한 컴퓨터에서 두 명의 프로그래머가 함께 코딩하는 방식이다.   
    ② 코드 표준(Coding Standard): 팀원들이 공통적으로 따르는 코딩 규칙이다.   
    ③ 소규모 릴리즈(Small Releases): 짧은 주기로 작동하는 소프트웨어를 릴리즈하는 방식이다.   
    ④ 통합 테스트(Integration Test): 시스템 전체의 통합 테스트를 수행하는 방식이다.   

25. **애자일(Agile) 방법론** 중 **스크럼(Scrum)** 에 대한 설명으로 틀린 것은?   
    ① 스크럼 팀은 제품 책임자(Product Owner), 스크럼 마스터(Scrum Master), 개발팀(Development Team)으로 구성된다.   
    ② 스크럼은 계획, 스프린트, 스크럼 미팅으로 구성된다.   
    ③ 스크럼 마스터는 팀원들의 일일 스크럼 미팅을 진행하며 방해 요소를 제거한다.   
    ④ 스프린트 회고는 스프린트 목표를 달성했는지 확인하는 데 초점을 둔다.   

26. **통합 테스트(Integration Test)** 와 관련한 설명으로 틀린 것은?   
    ① 시스템을 구성하는 모듈의 인터페이스와 결함을 테스트하는 것이다.   
    ② 하향식 통합 테스트의 경우 우선(Breadth First) 방식으로 테스트를 한 모듈을 선택할 수 있다.   
    ③ 하향식 통합 테스트의 경우 시스템 구조상의 최상위에 있는 모듈을 먼저 구현하고 테스트한다.   
    ④ 모듈 간의 인터페이스 오류와 시스템의 동작이 정상적으로 처리되고 있는지를 빨리 파악하고자 할 때 상향식보다는 하향식 통합 테스트를 사용하는 것이 좋다.   

27. 다음 중 **화이트박스 테스트** 기법에 해당하는 것으로만 짝지어진 것은?   
    가. 루프 테스트 나. 동등 분할 검사 다. 경계값 분석 라. 구문 검사   
    ① 가, 나   
    ② 가, 라   
    ③ 나, 다   
    ④ 다, 라   

28. **블랙박스 테스트** 의 특징으로 옳지 않은 것은?   
    ① 기능 검사, 오류 검사, 예상 결과 검사 등을 수행한다.   
    ② 프로그램 내부 구조는 고려하지 않는다.   
    ③ 사용자의 관점에서 테스트한다.   
    ④ 입력값 범위의 중간값을 사용하여 테스트 케이스를 선정한다.   

29. 소프트웨어 테스트의 분류 중 **블랙박스 테스트** 에 해당하는 기법으로 묶은 것은?   
    가. 동치 분할 검사 나. 경계값 분석 다. 경로 검사 라. 조건 검사   
    ① 가, 나   
    ② 가, 라   
    ③ 나, 다   
    ④ 다, 라   

30. 소프트웨어 테스트 기법 중 **블랙박스 테스트** 기법에 해당하는 것으로만 묶은 것은?   
    가. 동치 분할 검사 나. 원인 결과 그래프 기법 다. 구문 기반 검사 라. 오류 예측 기법   
    ① 가, 나, 다   
    ② 가, 나, 라   
    ③ 가, 다, 라   
    ④ 나, 다, 라   

31. **테스트 자동화 도구** 에 대한 설명으로 옳지 않은 것은?   
    ① STAF: Ruby를 사용하는 애플리케이션 테스트 프레임워크이다.   
    ② xUnit: xUnit, JUnit 등 다양한 언어를 지원하는 단위 테스트 자동화 프레임워크이다.   
    ③ FiTNeSSe: 웹 기반 테스트 케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크이다.   
    ④ NTAF: Naver의 테스트 자동화 프레임워크이다.   

32. 다음 중 **인터페이스 구현 검증 도구** 에 대한 설명으로 옳지 않은 것은?   
    ① STAF: Ruby를 사용하는 애플리케이션 테스트 프레임워크이다.   
    ② xUnit: xUnit, JUnit 등 다양한 언어를 지원하는 단위 테스트 프레임워크이다.   
    ③ FiTNeSSe: 웹 기반 테스트 케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크이다.   
    ④ NTAF: Naver의 테스트 자동화 프레임워크이다.   

33. **인터페이스 구현 검증 도구** 에 대한 설명으로 옳지 않은 것은?   
    ① Foxbase   
    ② STAF   
    ③ xUnit   
    ④ watir   

34. 소프트웨어 테스트 중 **검증(Verification)** 과 **확인(Validation)** 에 대한 설명으로 틀린 것은?   
    ① 검증은 개발자의 입장에서 개발된 소프트웨어가 명세서에 맞게 만들어졌는지를 검증하는 활동이다.   
    ② 확인은 사용자의 입장에서 개발된 소프트웨어가 사용자의 요구사항을 만족하는지를 검증하는 활동이다.   
    ③ 검증은 제품의 사양이나 표준을 준수했는지 확인하는 것이다.   
    ④ 확인은 개발자가 요구사항 명세서를 정확하게 이해했는지 확인하는 것이다.   

35. **클린 코드(Clean Code)** 작성 원칙으로 거리가 먼 것은?   
    ① 가독성을 높여 이해하기 쉬운 코드를 작성한다.   
    ② 모든 모듈은 다른 모듈에 미치는 영향을 최소화한다.   
    ③ 중복 코드를 최소화한다.   
    ④ 함수나 클래스는 최대한 작게 만든다.   

36. **클린 코드(Clean Code)** 작성 원칙에 대한 설명으로 틀린 것은?   
    ① 의존성 제거: 클린 코드는 다른 코드에 미치는 영향이 최소화된다.   
    ② 가독성: 코드를 읽고 이해하기 쉽도록 작성한다.   
    ③ 단순성: 코드의 중복을 최소화한다.   
    ④ 응집도: 관련된 코드는 함께 모아둔다.   

37. 소프트웨어 품질 목표 중 **사용성(Usability)** 에 대한 설명으로 옳은 것은?   
    ① 요구되는 기능을 달성하기 위해 주어진 시간 동안 자원(CPU, 메모리 등)을 얼마나 효율적으로 사용할 수 있는지 정도를 나타낸다.   
    ② 사용자가 이해하기 쉽도록 만들어져 사용에 어려움이 없는 정도를 나타낸다.   
    ③ 소프트웨어 오류 발생 시 그 오류가 수정될 수 있는 정도를 나타낸다.   
    ④ 소프트웨어가 요구되는 기능을 정확하게 수행하는 정도를 나타낸다.   

38. 소프트웨어 **Walkthrough** 에 대한 설명으로 틀린 것은?   
    ① 사용 사례를 확장하여 명세하거나 설계 다이어그램, 원시 코드, 테스트 케이스 등에 적용할 수 있다.   
    ② 복잡한 알고리즘 또는 반복, 실시간 동작, 병렬 처리와 같은 기능을 이해하고 파악할 때 유용하다.   
    ③ 인스펙션(Inspection)과 동일한 의미를 가진다.   
    ④ 단순히 테스트 케이스를 이용하여 프로젝트를 수작업으로 수행해 보는 것이다.   

39. 소프트웨어 **인스펙션(Inspection)** 에 대한 설명으로 틀린 것은?   
    ① 코드의 오류 발견을 위해 수행한다.   
    ② 코드 품질 향상에 기여한다.   
    ③ 동적 테스트 기법이다.   
    ④ 결과와 함께 코딩 표준 준수 여부, 효율성 등의 다른 품질 이슈를 검토한다.   

40. ISO/IEC 9126의 **소프트웨어 품질 특성** 중 **기능성(Functionality)** 의 하위 특성으로 옳지 않은 것은?   
    ① 학습성   
    ② 정확성   
    ③ 상호 운용성   
    ④ 보안성   

---

### 과목 3: 데이터베이스 구축  

41. **CREATE TABLE문**에 포함되지 않는 기능은?   
    ① 속성 타입 변경   
    ② 속성의 NOT NULL 여부 지정   
    ③ 기본키를 구성하는 속성 지정   
    ④ CHECK 제약조건의 정의   

42. **뷰(View)** 에 대한 설명으로 틀린 것은?   
    ① 사용자는 뷰를 통해 기본 테이블의 데이터에 접근할 수 있다.   
    ② 뷰 위에 또 다른 뷰를 정의할 수 있다.   
    ③ 뷰를 통한 삽입, 삭제, 갱신 연산은 제약이 따른다.   
    ④ 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 뷰도 자동으로 제거되지 않는다.   

43. 다음 중 **정규화 과정**에서 제1정규형을 제2정규형으로 만들 때 제거하는 것은?   
    ① 부분 함수 종속   
    ② 이행 함수 종속   
    ③ 결정자이면서 후보키가 아닌 속성에 종속되는 관계   
    ④ 다치 종속   

44. **정규화 과정**에서 2NF가 되기 위한 조건은?   
    ① 1NF를 만족하고, 모든 도메인이 원자값이어야 한다.   
    ② 1NF를 만족하고, 기본키가 아닌 모든 애트리뷰트들이 기본키에 이행적으로 함수 종속되지 않아야 한다.   
    ③ 1NF를 만족하고 다치 종속이 제거되어야 한다.   
    ④ 1NF를 만족하고 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속 관계를 만족해야 한다.   

45. **데이터 무결성 제약 조건** 중 **‘참조 무결성’** 에 대한 설명으로 옳은 것은?   
    ① 릴레이션의 모든 튜플의 속성의 도메인에 지정된 값만 가질 수 있다.   
    ② 기본키에 속하는 애트리뷰트는 널 값이나 중복 값을 가질 수 없다.   
    ③ 외래키는 참조할 수 없는 외래키 값을 가질 수 없다.   
    ④ 외래키 값은 참조 릴레이션의 기본키 값과 동일해야 한다.   

46. **데이터베이스 시스템** 에 대한 설명으로 틀린 것은?   
    ① 데이터베이스는 논리적인 시스템이나 물리적인 시스템 어디에도 존재할 수 있다.   
    ② 위치 투명성, 중복 투명성, 병행 투명성, 장애 투명성을 목표로 한다.   
    ③ 데이터베이스 시스템의 장점은 비교적 어렵고, 개발 비용과 처리 비용이 증가한다.   
    ④ 데이터베이스 시스템의 주요 구성 요소는 분산 처리기, P2P 시스템, 단일 데이터베이스 등이다.   

47. **분산 데이터베이스 시스템** 의 주요 구성 요소에 대한 설명으로 틀린 것은?   
    ① 분산 처리기: 분산된 시스템에서 데이터베이스를 처리하는 프로세스   
    ② 분산 데이터: 분산되어 있는 데이터   
    ③ 통신 네트워크: 분산 시스템 간의 통신을 위한 네트워크   
    ④ P2P 시스템: 분산된 시스템에서 중앙 제어 없이 데이터베이스를 관리하는 시스템   

48. 데이터베이스 시스템 구축과 관련된 설명으로 틀린 것은?   
    ① 데이터베이스 시스템 구축은 데이터베이스 설계와 소프트웨어 개발로 이루어진다.   
    ② 분산 데이터베이스는 데이터베이스 설계 및 소프트웨어 개발이 어렵다.   
    ③ 위치 투명성, 중복 투명성, 병행 투명성, 장애 투명성은 분산 데이터베이스 시스템의 목표이다.   
    ④ 새로운 지역 서버를 추가하거나 장비를 수용하는 등의 작업이 용이하다.   

49. **시스템 카탈로그** 의 갱신은 무결성 유지를 위하여 SQL을 이용하여 사용자가 직접 갱신하여야 한다는 설명이 틀린 이유는?   
    ① 시스템 카탈로그는 시스템 테이블이다.   
    ② 시스템 카탈로그는 DBMS가 스스로 생성하고 유지한다.   
    ③ 시스템 카탈로그는 데이터베이스 내의 특별한 테이블의 집합체이다.   
    ④ 시스템 카탈로그에 저장된 정보를 메타 데이터라고도 한다.   

50. **관계 대수** 에 대한 설명으로 옳지 않은 것은?   
    ① 관계 대수는 원래 수학의 **프레디컷 해석** 에 기반을 두고 있는 관계해석과 동일한 의미를 가진다.   
    ② 관계 대수는 절차적인 언어로서 원하는 정보를 어떻게 얻을 것인지 절차를 명세한다.   
    ③ 관계 대수는 **피연산자가 릴레이션** 이고 결과도 릴레이션이다.   
    ④ 관계 대수의 연산에는 SELECT, PROJECT, JOIN, DIVISION, UNION, INTERSECT, DIFFERENCE 등이 있다.   

51. **관계 해석** 에 대한 설명으로 옳지 않은 것은?   
    ① 관계 해석은 원래 수학의 프레디컷 해석에 기반을 두고 있는 관계 대수와 동일한 의미를 가진다.   
    ② 관계 해석은 비절차적인 언어로서 원하는 정보가 무엇인지만 명세한다.   
    ③ 관계 해석은 튜플 관계 해석과 도메인 관계 해석으로 나뉜다.   
    ④ 관계 해석은 연산자의 개념이 없다.   

52. 데이터베이스에서 **트랜잭션** 의 특징 중 **원자성(Atomicity)** 에 대한 설명은?   
    ① 트랜잭션의 연산은 데이터베이스에 모두 반영되든 아니면 전혀 반영되지 않아야 한다는 성질을 의미한다.   
    ② 하나의 트랜잭션이 완료되기 전까지는 해당 트랜잭션이 데이터베이스에 영구적으로 반영되지 않아야 한다는 성질을 의미한다.   
    ③ 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변화한다.   
    ④ 시스템 오류나 장애 발생 시에도 트랜잭션은 성공적으로 완료된 상태를 유지해야 한다는 성질을 의미한다.   

53. 데이터베이스에서 **트랜잭션** 의 특징 중 **일관성(Consistency)** 에 대한 설명은?   
    ① 트랜잭션의 연산은 데이터베이스에 모두 반영되든 아니면 전혀 반영되지 않아야 한다는 성질을 의미한다.   
    ② 하나의 트랜잭션이 완료되기 전까지는 해당 트랜잭션이 데이터베이스에 영구적으로 반영되지 않아야 한다는 성질을 의미한다.   
    ③ 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변화한다.   
    ④ 시스템 오류나 장애 발생 시에도 트랜잭션은 성공적으로 완료된 상태를 유지해야 한다는 성질을 의미한다.   

54. 데이터베이스에서 **트랜잭션** 의 특징 중 **고립성(Isolation)** 에 대한 설명은?   
    ① 트랜잭션의 연산은 데이터베이스에 모두 반영되든 아니면 전혀 반영되지 않아야 한다는 성질을 의미한다.   
    ② 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않고 독립적으로 수행되는 것처럼 보이는 성질을 의미한다.   
    ③ 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변화한다.   
    ④ 시스템 오류나 장애 발생 시에도 트랜잭션은 성공적으로 완료된 상태를 유지해야 한다는 성질을 의미한다.   

55. 데이터베이스에서 **트랜잭션** 의 특징 중 **지속성(Durability)** 에 대한 설명은?   
    ① 트랜잭션의 연산은 데이터베이스에 모두 반영되든 아니면 전혀 반영되지 않아야 한다는 성질을 의미한다.   
    ② 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않고 독립적으로 수행되는 것처럼 보이는 성질을 의미한다.   
    ③ 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변화한다.   
    ④ 시스템 오류나 장애 발생 시에도 트랜잭션은 성공적으로 완료된 상태를 유지해야 한다는 성질을 의미한다.   

56. 데이터베이스의 **정규형** 에 대한 설명으로 옳지 않은 것은?   
    ① 정규형에는 1NF, 2NF, 3NF, BCNF, 4NF, 5NF 등이 있다.   
    ② 릴레이션에 속한 모든 도메인이 원자값으로 되어 있어야 한다.   
    ③ 제3정규형이 되기 위해서는 제2정규형을 만족하고, 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족해야 한다.   
    ④ 결정자가 모두 후보키인 정규형은 BCNF이다.   

57. **정규화 단계** 중 **BCNF** 에 대한 설명으로 옳지 않은 것은?   
    ① 결정자가 모두 후보키인 정규형이다.   
    ② 제3정규형을 만족하면서, 모든 결정자가 후보키 집합에 속하는 정규형이다.   
    ③ 후보키가 아닌 결정자가 존재할 때 발생하는 함수 종속을 제거한다.   
    ④ BCNF는 3NF보다 더 높은 수준의 정규형이다.   

58. **개체-관계(E-R) 모델** 에 대한 설명으로 잘못된 것은?   
    ① 개체 타입을 사각형으로 표현한다.   
    ② 속성을 마름모, 관계 타입을 타원으로 표현한다.   
    ③ 개념적 데이터베이스 설계에서 사용된다.   
    ④ E-R 모델의 기본 표현 방식은 E-R 다이어그램이다.   

59. **개체-관계(E-R) 다이어그램** 표기법으로 옳지 않은 것은?   
    ① 개체 타입 - 사각형   
    ② 속성 - 원형   
    ③ 관계 타입 - 마름모   
    ④ 연결 - 선   

60. 데이터베이스에서 **LOCKING(병행 제어)** 의 로킹 단위에 대한 설명으로 옳지 않은 것은?   
    ① 데이터베이스, 파일, 레코드, 필드 등은 로킹 단위가 될 수 있다.   
    ② 로킹 단위가 작아지면 로킹 오버헤드가 증가한다.   
    ③ 로킹 단위가 작아지면 병행 수행 수준이 낮아진다.   
    ④ 로킹 단위가 크면 로크 수가 줄어들어 관리하기 용이하지만 병행 수행 수준이 낮아진다.   

---

### 과목 4: 프로그래밍 언어 활용  

61. 다음 C 언어 프로그램 실행 결과는?   
    ```c
    #include <stdio.h>
    int main() {
        int a = 4, b = 6, c = 2;
        int r1 = (a & b) | c;
        int r2 = (a ^ b) & c;
        int r3 = !c;
        printf("%d, %d, %d\n", r1, r2, r3);
        return 0;
    }
    ```   
    ① 6, 2, 0   
    ② 6, 2, 1   
    ③ 4, 0, 0   
    ④ 4, 0, 1   

62. 다음 C 언어 프로그램 실행 결과는?   
    ```c
    #include <stdio.h>
    int main() {
        int a = 4;
        int b = 7;
        int c = a | b;
        printf("%d\n", c);
        return 0;
    }
    ```   
    ① 3   
    ② 4   
    ③ 7   
    ④ 10   

63. 다음 C 언어 프로그램 실행 중 ‘c’를 입력하였을 때 출력 결과는?   
    ```c
    #include <stdio.h>
    int main() {
        char ch;
        scanf("%c", &ch);
        switch (ch) {
            case 'a': printf("one "); break;
            case 'b': printf("two "); break;
            case 'c': printf("three "); break;
            case 'd': printf("four "); break;
        }
        return 0;
    }
    ```   
    ① one   
    ② two   
    ③ three   
    ④ one two three four   

64. **IPv6** 에 대한 설명으로 틀린 것은?   
    ① 128비트의 주소 공간을 제공한다.   
    ② 연결 및 보안 기능을 포함한다.   
    ③ 패킷 크기가 64Kbyte로 고정되어 있다.   
    ④ IPv6 확장을 통해 네트워크 기능 확장이 용이하다.   

65. 다음 Python 프로그램의 실행 결과와 같을 때, 빈칸에 적합한 것은?   
    ```python
    x = 20
    if x == 10:
        print('10')
    __ (x == 20):
        print('20')
    else:
        print('other')
    ```   
    [실행 결과]   
    20   
    ① ether   
    ② elif   
    ③ else if   
    ④ else   

66. **JAVA의 변수명 작성 규칙**에 대한 설명으로 옳지 않은 것은?   
    ① 변수명의 첫 글자는 숫자를 사용할 수 없다.   
    ② 변수명의 첫 글자는 영문자, '_' 또는 '$'를 사용할 수 있다.   
    ③ 변수명 중간에 공백을 포함할 수 있다.   
    ④ 대소문자를 구분한다.   

67. 다음 C 언어 프로그램의 실행 결과는?   
    ```c
    #include <stdio.h>
    int main() {
        int r = 0;
        for (int i = 1; i <= 3; i++) {
            r += i;
        }
        printf("%d\n", r);
        return 0;
    }
    ```   
    ① 0   
    ② 2   
    ③ 3   
    ④ 6   

68. 다음 C 언어 프로그램 실행 결과는?   
    ```c
    #include <stdio.h>
    int main(void) {
        int n = 4;
        int *pt = NULL;
        int *npt = &n;
        printf("%d, %d\n", &n + 1, npt - 1);
        return 0;
    }
    ```   
    (단, int 형은 4Byte로 가정한다.)   
    ① 0, 4   
    ② 4, 8   
    ③ 8, 0   
    ④ 8, 4   

69. 다음 JAVA 프로그램이 실행되었을 때의 결과는?   
    ```java
    class DivideByZero {
        public static void div(int a, int b) {
            try {
                System.out.println(a / b);
            } catch (ArithmeticException e) {
                System.out.println("DivideByZero");
            } finally {
                System.out.println("Done");
            }
        }

        public static void main(String[] args) {
            div(5, 5);
        }
    }
    ```   
    ① 1   
    ② 1   
    DivideByZero   
    Done   
    ③ DivideByZero   
    Done   
    ④ 1   
    Done   

70. 다음 Python 프로그램의 실행 결과는?   
    ```python
    def func(n):
        sum = 0
        for i in range(n + 1):
            sum += i
        return sum

    r = func(11)
    print(r)
    ```   
    ① 0   
    ② 55   
    ③ 66   
    ④ 78   

71. 다음 C 언어에서 표준 입출력 함수를 사용하기 위해 헤더 파일로 옳바른 것은?   
    ① #include <stdio.h>   
    ② #import <stdio.h>   
    ③ #include <io.h>   
    ④ #import <io.h>   

72. 다음 JAVA 프로그램이 실행되었을 때의 결과는?   
    ```java
    class Test {
        public static void main(String[] args) {
            int[] arr = new int;
            for (int i = 0; i < arr.length; i++) {
                arr[i] = i + 1;
            }

            for (int i = 0; i < arr.length; i++) {
                System.out.print(arr[i]);
            }
        }
    }
    ```   
    ① 0123   
    ② 1234   
    ③ 012   
    ④ 123   

73. 다음 C 언어에서 출력 서식으로 사용되는 설명자 "%s"에 대한 설명으로 옳은 것은?   
    ① 정수를 출력한다.   
    ② 부동 소수점 수를 출력한다.   
    ③ 문자열을 출력한다.   
    ④ 단일 문자를 출력한다.   

74. 다음 C 언어 프로그램 실행 결과는?   
    ```c
    #include <stdio.h>
    int main(int argc, char *argv[]) {
        int arr[] = {14, 22, 30, 38};
        printf("%u, %u, %u\n", &arr, &arr, &arr);
        return 0;
    }
    ```   
    (단, int 형은 4Byte로 가정한다.)   
    ① 14, 18, 22   
    ② 14, 18, 22, 26   
    ③ 14, 18, 10   
    ④ 14, M   

75. **프로그래밍 언어별 분류** 중 **절차적 언어**에 해당하는 것은?   
    ① C   
    ② Java   
    ③ Python   
    ④ C++   

76. 다음 C 언어 프로그램 실행 결과는?   
    ```c
    #include <stdio.h>
    int main(int argc, char *argv[]) {
        int a[] = {11, 22, 44, 55};
        int i, sum = 0;
        int *p = a;
        for (i = 1; i < 4; i++) {
            sum += *(p + i);
        }
        printf("%d\n", sum);
        return 0;
    }
    ```   
    ① 88   
    ② 99   
    ③ 100   
    ④ 121   

77. 다음 Python 코드를 실행한 결과는?   
    ```python
    a =
    >>> a[2:7]
    ```   
    ①   
    ②   
    ③   
    ④   

78. 다음 Python 코드를 실행한 결과는?   
    ```python
    def cal(n):
        s = 0
        for r in range(n+1):
            s += r
        return s

    print(cal(11))
    ```   
    ① 45   
    ② 55   
    ③ 66   
    ④ 78   

79. 다음 Python 코드를 실행한 결과는?   
    ```python
    a, b = map(int, input().split(','))
    print(a, b)
    ```   
    53, 44를 입력했을 때   
    ① 53 44   
    ② 53, 44   
    ③ 53   
    44   
    ④ 53   
    ,   
    44   

80. 다음 C 언어 프로그램 실행 결과는?   
    ```c
    #include <stdio.h>
    int main(void) {
        int n = 4;
        int *pt = NULL;
        int *npt = &n;
        printf("%d, %d\n", &n + 1, npt - 1);
        return 0;
    }
    ```   
    (단, int 형은 4Byte로 가정한다.)   
    ① 14, 18   
    ② 14, M   
    ③ 18, 10   
    ④ 18, M   

---

### 과목 5: 정보시스템 구축 관리  

81. **정보 시스템 구축 관리**의 목표로 가장 거리가 먼 것은?   
    ① **정보시스템** 구축의 목표는 자원(데이터, 프로세스 등)의 공유이다.   
    ② **정보시스템** 구축은 구축 절차와 방법론에 대한 이해를 바탕으로 한다.   
    ③ **정보시스템** 구축은 프로젝트 관리 지식 체계를 활용하여 수행한다.   
    ④ **정보시스템** 구축은 새로운 시스템 구축을 통해 기존 시스템의 문제점을 개선하는 것이다.   

82. **정보 시스템 구축 관리** 단계 중 **구현 단계** 에서 주로 수행하는 활동은?   
    ① 시스템 요구사항 정의   
    ② 시스템 설계 및 구조화   
    ③ 프로그램 코딩 및 테스트   
    ④ 시스템 운영 및 유지보수   

83. 정보 시스템 구축 관점에서 **소프트웨어 생명 주기(SDLC)** 에 대한 설명으로 옳지 않은 것은?   
    ① **SDLC**는 시스템 개발을 위한 체계적인 절차를 제공한다.   
    ② **SDLC**는 개발 과정을 단계별로 나누어 관리한다.   
    ③ **SDLC** 모델은 프로젝트의 성격과 특성에 따라 선택된다.   
    ④ **SDLC** 모델은 개발 중의 변경 사항에 유연하게 대처하기 어렵다.   

84. 정보 시스템 구축 관리 단계 중 **요구사항 분석 단계** 에서 주로 수행하는 활동은?   
    ① 요구사항 수집 및 식별   
    ② 요구사항 구조화   
    ③ 요구사항 명세   
    ④ 시스템 테스트 계획 수립   

85. 정보 시스템 구축 관리 단계 중 **설계 단계** 에서 주로 수행하는 활동은?   
    ① 시스템 구조 설계   
    ② 데이터베이스 설계   
    ③ 인터페이스 설계   
    ④ 요구사항 검토 및 승인   

86. 정보 시스템 구축 관리 단계 중 **테스트 단계** 에서 주로 수행하는 활동은?   
    ① 단위 테스트 수행   
    ② 통합 테스트 수행   
    ③ 시스템 테스트 수행   
    ④ 사용자 요구사항 정의   

87. 정보 시스템 구축 관리 단계 중 **유지보수 단계** 에서 주로 수행하는 활동은?   
    ① 시스템 변경 요구사항 관리   
    ② 시스템 성능 개선   
    ③ 시스템 보안 강화   
    ④ 시스템 구축 계획 수립   

88. 다음은 **소프트웨어 개발 방법론** 중 하나인 **폭포수 모델(Waterfall Model)** 에 대한 설명이다.   
    각 단계를 명확하게 구분하며, 이전 단계가 완료되어야 다음 단계로 진행되는 선형적인 순차 모델   
    ① Spiral Model   
    ② Prototype Model   
    ③ Waterfall Model   
    ④ Agile Model   

89. 다음은 소프트웨어 개발 방법론 중 하나인 **나선형 모델(Spiral Model)** 에 대한 설명이다.   
    점진적 개발과 반복적 개발의 장점을 결합한 모델로, 위험 분석을 중요시한다.   
    ① Spiral Model   
    ② Prototype Model   
    ③ Waterfall Model   
    ④ Agile Model   

90. 다음은 소프트웨어 개발 방법론 중 하나인 **프로토타이핑 모델(Prototyping Model)** 에 대한 설명이다.   
    사용자의 요구사항을 정확하게 파악하기 위해 실제 동작하는 원형(Prototype)을 만들어 최종 결과물을 예측하는 모델   
    ① Spiral Model   
    ② Prototype Model   
    ③ Waterfall Model   
    ④ Agile Model   

91. 다음 중 **데이터 모델링** 에 대한 설명으로 틀린 것은?   
    ① 데이터 모델링은 데이터베이스 설계의 핵심 과정이다.   
    ② 데이터 모델링은 현실 세계의 데이터를 추상화하여 표현하는 과정이다.   
    ③ 데이터 모델링은 개념적, 논리적, 물리적 설계 단계로 진행된다.   
    ④ 데이터 모델링은 시스템 구축 완료 후 운영 단계에서만 수행된다.   

92. 다음 중 **개념적 데이터 모델링** 에 대한 설명으로 틀린 것은?   
    ① 현실 세계의 데이터를 사용자의 관점에서 추상화하여 표현한다.   
    ② E-R 다이어그램 등을 사용하여 표현한다.   
    ③ 특정 DBMS를 고려하지 않고 독립적으로 수행한다.   
    ④ 데이터 저장 구조 및 접근 방법을 구체화한다.   

93. 다음 중 **논리적 데이터 모델링** 에 대한 설명으로 틀린 것은?   
    ① 개념적 모델링에서 정의된 데이터를 특정 DBMS의 논리적 구조로 변환한다.   
    ② 데이터 모델링 도구(CASE)를 사용하여 수행할 수 있다.   
    ③ 데이터 저장 공간 할당, 접근 방법 등을 결정한다.   
    ④ 정규화 과정을 수행하여 데이터 모델의 무결성을 높인다.   

94. 다음 중 **물리적 데이터 모델링** 에 대한 설명으로 틀린 것은?   
    ① 논리적 모델링에서 정의된 논리적 구조를 특정 하드웨어와 DBMS 환경에 맞게 변환한다.   
    ② 인덱스, 뷰, 파티션 등을 고려하여 성능을 최적화한다.   
    ③ 데이터 저장 구조, 접근 경로, 응답 시간 등을 고려하여 설계한다.   
    ④ 특정 DBMS와 하드웨어 환경에 독립적으로 수행한다.   

95. **네트워크 관리 기술** 중 **SDN(Software Defined Networking)** 에 대한 설명으로 옳지 않은 것은?   
    ① 네트워크를 제어부와 데이터 전달부로 분리하여 네트워크 관리를 중앙 집중화하고 효율적으로 운영하는 기술이다.   
    ② 기존 네트워크 장비의 펌웨어 업그레이드를 통해 사용자의 직접적인 데이터 전송 경로 관리가 가능하다.   
    ③ 기존 네트워크에는 영향을 주지 않으면서 특정 서비스의 전송 경로 수정을 통해 유연한 네트워크 운영이 가능하다.   
    ④ 데이터 센터 관리, 서비스 공급자 환경 등에 적용할 수 있다.   

96. 다음 중 **데이터 저장 기술** 에 대한 설명으로 옳지 않은 것은?   
    ① DAS(Direct Attached Storage): 서버와 저장장치를 케이블로 직접 연결하는 방식   
    ② NAS(Network Attached Storage): 네트워크를 통해 여러 사용자가 파일 데이터를 공유하는 방식   
    ③ SAN(Storage Area Network): 서버와 스토리지 장치들을 네트워크로 연결하여 서버가 스토리지에 블록 단위로 접근하는 방식   
    ④ CDN(Content Delivery Network): 콘텐츠를 사용자에게 빠르게 전송하기 위한 분산 서버 네트워크   

97. **정보 보안** 의 3요소에 해당하지 않는 것은?   
    ① 기밀성   
    ② 가용성   
    ③ 무결성   
    ④ 편리성   

98. **정보 시스템 내의 정보 자원** 에 대한 **인증(Authentication)** 과 관련한 설명으로 옳지 않은 것은?   
    ① 신원의 유효성을 시스템에 증명하는 과정이다.   
    ② 접근 주체가 누구인지 확인하는 과정이다.   
    ③ 아이디/패스워드를 입력하는 것이 가장 일반적인 인증 방법이다.   
    ④ 접근 권한이 있는지를 확인하는 과정이다.   

99. **인증(Authentication)** 에서 사용되는 요소와 관련이 먼 것은?   
    ① Something You Know (지식): 패스워드, PIN 등   
    ② Something You Have (소유): 신분증, OTP, 스마트카드 등   
    ③ Something You Are (속성): 지문, 홍채 등   
    ④ Something You See (시각): 비전(Vision) 정보를 활용하는 것   

100. **정보 보안** 의 3요소 중 **기밀성(Confidentiality)** 에 대한 설명으로 옳은 것은?   
    ① 인가되지 않은 사용자에게 정보가 노출되지 않도록 보호하는 것이다.   
    ② 인가된 사용자만 정보에 접근하고 수정할 수 있도록 하는 것이다.   
    ③ 정보가 전송되거나 저장될 때 의도적으로 변경되지 않았음을 보장하는 것이다.   
    ④ 인가된 사용자에게 서비스를 중단 없이 제공하는 것이다.   

---

### 답 및 해설  

**과목 1**  
1.  답: ②   
    해설: MQTT는 TCP/IP 기반의 발행-구독 메시징 프로토콜로, 저전력 및 제한된 대역폭 환경에 최적화되어 IoT 분야에서 널리 사용된다.   
2.  답: ②   
    해설: 애자일 방법론은 동작하는 소프트웨어를 포괄적인 문서보다 가치 있게 여긴다.   
3.  답: ③   
    해설: 자료 흐름도(DFD)에서 자료 저장소(Data Store)는 평행선으로 표현된다.   
4.  답: ③   
    해설: HIPO 차트는 시스템의 기능과 그 기능을 수행하기 위해 입력될 자료, 처리될 내용, 출력될 자료를 계층적으로 표현하지만, 기능과 자료 간의 의존 관계는 표현하지 않는다.   
5.  답: ①   
    해설: 상태 다이어그램에서 상태 전이(transition)는 특정 상태(state)에서 이벤트(event)가 발생했을 때 다른 상태로 변화하는 것을 의미한다.   
6.  답: ②   
    해설: UML 모델에서 스테레오 타입은 << >> 기호 안에 이름을 넣어 표현한다.   
7.  답: ③   
    해설: Factory Method 패턴은 객체 생성을 위한 인터페이스를 정의하지만, 실제 인스턴스 생성은 서브클래스가 결정하도록 위임하는 패턴이다.   
8.  답: ③   
    해설: 프로토타이핑 모델은 개발 과정에서 사용자의 요구사항 변화에 유연하게 대응할 수 있도록 반복적으로 개발하는 것이 목표이므로, 요구사항 변화를 제한하지 않는다. 오히려 프로토타이핑을 통해 숨겨진 요구사항을 발견할 수 있다.   
9.  답: ③   
    해설: 사용자 추적(User Tracking)은 시스템 사용자의 행위를 추적하여 분석하는 기법으로 요구사항 도출보다는 시스템 분석이나 평가 단계에서 활용될 수 있다.   
10. 답: ③   
    해설: 클래스 다이어그램은 시스템의 정적인 구조와 클래스 간의 관계를 표현하는 데 사용되는 정적 모델링 도구이다. 동적인 행위는 활동 다이어그램이나 상태 다이어그램 등으로 표현한다.   
11. 답: ④   
    해설: 활동 다이어그램은 시스템 내에서 수행되는 활동이나 오퍼레이션 등의 흐름을 표현하는 다이어그램이다.   
12. 답: ④   
    해설: 유스케이스는 시스템이 사용자에게 제공해야 하는 기능 또는 서비스에 대한 요구사항으로, 사용자의 목표 달성 과정을 시나리오 형태로 표현한 것이다. 사용자의 행위 그 자체를 의미하지는 않는다.   
13. 답: ①   
    해설: 디자인 바이 컨트랙트(Design by Contract)에서 계약은 클래스의 오퍼레이션 수행 전/후 조건 및 불변 조건 등을 명세하여 객체 간의 신뢰를 보장한다.   
14. 답: ②   
    해설: MVC 모델에서 모델(Model)은 애플리케이션의 정보(데이터)와 비즈니스 로직을 담당한다. 뷰와 컨트롤러는 모델을 통해 데이터를 가져오거나 업데이트한다.   
15. 답: ④   
    해설: 객체지향 프로그래밍에서 객체 간의 상호작용은 메시지 전송(Message)을 통해 이루어진다.   
16. 답: ③   
    해설: 위험 관리 프로세스는 위험 식별, 위험 분석 및 평가, 위험 관리 계획, 위험 감시 및 조치 순으로 진행된다. 위험 우선순위는 위험 분석 및 평가 단계에서 결정된다.   
17. 답: ④   
    해설: CASE 도구는 소프트웨어 개발 과정의 자동화를 통해 소프트웨어의 생산성과 품질을 높이고, 재사용성을 증대시키는 장점이 있다.   
18. 답: ④   
    해설: CRC 카드에서 역할(Role)은 협력(Collaboration)과 관련된 개념으로, 특정 책임을 수행하기 위해 어떤 다른 클래스와 협력하는지를 정의하는 것이다. 클래스 자체의 역할은 아니다.   
19. 답: ①   
    해설: 단일 책임 원칙(SRP)은 하나의 클래스는 하나의 책임만 가져야 한다는 원칙이다.   
20. 답: ③   
    해설: 객체지향에서 ‘부분-전체’ 또는 ‘is-a-part-of’ 관계는 집합(Aggregation) 또는 포함(Composition) 관계로 표현된다.   

**과목 2**  
21. 답: ④   
    해설: 애자일 방법론은 변화에 유연하게 대응하기 위해 문서보다는 동작하는 소프트웨어와 고객과의 소통을 중시한다. 문서 중심의 개발은 전통적인 개발 방법론의 특징이다.   
22. 답: ③   
    해설: 익스트림 프로그래밍(XP)의 5가지 핵심 가치는 의사소통(Communication), 단순성(Simplicity), 용기(Courage), 피드백(Feedback)이다. 존경(Respect)은 XP의 가치 중 하나이지만, 제시된 5가지 가치 목록에는 포함되지 않았다. (참고: 다른 소스에서는 존경(Respect)을 5가지 가치에 포함시키기도 합니다. 하지만 제시된 보기와 소스를 기준으로 판단했습니다.)   
23. 답: ④   
    해설: 익스트림 프로그래밍(XP)은 테스트를 개발 초기부터 적극적으로 활용한다. 테스트는 코딩과 병행되거나 코딩 전에 작성되기도 한다.   
24. 답: ④   
    해설: 통합 테스트는 XP의 특정 실천 방법(Practices)으로 직접 언급되기보다는, XP의 소규모 릴리즈와 지속적인 통합(Continuous Integration)의 결과로 자연스럽게 수행되는 활동이다. 제시된 짝 프로그래밍, 코드 표준, 소규모 릴리즈는 XP의 주요 실천 방법이다.   
25. 답: ④   
    해설: 스프린트 회고(Sprint Retrospective)는 스프린트 목표 달성 여부뿐만 아니라 팀의 프로세스, 도구, 관계 등을 돌아보며 개선할 부분을 식별하는 데 초점을 둔다. 스프린트 목표 달성 여부는 스프린트 검토(Sprint Review)에서 주로 논의된다.   
26. 답: ②   
    해설: 하향식 통합 테스트는 시스템 구조의 최상위 모듈부터 하위 모듈 방향으로 테스트를 진행하며, 깊이 우선(Depth First) 또는 넓이 우선(Breadth First) 방식으로 하위 모듈을 선택하여 테스트한다.   
27. 답: ②   
    해설: 화이트박스 테스트 기법은 프로그램 내부 구조를 기반으로 한다. 루프 테스트와 구문 검사(또는 구조 기반 검사)는 화이트박스 테스트에 해당한다. 동등 분할 검사와 경계값 분석은 블랙박스 테스트 기법이다.   
28. 답: ④   
    해설: 동등 분할 검사와 경계값 분석은 블랙박스 테스트 기법으로, 입력값의 유효 범위에 따라 테스트 케이스를 선정하며, 특히 경계값 근처에서 오류가 많이 발견된다고 가정한다. 중간값만을 사용하는 것은 일반적인 블랙박스 기법의 설명과 거리가 멀다.   
29. 답: ①   
    해설: 동치 분할 검사(Equivalence Partitioning)와 경계값 분석(Boundary Value Analysis)은 프로그램의 내부 구조를 고려하지 않고 입력값이나 출력값을 기반으로 테스트 케이스를 설계하는 블랙박스 테스트 기법이다. 경로 검사와 조건 검사는 화이트박스 테스트 기법이다.   
30. 답: ②   
    해설: 동치 분할 검사(Equivalence Partitioning), 원인 결과 그래프 기법(Cause-Effect Graphing), 오류 예측 기법(Error Guessing)은 블랙박스 테스트 기법에 해당한다. 구문 기반 검사(Syntax Testing)는 화이트박스 테스트 기법에 해당한다.   
31. 답: ①   
    해설: STAF는 멀티플랫폼 테스트 자동화 프레임워크로, 여러 언어를 지원하지만 Ruby를 *주요* 언어로 사용하는 것은 Watir(Q33의 보기 4)이나 다른 도구에 가깝다. 소스의 전문가 의견에서는 STAF를 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크로 설명하며 Ruby 사용을 직접적으로 언급하지 않는다.   
32. 답: ①   
    해설: STAF는 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크이다. 특정 언어인 Ruby를 주 사용 언어로 명시하는 것은 Watir(Q33의 보기 4) 등 다른 도구의 설명과 혼동될 수 있다. 소스의 전문가 의견에서는 STAF를 서비스 호출 및 컴포넌트 재사용을 지원하는 테스트 프레임워크라고만 설명한다.   
33. 답: ①   
    해설: Foxbase는 데이터베이스 관리 시스템(DBMS)의 이름으로, 인터페이스 구현 검증 도구와는 거리가 멀다. STAF, xUnit, watir 등은 소프트웨어 테스트 자동화 또는 인터페이스 검증에 사용되는 도구/프레임워크이다.   
34. 답: ④   
    해설: 검증(Verification)은 제품이 명세에 따라 올바르게 만들어졌는지, 즉 '제대로 만들었는지(Are we building the product right?)'를 확인하는 과정이다. 확인(Validation)은 최종 제품이 사용자의 요구사항을 만족하는지, 즉 '올바른 제품을 만들었는지(Are we building the right product?)'를 확인하는 과정이다. 개발자가 요구사항 명세서를 제대로 이해했는지 확인하는 것은 요구사항 분석/검토 단계의 활동이다.   
35. 답: ②   
    해설: 클린 코드의 원칙 중 의존성 관리는 모듈 간의 의존성을 최소화하여 다른 코드에 미치는 영향을 줄이는 것을 의미한다. 모든 모듈이 다른 모듈에 미치는 영향을 '최소화'하는 것이 목표이며, '최대화'하는 것은 원칙과 반대된다.   
36. 답: ④   
    해설: 클린 코드는 누구나 쉽게 읽고 이해할 수 있도록 작성하는 것을 강조한다. 코드를 간단하게 작성하는 것은 좋은 습관이지만, '간단하게'라는 표현보다는 '이해하기 쉽게', '가독성 있게' 작성하는 것이 클린 코드의 핵심 원칙이다.   
37. 답: ②   
    해설: 사용성(Usability)은 사용자가 소프트웨어를 얼마나 쉽게 배우고 효율적으로 사용할 수 있으며, 사용 시 만족감을 느끼는지 등을 나타내는 품질 특성이다.   
38. 답: ③   
    해설: Walkthrough는 비공식적인 검토 기법으로 오류를 미리 발견하고 개선하는 데 초점을 둔다. 인스펙션(Inspection)은 Walkthrough보다 더 공식적이고 체계적인 검토 기법이다. 따라서 Walkthrough와 인스펙션은 다른 기법이다.   
39. 답: ③   
    해설: 인스펙션(Inspection)은 동적으로 프로그램을 실행하지 않고 코드나 문서를 검토하는 정적 테스트 기법이다.   
40. 답: ①   
    해설: ISO/IEC 9126에서 기능성(Functionality)의 하위 특성은 적합성, 정확성, 상호 운용성, 보안성, 준수성이다. 학습성(Learnability)은 사용성(Usability)의 하위 특성이다.   

**과목 3**  
41. 답: ①   
    해설: CREATE TABLE문은 테이블 생성 시 속성 타입, NOT NULL 제약조건, 기본키/외래키 지정, CHECK 제약조건 등을 정의할 수 있다. 이미 생성된 테이블의 속성 타입을 변경하는 것은 ALTER TABLE 문을 사용한다.   
42. 답: ④   
    해설: 뷰(View)는 저장장치 내에 물리적으로 존재하지 않는 가상 테이블이다. 뷰가 정의된 기본 테이블이나 뷰를 삭제하면, 해당 뷰 또는 그 뷰를 참조하는 다른 뷰도 자동으로 제거된다.   
43. 답: ①   
    해설: 제1정규형에서 제2정규형으로 정규화할 때는 부분 함수 종속을 제거한다. 이행 함수 종속은 제3정규형에서, 후보키가 아닌 결정자에 함수 종속되는 것은 BCNF에서 제거된다. 다치 종속은 제4정규형에서 제거된다.   
44. 답: ④   
    해설: 제2정규형(2NF)은 1NF를 만족하고, 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속(Full Functional Dependency)을 만족해야 한다. 즉, 부분 함수 종속을 제거해야 한다.   
45. 답: ④   
    해설: 참조 무결성 제약 조건은 외래키 값이 NULL이거나, 참조 릴레이션의 기본키 값과 동일해야 한다는 규칙이다.   
46. 답: ③   
    해설: 분산 데이터베이스 시스템의 장점은 데이터 공유, 가용성, 신뢰성, 접근 속도 향상 등이며, 구축 및 관리 비용은 오히려 증가할 수 있다.   
47. 답: ④   
    해설: 분산 데이터베이스 시스템의 주요 구성 요소는 분산 처리기(DP), 분산 데이터(DD), 통신 네트워크(Communication Network)이다. P2P 시스템은 중앙 집중식 데이터베이스 시스템과는 거리가 멀다.   
48. 답: ④   
    해설: 분산 데이터베이스 시스템은 데이터를 여러 위치에 분산시켜 저장하므로, 새로운 지역 서버 추가 등은 분산 설계 및 구현에 따라 용이할 수도 있고 어려울 수도 있다. 일반적으로 분산 시스템은 관리 및 구축이 더 복잡하다. 나머지 설명은 분산 데이터베이스 시스템의 특징 및 목표에 부합한다.   
49. 답: ②   
    해설: 시스템 카탈로그는 데이터베이스 관리 시스템(DBMS)이 스스로 생성하고 유지하며 관리하는 특별한 테이블의 집합체이다. 사용자는 시스템 카탈로그에 저장된 정보를 검색할 수 있지만, SQL 문을 사용하여 직접 갱신하거나 삭제할 수 없다.   
50. 답: ①   
    해설: 관계 대수는 절차적인 언어이고, 관계 해석은 비절차적인 언어이다. 관계 대수와 관계 해석은 모두 수학의 프레디컷 해석에 기반을 두고 있지만, 관계 해석이 프레디컷 해석과 더 가깝다고 볼 수 있다. 관계 대수는 연산자를 사용하여 원하는 결과를 얻는 절차를 명시한다.   
51. 답: ①   
    해설: 관계 해석은 비절차적인 언어로서 원하는 정보가 무엇인지만 명세하고, 이를 얻는 절차는 명세하지 않는다. 원래 수학의 프레디컷 해석에 기반을 두고 있다.   
52. 답: ①   
    해설: 원자성(Atomicity)은 트랜잭션 내의 모든 연산은 완전히 실행되거나, 어떤 연산도 전혀 실행되지 않거나(all-or-nothing) 한다는 성질을 의미한다.   
53. 답: ③   
    해설: 일관성(Consistency)은 트랜잭션 실행 전과 후의 데이터베이스 상태가 일관되어야 함을 의미한다. 트랜잭션은 데이터베이스의 제약 조건 등을 위반하지 않고 실행되어야 한다.   
54. 답: ②   
    해설: 고립성(Isolation)은 여러 트랜잭션이 동시에 실행될 때, 각 트랜잭션이 다른 트랜잭션의 영향을 받지 않고 독립적으로 실행되는 것처럼 보이는 성질을 의미한다.   
55. 답: ④   
    해설: 지속성(Durability)은 트랜잭션이 성공적으로 완료(Commit)된 후에는 시스템에 장애가 발생하더라도 트랜잭션의 결과가 손실되지 않고 영구적으로 반영되는 성질을 의미한다.   
56. 답: ③   
    해설: 제3정규형(3NF)은 제2정규형을 만족하고, 기본키가 아닌 속성들이 기본키가 아닌 다른 속성에 함수 종속되는 이행 함수 종속을 제거해야 한다.   
57. 답: ④   
    해설: BCNF는 제3정규형을 만족하면서, 모든 결정자가 후보키 집합에 속하는 정규형이다. 즉, 후보키가 아닌 결정자가 존재할 때 발생하는 함수 종속을 제거해야 한다. 제4정규형은 다치 종속을 제거한다.   
58. 답: ②   
    해설: E-R 모델에서 속성은 타원으로 표현된다. 마름모는 관계 타입을, 사각형은 개체 타입을 표현한다.   
59. 답: ②   
    해설: E-R 다이어그램에서 속성은 타원으로 표현된다. 원형이 아니라 타원이다.   
60. 답: ③   
    해설: 로킹 단위가 작아지면 로크의 수가 많아져 로킹 오버헤드가 증가하지만, 병행 수행 수준(동시성)은 높아진다. 로킹 단위가 크면 로크 수가 적어 오버헤드는 줄지만, 병행 수행 수준은 낮아진다.   

**과목 4**  
61. 답: ①   
    해설:   
    a=4 (0100), b=6 (0110), c=2 (0010)   
    r1 = (a & b) | c = (0100 & 0110) | 0010 = 0100 | 0010 = 0110 (6)   
    r2 = (a ^ b) & c = (0100 ^ 0110) & 0010 = 0010 & 0010 = 0010 (2)   
    r3 = !c   
    C언어에서 논리 부정 연산자 `!`는 피연산자가 0이 아니면 0을, 0이면 1을 반환한다. c는 2이므로 0이 아니다. 따라서 !c는 0이 된다.   
    결과: 6, 2, 0   
62. 답: ③   
    해설:   
    a = 4 (이진수: 0100)   
    b = 7 (이진수: 0111)   
    c = a | b = (0100 | 0111) = 0111 (이진수)   
    0111은 십진수로 7이다.   
    결과: 7   
63. 답: ③   
    해설:   
    `scanf("%c", &ch);` 에 'c'를 입력하면 ch 변수에 'c'가 저장된다.   
    `switch (ch)` 문에서 ch의 값이 'c'이므로 `case 'c':`로 이동한다.   
    `printf("three ");` 가 실행되어 "three "가 출력된다.   
    `break;` 문을 만나 switch 문을 빠져나간다.   
    `return 0;` 가 실행되어 프로그램이 종료된다.   
    결과: three   
64. 답: ③   
    해설: IPv6의 기본 패킷 크기는 64Kbyte이지만, Jumbogram 옵션을 사용하면 4Gbyte까지 확장 가능하다. 따라서 64Kbyte로 고정되어 있다는 설명은 틀렸다.   
65. 답: ②   
    해설: `elif`는 Python에서 `else if`와 동일한 역할을 한다. 첫 번째 `if x == 10` 조건은 거짓이고, `elif x == 20` 조건은 참이므로 '20'이 출력된다.   
66. 답: ③   
    해설: JAVA 변수명 작성 규칙에서 변수명 중간에 공백을 포함할 수 없다.   
67. 답: ④   
    해설:   
    초기 r = 0   
    i = 1: r = 0 + 1 = 1   
    i = 2: r = 1 + 2 = 3   
    i = 3: r = 3 + 3 = 6   
    for 루프 종료.   
    printf("%d", r); 에 의해 6이 출력된다.   
    결과: 6   
68. 답: ③   
    해설:   
    `&n`은 변수 n의 주소이다.   
    `npt`는 변수 n의 주소를 저장하는 포인터 변수이므로 `npt == &n`이다.   
    포인터 산술 연산에서 `포인터 + 정수`는 `포인터 + 정수 * (타입의 크기)` 와 같다.   
    int 형의 크기는 4Byte이므로,   
    `&n + 1` 은 n의 주소 + 1 * 4Byte = n의 주소 + 4Byte 이다. n이 1000번지에 있다면 1004번지가 된다.   
    `npt - 1` 은 npt의 주소 - 1 * 4Byte = n의 주소 - 4Byte 이다. n이 1000번지에 있다면 996번지가 된다.   
    소스의 예시 실행 결과는 8, 4로 되어 있는데, 이는 &n + 1과 npt - 1을 각각의 값으로 출력한 것이 아니라, 특정 예시에서의 메모리 주소 값 차이를 표현한 것으로 보인다. 실제 메모리 주소는 실행 시마다 달라지므로, 주소 값 그대로를 출력하기보다는 주소 연산의 결과를 이해하는 것이 중요하다. 소스에서 제시된 결과 8, 4는 주소 연산 결과값 자체라기 보다는 다른 문제에 대한 답변으로 보이며, 이 문제에 대한 실제 실행 결과는 시스템 환경에 따라 달라지는 주소 값들이므로 정확한 숫자를 예측하기 어렵다. 하지만 문제의 의도는 포인터 산술 연산의 결과를 묻는 것이므로, &n+1은 n의 주소보다 int 크기만큼 증가한 주소를, npt-1은 npt가 가리키는 주소보다 int 크기만큼 감소한 주소를 나타낸다는 것을 이해해야 한다.   
    (문제의 보기 ③ 8, 0은 소스 해설의 결과와 다르며, 이 해설은 다른 문제에 대한 것으로 보입니다. 따라서 문제와 보기를 소스에서 그대로 가져왔으나, 해설은 해당 문제가 아니라 다른 C코드 문제에 대한 해설이 잘못 연결된 것으로 판단됩니다. 정확한 해설은 &n + 1은 n 주소 + 4바이트, npt - 1은 npt 주소 - 4바이트가 됩니다.)   
    *정확한 해설 부재로 인한 추가 설명*: 이 문제와 같은 경우 실제 실행 결과는 시스템마다 메모리 할당 방식이 달라지므로 정해진 숫자로 답을 하기는 어렵습니다. 하지만 문제의 의도가 포인터 산술 연산을 묻는 것이라면, `&n + 1`과 `npt - 1`이 각각 `sizeof(int)` 만큼 주소가 증가/감소한다는 개념을 아는지 평가하는 것입니다. 제시된 보기 중 8, 4라는 특정 숫자가 나오는 이유는 해당 기출 시험 당시의 특정 시스템에서의 메모리 주소 값과 관련 있을 수 있습니다. 소스 PDF의 해당 페이지 하단의 전문가 의견은 다른 C 코드 문제(&a와 &a의 주소 차이)에 대한 해설이 잘못 삽입된 것으로 보입니다. 따라서 이 문제의 정답은 소스 자체만으로는 확정하기 어려우나, 제시된 보기가 있다면 출제 의도에 맞는 답을 선택해야 합니다. 소스 PDF의 정답은 ③으로 표시되어 있으나, 해설은 ③을 지지하지 않습니다. 문제의 출처을 따르되, 해설은 정확한 내용을 바탕으로 수정했습니다.   
69. 답: ④   
    해설: `main` 함수에서 `div(5, 5)`를 호출한다. `try` 블록 안의 `System.out.println(a / b);`는 5 / 5 = 1을 계산하고 "1"을 출력한다. 나눗셈 예외(ArithmeticException)는 발생하지 않으므로 `catch` 블록은 실행되지 않는다. `finally` 블록은 예외 발생 여부와 관계없이 항상 실행되므로 `System.out.println("Done");`이 실행되어 "Done"을 출력한다.   
70. 답: ③   
    해설:   
    `func(11)` 호출. n = 11.   
    `range(n + 1)`은 `range(12)`와 같으며, 이는 0부터 11까지의 정수를 생성한다 (0, 1, 2, ..., 11).   
    `for i in range(12)` 루프가 실행되면서 i는 0부터 11까지 순서대로 값을 갖는다.   
    sum은 각 i 값을 누적한다. sum = 0 + 1 + 2 + ... + 11   
    이는 0부터 11까지의 합으로, (11 * 12) / 2 = 66이다.   
    함수는 sum 값인 66을 반환한다.   
    `print(r)`에 의해 66이 출력된다.   
    결과: 66   
71. 답: ①   
    해설: C 언어에서 표준 입출력 함수(printf, scanf 등)를 사용하기 위해서는 `<stdio.h>` 헤더 파일을 포함해야 한다.   
72. 답: ②   
    해설:   
    `int[] arr = new int;` : 크기 4의 int 배열 `arr` 생성. 초기값은 0.   
    첫 번째 `for` 루프: i = 0, 1, 2, 3   
    `arr[i] = i + 1;` : arr=1, arr=2, arr=3, arr=4   
    배열 `arr`은 {1, 2, 3, 4}가 된다.   
    두 번째 `for` 루프: i = 0, 1, 2, 3   
    `System.out.print(arr[i]);` : arr, arr, arr, arr 값을 순서대로 공백 없이 출력한다.   
    1, 2, 3, 4가 차례로 출력된다.   
    결과: 1234   
73. 답: ③   
    해설: C 언어에서 `%s`는 문자열(string)을 출력할 때 사용하는 서식 지정자이다.   
74. 답: ③   
    해설:   
    int 배열 `arr`은 {14, 22, 30, 38}이다.   
    `&arr`는 배열의 첫 번째 요소 주소이다.   
    `&arr`는 배열의 두 번째 요소 주소이다.   
    `&arr`는 배열의 세 번째 요소 주소이다.   
    `%u`는 부호 없는 정수형으로 주소를 출력한다.   
    int형의 크기가 4Byte이므로, 배열 요소 간의 주소 차이는 4Byte이다.   
    `&arr`의 주소가 특정 값 (예: 1000)이라면, `&arr`의 주소는 1000 + 4 = 1004, `&arr`의 주소는 1004 + 4 = 1008이 된다.   
    문제의 보기 ③ 18, 10은 소스 해설의 결과와 다르며, 이 해설은 다른 문제에 대한 것으로 보입니다. 소스의 전문가 의견은 다른 C 코드 문제(&arr, &arr 주소)에 대한 해설이 잘못 삽입된 것으로 보입니다. 실제 실행 결과는 시스템 환경에 따라 달라지므로, 정확한 숫자를 예측하기 어렵습니다.   
    *정확한 해설 부재로 인한 추가 설명*: 이 문제 역시 Q68과 마찬가지로 실제 실행 시의 메모리 주소 값은 시스템마다 달라집니다. 문제의 의도는 배열 요소의 주소가 `sizeof(int)`만큼 차이 난다는 것을 아는지 평가하는 것입니다. 제시된 보기 ③ 18, 10은 Q68 보기 ③과 유사하게 특정 시스템 환경의 주소 값을 가정한 것으로 보이며, 소스의 전문가 의견은 이 문제에 대한 해설이 아닙니다.   
75. 답: ①   
    해설: C는 명령문들이 순서대로 실행되는 절차적 프로그래밍 언어이다. Java, Python, C++은 객체지향 프로그래밍을 지원하는 언어이다.   
76. 답: ④   
    해설:   
    int 배열 a = {11, 22, 44, 55}   
    int i, sum = 0   
    int *p = a; // p는 배열 a의 첫 번째 요소(11)를 가리킨다.   
    for 루프: i는 1부터 3까지 증가한다.   
    `sum += *(p + i);` 는 `sum += a[i];` 와 같다.   
    i=1: sum = 0 + a = 0 + 22 = 22   
    i=2: sum = 22 + a = 22 + 44 = 66   
    i=3: sum = 66 + a = 66 + 55 = 121   
    loop 종료.   
    `printf("%d\n", sum);` 에 의해 121이 출력된다.   
    결과: 121   
77. 답: ④   
    해설: Python의 리스트 슬라이싱 `a[start:end]`는 `start` 인덱스부터 `end-1` 인덱스까지의 요소를 포함하는 새로운 리스트를 반환한다. `a[2:7]`는 인덱스 2부터 6까지의 요소를 가져온다.   
    a =   
    인덱스: 0, 1, 2, 3, 4, 5, 6, 7, 8   
    a[2:7] = a, a, a, a, a =   
    결과:   
78. 답: ③   
    해설:   
    `cal(11)` 호출. n=11   
    `range(n+1)`은 `range(12)`와 같으며, 0부터 11까지의 정수 시퀀스를 생성한다.   
    sum은 이 시퀀스의 합을 계산한다: 0+1+2+...+11.   
    이는 0부터 11까지의 자연수 합이므로, `(11 * (11 + 1)) / 2 = (11 * 12) / 2 = 66` 이다.   
    print(66)이 실행된다.   
    결과: 66   
79. 답: ②   
    해설:   
    `input().split(',')`는 사용자로부터 문자열을 입력받아 ','를 기준으로 분리하여 리스트로 만든다. '53,44'를 입력하면 ['53', '44'] 리스트가 된다.   
    `map(int, ...)`는 리스트의 각 요소에 `int()` 함수를 적용하여 정수로 변환한다. 결과는가 된다.   
    `a, b = [...]`는 이 리스트의 요소를 각각 변수 a와 b에 할당한다. 따라서 a=53, b=44가 된다.   
    `print(a, b)`는 변수 a와 b의 값을 출력한다. print 함수는 기본적으로 인자들을 공백으로 구분하여 출력한다.   
    결과: 53 44   
    (문제의 보기 ② 53, 44는 출력 결과가 "53 44"임을 의미하는 것으로 해석해야 합니다. 쉼표와 공백은 단순히 출력 결과를 나열한 것이 아니라, Python의 `print` 함수 기본 동작으로 인해 53과 44 사이에 공백이 들어간 결과를 나타냅니다.)   
80. 답: ③   
    해설: 이 문제는 Q68과 동일한 문제입니다. 설명은 Q68의 해설을 참고해주세요. 소스 상의 해설은 다른 문제에 대한 것으로 잘못 삽입되었습니다.   

**과목 5**  
81. 답: ①   
    해설: 정보시스템 구축 관리는 자원(데이터, 프로세스 등)의 공유를 목표로 하지 않는다. 주요 목표는 요구사항을 충족하는 시스템을 효율적으로 개발하고 관리하는 것이다.   
82. 답: ③   
    해설: 시스템 개발 단계에서 구현 단계는 설계된 내용을 바탕으로 실제 프로그램을 코딩하고 테스트하는 활동을 수행한다.   
83. 답: ④   
    해설: 폭포수 모델과 같은 전통적인 SDLC 모델은 개발 과정 중의 변경 사항에 유연하게 대처하기 어려운 단점이 있다.   
84. 답: ④   
    해설: 요구사항 분석 단계에서는 사용자의 요구사항을 수집, 식별, 구조화, 명세하는 활동을 한다. 시스템 테스트 계획 수립은 테스트 단계에서 수행한다.   
85. 답: ④   
    해설: 설계 단계에서는 시스템 구조 설계, 데이터베이스 설계, 인터페이스 설계 등을 수행한다. 요구사항 검토 및 승인은 요구사항 분석 단계 또는 다음 단계로 넘어가기 전에 수행된다.   
86. 답: ④   
    해설: 테스트 단계에서는 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트 등을 수행한다. 사용자 요구사항 정의는 요구사항 분석 단계 활동이다.   
87. 답: ④   
    해설: 유지보수 단계에서는 운영 중인 시스템의 오류 수정, 성능 개선, 기능 추가 등 시스템의 변경 및 관리를 수행한다. 시스템 구축 계획 수립은 프로젝트 초기 단계 활동이다.   
88. 답: ③   
    해설: 폭포수 모델은 개발 과정을 단계별로 구분하고 이전 단계가 완료되어야만 다음 단계로 진행되는 순차적인 개발 방법론이다.   
89. 답: ①   
    해설: 나선형 모델은 점진적 개발과 반복적 개발을 결합한 모델로, 개발 주기마다 위험 분석을 수행하는 특징이 있다.   
90. 답: ②   
    해설: 프로토타이핑 모델은 사용자의 요구사항을 명확히 하기 위해 실제 동작하는 시스템의 일부 또는 원형을 개발하여 사용자의 피드백을 받아 요구사항을 구체화하는 모델이다.   
91. 답: ④   
    해설: 데이터 모델링은 시스템 구축 초기 단계에서 수행된다. 운영 단계에서만 수행되는 것이 아니다.   
92. 답: ④   
    해설: 개념적 데이터 모델링은 특정 DBMS를 고려하지 않고 수행되는 독립적인 설계 단계이다. 데이터 저장 구조 및 접근 방법 구체화는 물리적 데이터 모델링 단계에서 수행된다.   
93. 답: ③   
    해설: 논리적 데이터 모델링 단계에서는 개념적 모델링에서 정의된 데이터를 특정 DBMS의 논리적 구조로 변환하고, 정규화를 수행한다. 데이터 저장 공간 할당, 접근 방법, 응답 시간 등은 물리적 데이터 모델링 단계에서 고려된다.   
94. 답: ④   
    해설: 물리적 데이터 모델링 단계는 특정 DBMS와 하드웨어 환경을 고려하여 성능을 최적화하는 단계이다. 특정 환경에 독립적으로 수행되지 않는다.   
95. 답: ②   
    해설: SDN은 네트워크 제어부와 전달부를 분리하여 중앙 집중식 제어를 통해 네트워크 관리를 효율화하는 기술이다. 기존 네트워크 장비의 펌웨어 업그레이드만으로는 사용자의 직접적인 데이터 전송 경로 관리를 유연하게 수행하기 어렵다. SDN은 소프트웨어를 통해 경로 설정 및 제어를 프로그래밍 방식으로 수행한다.   
96. 답: ④   
    해설: DAS, NAS, SAN은 데이터 저장 장치를 서버나 네트워크에 연결하여 데이터를 저장하고 공유하는 기술 방식이다. CDN(Content Delivery Network)은 사용자에게 콘텐츠를 빠르게 전송하기 위한 분산 네트워크 기술로, 데이터 저장 방식 자체보다는 콘텐츠 배포 방식과 관련이 깊다.   
97. 답: ④   
    해설: 정보 보안의 3요소는 기밀성(Confidentiality), 무결성(Integrity), 가용성(Availability)이다. 편리성은 정보 보안의 직접적인 목표라기보다는 서비스의 품질 측면이다.   
98. 답: ④   
    해설: 인증(Authentication)은 접근 주체가 누구인지, 즉 사용자의 신원을 확인하는 과정이다. 접근 권한이 있는지를 확인하는 것은 인가(Authorization) 과정이다.   
99. 답: ④   
    해설: 인증(Authentication)에 사용되는 주요 요소는 Something You Know (지식), Something You Have (소유), Something You Are (속성), Somewhere You Are (위치) 등이다. Something You See는 시각 정보 그 자체를 의미하며, 인증 요소로 직접 분류하기 어렵다.   
100. 답: ①   
    해설: 기밀성(Confidentiality)은 허가되지 않은 사용자나 시스템에게 정보가 노출되지 않도록 보호하는 특성이다.   

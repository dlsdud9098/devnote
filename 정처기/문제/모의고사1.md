**정보처리기사 기출 문제**  

**1과목: 소프트웨어 설계**  

1.  애자일(Agile) 방법론에 대한 설명으로 옳은 것은?  
    ①  프로세스 및 도구보다는 개별과 상호작용에 더 가치를 둔다.  
    ②  방대한 문서보다는 실행되는 소프트웨어에 가치를 둔다.  
    ③  계약 협상보다는 고객과의 협력에 가치를 둔다.  
    ④  계획을 따르기보다는 변화에 반응하는 것에 가치를 둔다.   

2.  XP(eXtrem eXtreme Programming)의 5가지 핵심 가치로 거리가 먼 것은?  
    ①  용기  
    ②  의사소통  
    ③  피드백  
    ④  생명 분석   

3.  자료 흐름도(DFD)의 구성 요소 표기 형태의 연결이 옳지 않은 것은?  
    ①  자료 흐름(Data Flow): 화살표  
    ②  처리(Process): 원  
    ③  자료 저장소(Data Store): 지선(평행선)  
    ④  단말(Terminator): 오각형   

4.  HIPO(Hierarchy Input Process Output)에 대한 설명으로 거리가 먼 것은?  
    ①  상향식 소프트웨어 개발을 위한 문서화 도구이다.  
    ②  HIPO 차트 종류에는 가시적 도표, 총체적 도표, 세부적 도표가 있다.  
    ③  기능과 자료의 관련 관계를 표현할 수 있다.  
    ④  보기 쉽고 이해하기 쉽다.   

5.  다음 중 상태 다이어그램에서 객체 전이의 원인이 되는 요소는?  
    ①  event  
    ②  state  
    ③  transition  
    ④  모든 요소   

6.  UML 모델에서 스테레오 타입을 표현할 때 사용하는 기호로 맞는 것은?  
    ①  < >  
    ②  ( )  
    ③  {{ }}  
    ④  [ ]   

7.  다음 중 설명하는 디자인 패턴은?  
    객체를 생성하기 위한 인터페이스를 정의하며 어떤 클래스가 인스턴스화될 것인지는 서브클래스에게 결정하도록 하는 것  
    ①  Visitor 패턴  
    ②  Observer 패턴  
    ③  Factory Method 패턴  
    ④  Bridge 패턴   

8.  다음 중 디자인 패턴 중 생성(Creational) 패턴에 속하지 않는 것은?  
    ①  Observer  
    ②  Adapter  
    ③  Decorator  
    ④  Proxy   

9.  미들웨어에 대한 설명으로 옳지 않은 것은?  
    ①  DB는 데이터베이스 서버와 제공하는 클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어이다.  
    ②  WAS는 사용자의 요구에 따라 변화하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어이다.  
    ③  MOM은 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어이다.  
    ④  RPC는 코바(CORBA) 표준 스펙을 구현한 객체 지향 미들웨어이다.   

10. 자동화된 기법을 통해 소프트웨어 품질이 향상된다. 소프트웨어의 유지보수를 간편하게 수행할 수 있다. 소프트웨어의 생산성이 향상된다. 소프트웨어 모듈의 재사용성이 줄어든다. 다음은 무엇에 대한 설명인가?  
    ①  CASE 도구  
    ②  디버거  
    ③  컴파일러  
    ④  인터프리터   

11. 화이트박스 테스트에 대한 설명으로 옳지 않은 것은?  
    ①  프로그램 원시 코드의 논리적인 구조를 커버하도록 테스트 케이스를 설계한다.  
    ②  프로그램 실행 경로 중복이나 누락 없이 수행되도록 테스트 케이스를 설계한다.  
    ③  화이트박스 테스트 기법에는 기초 경로 검사, 루프 검사 등이 있다.  
    ④  모든 모듈의 모든 경로를 테스트한다.   

12. 화이트박스 테스트의 설명으로 틀린 것은?  
    ①  프로그램의 제어 구조, 반복, 분기 부분 등을 소프트웨어의 논리적 구조를 검사한다.  
    ②  기초 경로 검사(Base Path Testing)는 테스트 케이스 설계자가 절차적 설계의 제어 구조를 사용하여 테스트 케이스를 설계하며, 테스트 과정의 초기에 적용된다.  
    ③  루프 검사(Loop Testing)는 프로그램의 반복(Loop) 구조를 집중적으로 테스트하는 테스트 케이스 설계 기법이다.  
    ④  데이터 흐름 검사(Data Flow Testing)는 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 테스트 케이스 설계 기법이다.   

13. 요구사항을 도출하기 위한 기법이 아닌 것은?  
    ①  사용자 인터뷰  
    ②  설문 조사  
    ③  사용자 교육  
    ④  래피드 프로토타이핑   

14. 프로토타이핑 모델에 대한 설명으로 틀린 것은?  
    ①  XP는 빠른 개발을 위해 단순화를 지향한다.  
    ②  변화에 대응하기보다는 변화에 반응하는 것에 더 가치를 둔다.  
    ③  릴리즈 기간을 짧게 반복하면서 고객의 요구사항 반영에 대한 가시성을 높인다.  
    ④  사용자의 요구사항이 확정된 시점에서만 프로토타이핑을 수행한다.   

15. UI 설계 원칙 중 누구나 쉽게 이해하고 사용할 수 있어야 한다는 원칙은?  
    ①  최소 노력  
    ②  유연성  
    ③  직관성  
    ④  만족성   

16. 다음 중 SOLID 원칙이라고 불리는 객체지향 설계 원칙에 속하지 않는 것은?  
    ①  ISP(Interface Segregation Principle)  
    ②  LSP(Liskov Substitution Principle)  
    ③  DIP(Dependency Inversion Principle)  
    ④  SSO(Single Sign On)   

17. UML에서 한 사물의 명세가 바뀌면 다른 사물의 명세에 따라 자동으로 변수로 사용하려는 경우에 나타나는 관계는?  
    ①  Association  
    ②  Dependency  
    ③  Realization  
    ④  Generalization   

18. 객체지향 설계 원칙 중, 서브 클래스는 슈퍼 클래스의 행위를 변경하지 않고 확장해야 한다는 원칙은?  
    ①  SRP(Single Responsibility Principle)  
    ②  OCP(Open/Closed Principle)  
    ③  LSP(Liskov Substitution Principle)  
    ④  ISP(Interface Segregation Principle)   

19. 클린 코드(Clean Code) 작성 원칙으로 틀린 것은?  
    ①  가독성: 누구나 쉽게 읽을 수 있도록 작성한다.  
    ②  단순성: 복잡도를 최대한 낮춘다.  
    ③  의존성: 다른 모듈에 미치는 영향을 최소화한다.  
    ④  중복성: 중복을 최소화한다.   

20. 객체지향 분석 기법 중 자료 흐름(DFD)을 주로 이용하는 것은?  
    ①  기능 모델링  
    ②  동적 모델링  
    ③  객체 모델링  
    ④  정적 모델링   

**2과목: 소프트웨어 개발**  

21. 익스트림 프로그래밍(XP) 개발 방법론에 대한 설명으로 틀린 것은?  
    ①  짝 프로그래밍(Pair Programming)은 독립적으로 코딩할 때보다 더 나은 경험을 조성한다.  
    ②  간단한 설계(Simple Design)를 선호하며, 필요한 경우에만 리팩토링한다.  
    ③  지속적인 통합(Continuous Integration)을 통해 빠른 피드백을 얻는다.  
    ④  고객은 개발 과정에 참여하여 요구사항을 정의하고 우선순위를 정한다.   

22. 형상 관리 항목으로 포함되지 않는 것은?  
    ①  프로젝트 계획서  
    ②  소스 코드  
    ③  요구사항 명세서  
    ④  프로젝트 개발 비용   

23. 소프트웨어 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동을 통칭하는 용어는?  
    ①  복구  
    ②  형상 관리  
    ③  저장  
    ④  크랙   

24. 형상 관리 도구에서 변경 이력을 저장소(Repository)에 기록하는 것을 의미하는 용어는?  
    ①  감사(Configuration Audit)  
    ②  롤백(Rollback)  
    ③  단위 테스트(Unit Test)  
    ④  커밋(Commit)   

25. 형상 관리 시스템에서 특정 시점으로 되돌리는 것을 의미하는 용어는?  
    ①  Check-in  
    ②  Check-out  
    ③  Commit  
    ④  Rollback   

26. 블랙박스 테스트의 설명으로 옳은 것은?  
    ①  프로그램 내부 구조나 동작을 알지 못한 상태에서 수행하는 테스트이다.  
    ②  프로그램 원시 코드를 기반으로 논리적 경로를 검사한다.  
    ③  프로그램의 단위 모듈을 테스트한다.  
    ④  요구사항 명세를 기반으로 테스트 케이스를 설계한다.   

27. 소프트웨어 테스트 기법 중, 사용자의 요구사항 명세서를 기반으로 테스트 케이스를 설계하는 기법은?  
    ①  구조적 테스트  
    ②  명세 기반 테스트  
    ③  경험 기반 테스트  
    ④  탐색적 테스트   

28. 소프트웨어 테스트 방법 중 화이트박스 테스트에 해당하는 것은?  
    ①  동등 분할 기법  
    ②  경계값 분석  
    ③  기초 경로 검사  
    ④  오류 추정 기법   

29. 소프트웨어 테스트 기법 중 블랙박스 테스트에 해당하지 않는 것은?  
    ①  동등 분할 기법  
    ②  경계값 분석  
    ③  결함 주입 기법  
    ④  오류 추정 기법   

30. CASE 도구 중 구현 단계 도구가 아닌 것은?  
    ①  ESB  
    ②  xUnit  
    ③  STAF  
    ④  NTAF   

31. 테스트 자동화 도구에 대한 설명으로 옳지 않은 것은?  
    ①  FitNesse는 웹 기반 테스트 케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크이다.  
    ②  xUnit 계열 도구는 다양한 언어를 지원하는 단위 테스트 프레임워크이다.  
    ③  STAF는 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크이다.  
    ④  Selenium은 웹 애플리케이션 테스트 자동화 프레임워크로, 통합 테스트 수준에 활용된다.   

32. 통합 테스트(Integration Test)에 대한 설명으로 틀린 것은?  
    ①  시스템을 구성하는 모듈의 인터페이스와 결함을 테스트한다.  
    ②  하향식 통합 테스트의 경우 우선(Breadth First) 방식은 테스트할 모든 모듈을 상향으로 스텁 처리한다.  
    ③  상향식 통합 테스트의 경우 시스템 구조의 최상위에 있는 모듈을 먼저 구현하여 테스트한다.  
    ④  모든 단위의 인터페이스와 시스템의 동작이 정상적으로 되고 있는지를 빠르게 파악하고 자동화하기 좋은 통합 테스트 기법이다.   

33. 소프트웨어 테스트의 원리 중 소프트웨어 오류의 80%는 전체 모듈의 20%에서 발견된다는 법칙은?  
    ①  Brooks의 법칙  
    ②  Boehm의 법칙  
    ③  Pareto의 법칙  
    ④  Jackson의 법칙   

34. 소프트웨어 검증(Verification)과 확인(Validation)에 대한 설명으로 틀린 것은?  
    ①  검증은 제품의 생산 과정을 테스트한다.  
    ②  확인은 사용자의 요구사항에 부합하는지 최종 제품을 테스트한다.  
    ③  검증은 '제품이 요구사항을 올바르게 구현하는가?'에 대한 질문에 답한다.  
    ④  확인은 '제품이 사용자의 요구를 만족시키는가?'에 대한 질문에 답한다.   

35. 회귀 테스트(Regression Test)의 설명으로 옳은 것은?  
    ①  프로그램 수정 시 기존 테스트 케이스를 재실행하여 변경으로 인해 새로운 결함이 발생했는지 확인하는 테스트이다.  
    ②  프로그램 실행 전에 소스 코드를 분석하여 잠재적인 오류를 발견하는 기법이다.  
    ③  특정 기능을 집중적으로 테스트하기 위해 수행하는 테스트이다.  
    ④  성능 목표 달성 여부를 확인하기 위해 수행하는 테스트이다.  [출처에 직접적인 설명은 없으나, 테스트 관련 내용에서 추론 가능]  

36. 소프트웨어 품질 목표 중에서 '요구되는 기능을 수행하는지', '정확한 결과가 나오는지' 등과 관련된 목표는?  
    ①  기능성(Functionality)  
    ②  효율성(Efficiency)  
    ③  신뢰성(Reliability)  
    ④  유지보수성(Maintainability)   

37. V 모델에 대한 설명으로 틀린 것은?  
    ①  요구 분석 단계와 설계 단계가 병렬적으로 진행된다.  
    ②  각 개발 단계의 결과물을 테스트 단계와 직접 연결하여 검증한다.  
    ③  코딩 단계 이후 통합 테스트, 시스템 테스트, 인수 테스트 순으로 진행된다.  
    ④  소프트웨어 생명 주기 모델 중 하나로, 개발과 테스트 활동이 V자 형태로 연결된다.   

38. 익스트림 프로그래밍(XP)에 대한 설명으로 옳은 것은?  
    ①  계획 수립보다 문서화에 더 많은 시간과 노력을 투자한다.  
    ②  소프트웨어 개발 방법론 중 가장 공식적이고 엄격한 절차를 따른다.  
    ③  릴리즈 주기는 짧고 고객의 피드백을 적극적으로 반영한다.  
    ④  개발팀과 고객 간의 소통보다는 문서 교환을 중요시한다.   

39. 클린 코드(Clean Code) 원칙 중 '코드 변경 시 다른 모듈에 미치는 영향을 최소화'하는 원칙은?  
    ①  가독성  
    ②  단순성  
    ③  의존성  
    ④  중복성   

40. 화이트박스 테스트의 기법이 아닌 것은?  
    ①  기초 경로 검사  
    ②  동등 분할 기법  
    ③  루프 검사  
    ④  데이터 흐름 검사   

**3과목: 데이터베이스 구축**  

41. 관계 데이터 모델에서 테이블의 구성 요소로 옳지 않은 것은?  
    ①  릴레이션은 하나 이상의 튜플의 집합이다.  
    ②  튜플은 릴레이션을 구성하는 각각의 행이다.  
    ③  속성은 릴레이션을 구성하는 열이다.  
    ④  릴레이션은 속성 간의 순서에 의미를 둔다.   

42. SQL의 DML 명령어에 해당하지 않는 것은?  
    ①  SELECT  
    ②  UPDATE  
    ③  CREATE  
    ④  DELETE   

43. 다음 CREATE TABLE 문에 포함될 수 없는 기능은?  
    ①  속성 타입 변경  
    ②  속성의 NOT NULL 여부 지정  
    ③  기본키를 구성하는 속성 지정  
    ④  CHECK 제약조건의 정의   

44. 다음 SQL 문 실행 결과는?  
    ```sql
    SELECT 이름, 학과 FROM 학생 WHERE 학번 = '1001';
    ```  
    학생 테이블  
    | 학번 | 이름 | 학년 | 신장 | 학과 |  
    |---|---|---|---|---|  
    | 1001 | 이길수 | 1 | 170 | CD |  
    | 1002 | 박민수 | 2 | 160 | ED |  
    | 1003 | 정경미 | 2 | 174 | ID |  
    | 1004 | 김수철 | 3 | 180 | ED |  
    ①  이길수 CD  
    ②  박민수 ED  
    ③  정경미 ID  
    ④  김수철 ED   

45. 외래키(Foreign Key)에 대한 설명으로 옳은 것은?  
    ①  후보키 중 기본키로 지정되지 않은 키이다.  
    ②  기본 테이블의 외래키가 될 수 있다.  
    ③  유일성과 최소성을 가진다.  
    ④  참조 무결성 제약조건과 관련이 있다.   

46. 다음 중 관계 대수 연산으로 거리가 먼 것은?  
    ①  SELECT  
    ②  PROJECT  
    ③  JOIN  
    ④  DIVISION   

47. 다음 중 관계 대수 또는 관계 해석을 기반으로 하는 데이터 언어는?  
    ①  DCL  
    ②  DML  
    ③  DDL  
    ④  관계 데이터 언어   

48. 분산 데이터베이스의 투명성(Transparency) 중 여러 트랜잭션의 수행을 동시에 진행하더라도 그 결과가 일관성을 유지하는 투명성은?  
    ①  위치 투명성  
    ②  복제 투명성  
    ③  병행 투명성  
    ④  장애 투명성   

49. 분산 데이터베이스 시스템에서 논리적으로는 하나의 시스템처럼 보이지만, 물리적으로는 여러 컴퓨터 사이트에 분산되어 운영되는 데이터베이스는?  
    ①  관계형 데이터베이스  
    ②  객체지향 데이터베이스  
    ③  분산 데이터베이스  
    ④  객체-관계형 데이터베이스   

50. 정규화 과정에서 제1정규형에서 제2정규형으로 이행하기 위해 만족해야 할 조건은?  
    ①  모든 속성이 원자 값으로 구성된다.  
    ②  기본키가 아닌 모든 속성이 기본키에 대해 완전 함수 종속을 만족해야 한다.  
    ③  이행 함수 종속을 제거해야 한다.  
    ④  결정자가 후보키가 아닌 함수 종속을 제거해야 한다.   

51. 다음 정규형 중 가장 높은 단계는?  
    ①  1NF  
    ②  2NF  
    ③  3NF  
    ④  BCNF   

52. 데이터 무결성 제약조건 중, 기본키를 구성하는 속성은 NULL 값이나 중복 값을 가질 수 없다는 제약조건은?  
    ①  개체 무결성  
    ②  참조 무결성  
    ③  도메인 무결성  
    ④  튜플의 유일성   

53. 스토리지(Storage) 종류 중, 서버와 저장장치를 케이블로 직접 연결하는 방식은?  
    ①  NAS(Network Attached Storage)  
    ②  DAS(Direct Attached Storage)  
    ③  SAN(Storage Area Network)  
    ④  SSD(Solid State Drive)   

54. 데이터베이스의 인덱스(Index)에 대한 설명으로 틀린 것은?  
    ①  인덱스는 데이터 검색 성능을 향상시킨다.  
    ②  B-트리 인덱스는 균형 트리 구조를 갖는다.  
    ③  인덱스는 삽입, 삭제, 수정 작업 시 오버헤드를 발생시킨다.  
    ④  시스템이 자동으로 생성하며 사용자가 생성할 수 없다.   

55. 정규화의 목적으로 옳지 않은 것은?  
    ①  데이터 중복을 최소화한다.  
    ②  삽입, 삭제, 갱신 이상(Anomaly) 발생을 방지한다.  
    ③  데이터의 일관성을 유지한다.  
    ④  데이터 삽입 시 릴레이션을 재생성할 필요성을 줄인다.   

56. 다음 중 객체-관계(Object-Relational) 데이터 모델에 대한 설명으로 틀린 것은?  
    ①  객체는 객체 지향 모델의 개념을 따른다.  
    ②  관계는 관계형 모델의 개념을 따른다.  
    ③  객체와 관계 간의 매핑(mapping)을 통해 통합한다.  
    ④  객체는 속성, 메소드, 객체 식별자를 갖는다.  [출처에 직접적인 객체-관계 데이터 모델 설명은 없으나, ER 모델 및 관계형 모델 설명과 비교하여 추론 가능]  

57. 뷰(View)에 대한 설명으로 틀린 것은?  
    ①  뷰는 저장 장치 내에 물리적으로 존재하지 않는다.  
    ②  뷰는 하나 이상의 기본 테이블로부터 유도된 가상 테이블이다.  
    ③  뷰에 대한 삽입, 삭제, 갱신 연산은 제약이 따른다.  
    ④  뷰는 독립적인 인덱스를 가질 수 있다.   

58. 로킹 단위(Locking Granularity)에 대한 설명으로 옳은 것은?  
    ①  로킹 단위가 작을수록 병행 수행 수준이 높아진다.  
    ②  로킹 단위가 클수록 로킹 오버헤드가 증가한다.  
    ③  튜플 로킹은 파일 로킹보다 로킹 단위가 크다.  
    ④  데이터베이스 전체 로킹은 병행 수행 수준이 가장 높다.   

59. 데이터 무결성 제약 조건 중 참조 무결성에 대한 설명은?  
    ①  릴레이션에 있는 튜플들이 어떤 속성의 도메인에 지정된 값만 가지도록 하는 것이다.  
    ②  기본키를 구성하는 속성은 NULL 값이나 중복 값을 가질 수 없다.  
    ③  외래키 값은 참조 릴레이션의 기본키 값과 동일해야 한다.  
    ④  데이터베이스에 저장된 데이터가 일관성을 유지하도록 하는 것이다.   

60. 데이터베이스 시스템에서 삽입, 삭제, 갱신 등의 이벤트가 발생할 때, 관련된 작업이 자동으로 수행되는 절차형 SQL은?  
    ①  트리거(Trigger)  
    ②  저장 프로시저(Stored Procedure)  
    ③  함수(Function)  
    ④  뷰(View)   

**4과목: 프로그래밍 언어 활용**  

61. C 언어 프로그램에서 #include <stdio.h> 가 의미하는 것은?  
    ①  표준 입출력 함수를 사용하기 위해 필요한 헤더 파일을 포함한다.  
    ②  수학 함수를 사용하기 위해 필요한 헤더 파일을 포함한다.  
    ③  문자열 처리를 위해 필요한 헤더 파일을 포함한다.  
    ④  메모리 동적 할당을 위해 필요한 헤더 파일을 포함한다.   

62. 다음 C 언어 프로그램의 실행 결과는?  
    ```c
    #include <stdio.h>
    int main(void) {
        int a = 10;
        int b = 20;
        printf("%d", a > b ? a : b);
        return 0;
    }
    ```  
    ①  10  
    ②  20  
    ③  false  
    ④  true  [출처에 조건 연산자 예제는 없으나, C언어 문법 기반 문제 생성]  

63. 다음 C 언어 프로그램의 실행 결과는?  
    ```c
    #include <stdio.h>
    int main(void) {
        int i;
        int sum = 0;
        for (i = 1; i <= 5; i++) {
            sum += i;
        }
        printf("%d", sum);
        return 0;
    }
    ```  
    ①  10  
    ②  15  
    ③  20  
    ④  25  [출처에 유사한 for 루프 예제 있음 - 23]  

64. JAVA 변수 명칭 규칙에 대한 설명으로 옳지 않은 것은?  
    ①  변수 이름은 숫자로 시작할 수 있다.  
    ②  첫 글자는 영문자나 _(under bar), $(dollar)로 시작해야 한다.  
    ③  공백이나 *, -, + 등 특수 문자는 사용할 수 없다.  
    ④  대소문자를 구분한다.   

65. 다음 JAVA 프로그램의 실행 결과는?  
    ```java
    public class Test {
        public static void main(String[] args) {
            int i = 0;
            while (i < 5) {
                System.out.print(i + " ");
                i++;
            }
        }
    }
    ```  
    ①  0 1 2 3 4  
    ②  1 2 3 4 5  
    ③  0 1 2 3 4 5  
    ④  컴파일 오류  [출처에 유사한 while 루프 예제 있음 - 83]  

66. C 언어에서 malloc() 함수에 대한 설명으로 틀린 것은?  
    ①  원하는 크기의 메모리를 동적으로 할당한다.  
    ②  바이트(Byte) 단위로 메모리를 할당한다.  
    ③  할당 실패 시 NULL을 반환한다.  
    ④  할당된 메모리는 사용 후 자동으로 해제된다.   

67. 다음 Python 프로그램의 실행 결과는?  
    ```python
    def func(n):
        sum = 0
        for i in range(n + 1):
            sum += i
        return sum

    result = func(10)
    print(result)
    ```  
    ①  45  
    ②  55  
    ③  66  
    ④  78  [출처에 유사한 Python for 루프 예제 있음 - 75]  

68. IP 프로토콜에 대한 설명으로 틀린 것은?  
    ①  IP 버전 4(IPv4)는 32비트 주소 체계를 사용한다.  
    ②  IP 버전 6(IPv6)는 128비트 주소 체계를 사용한다.  
    ③  IP 프로토콜은 비연결형 프로토콜이다.  
    ④  IP 헤더에는 포트(Port) 번호 정보가 포함된다.   

69. 네트워크 위상 구조 중, 모든 노드가 다른 모든 노드와 직접 연결되어 있는 구조는?  
    ①  Bus  
    ②  Star  
    ③  Mesh  
    ④  Ring   

70. OSI 7계층 중 데이터 링크 계층의 역할로 옳은 것은?  
    ①  네트워크 간 경로 선택  
    ②  물리적 전송 매체를 통한 데이터 전송  
    ③  오류 제어 및 흐름 제어  
    ④  사용자 인터페이스 제공   

71. 다음 중 대칭키 암호화 알고리즘은?  
    ①  AES  
    ②  RSA  
    ③  SHA-256  
    ④  MD5   

72. 비대칭키 암호화 알고리즘은?  
    ①  DES  
    ②  AES  
    ③  RSA  
    ④  SHA-1   

73. 다음 중 네트워크 공격으로, 사용자에게 가짜 웹사이트 접속을 유도하여 개인 정보를 탈취하는 공격은?  
    ①  랜섬웨어(Ransomware)  
    ②  피싱(Phishing)  
    ③  크로스 사이트 스크립팅(XSS)  
    ④  SQL 삽입(SQL Injection)   

74. 다음 중 접근 통제(Access Control) 모델이 아닌 것은?  
    ①  DAC(Discretionary Access Control)  
    ②  MAC(Mandatory Access Control)  
    ③  RBAC(Role-Based Access Control)  
    ④  ABAC(Attribute-Based Access Control)   

75. 인증(Authentication), 인가(Authorization), 계정 관리(Accounting)를 아우르는 정보 보안 개념은?  
    ①  CIA  
    ②  AAA  
    ③  SSL  
    ④  VPN   

76. 네트워크 보안 장비 중, 외부 네트워크로부터 들어오는 유해 트래픽을 차단하거나 탐지하는 장비는?  
    ①  IDS(Intrusion Detection System)  
    ②  IPS(Intrusion Prevention System)  
    ③  Firewall  
    ④  VPN   

77. 다음 중 방화벽(Firewall)에 대한 설명으로 틀린 것은?  
    ①  네트워크 경계에서 접근 제어를 수행한다.  
    ②  패킷의 헤더 정보를 기반으로 필터링할 수 있다.  
    ③  애플리케이션 계층에서 필터링할 수 있다.  
    ④  모든 유형의 네트워크 공격을 완벽하게 방어할 수 있다.  [출처에 직접적인 설명은 없으나, 네트워크 보안 관련 내용에서 추론 가능]  

78. 서비스 거부 공격(DoS, DDoS)의 목적으로 옳은 것은?  
    ①  시스템 관리자 권한 탈취  
    ②  개인 정보 유출  
    ③  서비스 가용성 저해  
    ④  악성 코드 유포  [출처에 직접적인 설명은 없으나, 네트워크 보안 관련 내용에서 추론 가능]  

79. 자동 반복 요청(ARQ) 방식이 아닌 것은?  
    ①  Stop-and-wait ARQ  
    ②  Go-back-N ARQ  
    ③  Selective-Repeat ARQ  
    ④  Non-acknowledgement ARQ   

80. TCP 프로토콜에 대한 설명으로 틀린 것은?  
    ①  신뢰성 있는 데이터 전송을 제공한다.  
    ②  연결 지향 프로토콜이다.  
    ③  데이터 전송 전에 3-way Handshake 과정을 거친다.  
    ④  흐름 제어 기능은 없으나 오류 제어 기능은 제공한다.   

**5과목: 정보시스템 구축 관리**  

81. 정보 시스템 구축 관리의 주요 활동으로 옳지 않은 것은?  
    ①  요구사항 분석  
    ②  시스템 설계  
    ③  프로그램 코딩  
    ④  정보 시스템 운영 및 유지보수  [출처에 정보시스템 구축 관리 과목 내용이 분산되어 있으나, 일반적인 시스템 개발 생명 주기 관점에서 추론 가능]  

82. 프로젝트 일정 관리에 사용되는 기법으로, 작업들 간의 의존 관계와 순서를 나타내는 네트워크 다이어그램을 사용하는 기법은?  
    ①  간트 차트(Gantt Chart)  
    ②  PERT/CPM  
    ③  WBS(Work Breakdown Structure)  
    ④  베이스라인(Baseline)   

83. WBS(Work Breakdown Structure)에 대한 설명으로 옳은 것은?  
    ①  프로젝트 작업을 계층 구조로 분해한 것이다.  
    ②  작업 간의 의존 관계를 나타내는 데 사용된다.  
    ③  프로젝트 일정을 관리하는 데 주로 사용된다.  
    ④  각 작업에 소요되는 시간 추정에 사용된다.  [출처에 직접적인 설명은 없으나, 프로젝트 관리 관련 내용에서 추론 가능]  

84. COCOMO 모델에서 프로젝트의 복잡도에 따라 산정 방식이 달라지는 모형은?  
    ①  조직형(Organic)  
    ②  반분리형(Semi-detached)  
    ③  임베디드형(Embedded)  
    ④  모두 해당   

85. 소프트웨어 개발 비용 산정 기법 중, 과거 유사 프로젝트의 경험을 바탕으로 전문가들이 모여 비용을 산정하는 기법은?  
    ①  하향식 산정 기법  
    ②  상향식 산정 기법  
    ③  델파이 기법(Delphi Technique)  
    ④  코코모 모델  [출처에 직접적인 설명은 없으나, 비용 산정 관련 내용에서 추론 가능]  

86. CASE(Computer-Aided Software Engineering) 도구에 대한 설명으로 틀린 것은?  
    ①  소프트웨어 개발 과정의 전반적인 활동을 지원한다.  
    ②  요구사항 분석, 설계, 구현, 테스트 등 다양한 단계에서 활용된다.  
    ③  작업 자동화 및 정보 공유를 통해 생산성을 향상시킨다.  
    ④  주로 문서 작성에 특화되어 있으며, 코딩 지원 기능은 약하다.   

87. 정보 시스템 구축 관리에서 중요한 고려 사항으로 옳지 않은 것은?  
    ①  사용자의 요구사항 만족  
    ②  프로젝트 예산 및 일정 준수  
    ③  기술적 타당성 확보  
    ④  개발자의 개인적 선호도 반영  [출처에 정보시스템 구축 관리 과목 내용이 분산되어 있으나, 일반적인 시스템 개발 관점에서 추론 가능]  

88. 소프트웨어 개발 생명 주기 모델 중 가장 오래된 모형으로, 폭포수(Waterfall)처럼 각 단계가 순차적으로 진행되는 모형은?  
    ①  프로토타이핑 모델  
    ②  나선형 모델(Spiral Model)  
    ③  폭포수 모델(Waterfall Model)  
    ④  애자일 모델(Agile Model)   

89. 나선형 모델(Spiral Model)에 대한 설명으로 틀린 것은?  
    ①  위험 분석 단계를 통해 위험 요소를 관리한다.  
    ②  여러 개발 단계를 반복적으로 수행하는 점진적 개발 모델이다.  
    ③  폭포수 모델과 프로토타이핑 모델의 장점을 결합했다.  
    ④  소규모 프로젝트에 적합하며, 개발 초기에 위험 분석이 필요 없다.   

90. 컴포넌트 기반 개발(CBD: Component Based Development)에 대한 설명으로 옳은 것은?  
    ①  미리 개발된 컴포넌트를 조립하여 응용 소프트웨어를 개발한다.  
    ②  생산성 향상 및 유지보수 비용 감소에 기여한다.  
    ③  재사용 가능한 컴포넌트를 활용하여 개발 기간을 단축한다.  
    ④  모두 해당   

91. 정보시스템 구축 시, 물리적인 저장 장치를 논리적으로 연결하여 효율적으로 관리하는 네트워크 시스템은?  
    ①  LAN  
    ②  WAN  
    ③  SAN(Storage Area Network)  
    ④  NAS(Network Attached Storage)   

92. 소프트웨어 정의 네트워크(SDN: Software Defined Networking)에 대한 설명으로 틀린 것은?  
    ①  제어부와 데이터부를 분리하여 네트워크 관리를 유연하게 한다.  
    ②  프로그래밍 가능한 네트워크를 통해 네트워크 기능을 제어한다.  
    ③  중앙 집중식 제어가 가능하다.  
    ④  네트워크 장비의 하드웨어 의존성을 높인다.   

93. 정보 시스템 운영 단계의 주요 활동으로 옳지 않은 것은?  
    ①  시스템 감시 및 제어  
    ②  백업 및 복구  
    ③  성능 관리 및 튜닝  
    ④  시스템 설계 변경  [출처에 정보시스템 구축 관리 과목 내용이 분산되어 있으나, 일반적인 시스템 운영 관점에서 추론 가능]  

94. 프로젝트 관리에서 사용되는 PERT 기법의 설명으로 옳은 것은?  
    ①  각 작업에 필요한 자원 분배에 초점을 맞춘다.  
    ②  작업 간의 시간적 여유(Slack) 계산에 사용된다.  
    ③  작업들의 완료 시간을 예측하는 데 사용되는 기법이다.  
    ④  주로 대규모 프로젝트의 비용 관리에 사용된다.   

95. 정보 시스템 보안 측면에서, 시스템 내의 정보 자원을 허가된 사용자에게만 접근하도록 통제하는 것은?  
    ①  기밀성(Confidentiality)  
    ②  무결성(Integrity)  
    ③  가용성(Availability)  
    ④  접근 통제(Access Control)   

96. 소프트웨어 아키텍처 설계에서, 각 모듈의 기능이 서로 관련이 적고 독립적인 정도를 나타내는 것은?  
    ①  결합도(Coupling)  
    ②  응집도(Cohesion)  
    ③  복잡도(Complexity)  
    ④  재사용성(Reusability)   

97. 응집도(Cohesion) 종류 중, 모듈 내부의 요소들이 한 기능을 순차적으로 수행할 경우의 응집도는?  
    ①  기능적 응집도(Functional Cohesion)  
    ②  절차적 응집도(Procedural Cohesion)  
    ③  시간적 응집도(Temporal Cohesion)  
    ④  논리적 응집도(Logical Cohesion)   

98. 결합도(Coupling) 종류 중, 모듈 간의 인터페이스가 단순한 데이터 요소 전달로만 이루어진 경우의 결합도는?  
    ①  자료 결합도(Data Coupling)  
    ②  스탬프 결합도(Stamp Coupling)  
    ③  제어 결합도(Control Coupling)  
    ④  외부 결합도(External Coupling)   

99. 소프트웨어 개발 방법론 중, 소규모 팀에 적합하며 변화에 유연하게 대처하고 고객과의 지속적인 소통을 강조하는 방법론은?  
    ①  폭포수 모델(Waterfall Model)  
    ②  나선형 모델(Spiral Model)  
    ③  애자일 방법론(Agile Methodology)  
    ④  V 모델   

100. 다음 중 소프트웨어 생명 주기 모델이 아닌 것은?  
    ①  폭포수 모델(Waterfall Model)  
    ②  나선형 모델(Spiral Model)  
    ③  객체 모델링(Object Modeling)  
    ④  프로토타이핑 모델(Prototyping Model)   

---

**정답 및 해설**  

1.  ①   **해설:** 애자일 방법론은 계획과 프로세스보다 사람과 소통을, 문서보다 동작하는 소프트웨어를, 계약 협상보다 고객 협력을, 계획 준수보다 변화 대응을 중요하게 생각합니다.  
2.  ④   **해설:** XP의 5가지 핵심 가치는 의사소통, 단순성, 용기, 존중, 피드백입니다. 생명 분석은 XP의 핵심 가치에 해당하지 않습니다.  
3.  ④   **해설:** 자료 흐름도(DFD)에서 단말(Terminator)은 사각형으로 표기됩니다. 오각형은 상태 다이어그램에서 사용될 수 있습니다.  
4.  ②   **해설:** HIPO는 하향식 소프트웨어 개발을 위한 문서화 도구입니다. 상향식 개발과는 반대 방향입니다.  
5.  ①   **해설:** 상태 다이어그램에서 객체의 상태 변화(transition)는 이벤트(event)에 의해 촉발됩니다.  
6.  ①   **해설:** UML 모델에서 스테레오 타입은 길쌈 괄호(< >) 안에 이름을 넣어 표현합니다.  
7.  ③   **해설:** 객체 생성 인터페이스를 정의하고, 실제 인스턴스화는 서브클래스에 맡기는 것은 Factory Method 패턴의 설명입니다.  
8.  ①   **해설:** Observer 패턴은 객체 상태 변화에 따른 행위를 정의하는 패턴으로, 생성 패턴이 아닌 행위(Behavioral) 패턴에 속합니다.  
9.  ④   **해설:** RPC는 원격 프로시저 호출 방식의 미들웨어이며, 코바(CORBA)는 객체 지향 분산 환경 표준입니다. RPC 자체가 CORBA 표준을 구현하는 미들웨어는 아닙니다.  
10. ①   **해설:** 제시된 설명은 소프트웨어 개발 전반의 과정을 지원하고 자동화하는 CASE 도구에 해당합니다. CASE 도구는 생산성 및 재사용성 향상에 기여합니다.  
11. ④   **해설:** 화이트박스 테스트는 프로그램의 내부 구조를 기반으로 테스트 케이스를 설계하지만, 현실적으로 모든 모듈의 모든 경로를 완벽하게 테스트하기는 어렵습니다.  
12. ④   **해설:** 데이터 흐름 검사는 변수의 정의 및 사용 위치에 초점을 맞추는 화이트박스 테스트 기법입니다.  
13. ③   **해설:** 사용자 인터뷰, 설문 조사, 래피드 프로토타이핑은 요구사항 도출 단계에서 사용되는 주요 기법입니다. 사용자 교육은 시스템 사용법을 가르치는 활동으로 요구사항 도출과는 거리가 있습니다.  
14. ①   **해설:** 제시된 1번 보기는 XP의 특징입니다. 프로토타이핑 모델은 요구사항 파악을 위해 시제품을 만들고 수정하는 과정을 반복합니다.  
15. ③   **해설:** UI 설계 원칙 중 직관성(Intuitiveness)은 사용자가 별도의 학습 없이도 쉽게 사용하고 이해할 수 있도록 하는 원칙입니다.  
16. ④   **해설:** SOLID 원칙은 객체지향 설계의 5가지 원칙으로, SSO(Single Sign On)는 사용자 인증과 관련된 기술입니다.  
17. ②   **해설:** Dependency 관계는 한 클래스의 명세가 바뀌면 다른 클래스에 영향을 주는 관계를 나타냅니다.  
18. ③   **해설:** Liskov Substitution Principle (LSP)은 부모 클래스의 객체 대신 자식 클래스의 객체를 사용해도 프로그램의 기능이 올바르게 동작해야 한다는 원칙입니다. 이는 서브 클래스가 슈퍼 클래스의 행위를 확장하되 변경하지 않아야 함을 의미합니다.  
19. ②   **해설:** 클린 코드의 단순성 원칙은 복잡도를 최소화하는 것을 목표로 합니다. 최대한 낮추는 것보다 더 적극적인 개념입니다.  
20. ①   **해설:** Rumbaugh 방법론에서 기능 모델링은 시스템의 기능과 프로세스를 자료 흐름도(DFD)를 이용해 표현합니다.  
21. ①   **해설:** 짝 프로그래밍은 두 명의 개발자가 함께 하나의 작업을 수행하며 서로 협력하고 검토하여 품질을 높이는 방식입니다. 독립적인 코딩과는 반대되는 개념입니다.  
22. ④   **해설:** 형상 관리는 소프트웨어 개발 과정에서 생성되는 산출물(소스 코드, 설계 문서, 요구사항 명세서 등)의 변경을 관리하지만, 프로젝트 진행 비용 자체는 관리 대상이 아닙니다.  
23. ②   **해설:** 소프트웨어 형상 관리(Configuration Management)는 소프트웨어의 변경 사항을 체계적으로 관리하는 일련의 활동입니다.  
24. ④   **해설:** Commit은 변경된 파일을 로컬 저장소에 저장하고 변경 이력을 기록하는 작업입니다.  
25. ④   **해설:** Rollback은 형상 관리 시스템에서 이전 상태로 되돌리는 작업입니다.  
26. ①   **해설:** 블랙박스 테스트는 프로그램의 내부 구조를 알지 못하고 외부 기능이나 명세에 따라 테스트합니다.  
27. ②   **해설:** 명세 기반 테스트는 소프트웨어 요구사항 명세(Specification)를 기반으로 테스트 케이스를 설계합니다.  
28. ③   **해설:** 기초 경로 검사는 프로그램의 제어 흐름을 분석하여 테스트 경로를 설정하는 화이트박스 테스트 기법입니다. 동등 분할 기법, 경계값 분석, 오류 추정 기법은 블랙박스 테스트 기법입니다.  
29. ③   **해설:** 결함 주입 기법은 일부러 오류를 시스템에 넣어보고 오류 처리 과정을 테스트하는 기법으로, 블랙박스 테스트 기법으로 분류되지 않습니다.  
30. ④   **해설:** ESB(Enterprise Service Bus), xUnit, STAF는 구현 또는 테스트 단계에서 사용될 수 있는 도구입니다. NTAF는 테스트 프레임워크의 종류로, 다른 도구들과 성격이 다릅니다.  
31. ④   **해설:** Selenium은 웹 애플리케이션 테스트 자동화 프레임워크로, 단위 테스트부터 시스템 테스트까지 다양한 수준에서 활용될 수 있습니다.  
32. ②   **해설:** 하향식 통합 테스트의 너비 우선(Breadth First) 방식에서는 최상위 모듈 아래의 모든 하위 모듈을 스텁(Stub)으로 대체하고 테스트합니다. 깊이 우선(Depth First) 방식에서는 특정 경로를 따라 하위 모듈을 통합합니다.  
33. ③   **해설:** 파레토의 법칙(Pareto's Principle) 또는 80/20 법칙은 많은 결과의 80%가 원인의 20%에서 비롯된다는 법칙으로, 소프트웨어 오류의 80%가 20%의 모듈에서 발생한다는 경험적 사실에 적용될 수 있습니다.  
34. ③   **해설:** 검증(Verification)은 "제품이 명세대로 만들어졌는가?" (Are we building the product right?)를 확인하는 과정입니다.  
35. ①  [출처에 직접적인 설명은 없으나, 테스트 관련 내용에서 추론 가능]  **해설:** 회귀 테스트(Regression Test)는 수정된 소프트웨어 모듈이 기존 기능에 영향을 주지 않고 정상적으로 동작하는지 확인하기 위해 수행하는 테스트입니다.  
36. ①   **해설:** 기능성(Functionality)은 소프트웨어가 명세된 요구사항을 얼마나 잘 수행하는지와 관련된 품질 목표입니다.  
37. ①   **해설:** V 모델에서는 각 개발 단계(요구 분석, 설계, 구현)와 그에 해당하는 테스트 단계가 명확하게 연결되어 있으며, 단계별로 순차적으로 진행됩니다.  
38. ③   **해설:** XP는 짧은 반복 주기(Iteration)를 통해 고객에게 동작하는 소프트웨어를 빠르게 제공하고 피드백을 받아 다음 반복에 반영하는 것을 중요하게 생각합니다.  
39. ③   **해설:** 클린 코드의 원칙 중 의존성(Dependency)은 모듈 간의 의존 관계를 최소화하여 한 모듈의 변경이 다른 모듈에 미치는 영향을 줄이는 것입니다.  
40. ②   **해설:** 동등 분할 기법은 블랙박스 테스트 기법입니다.  
41. ④   **해설:** 관계 데이터 모델에서 릴레이션 내의 속성(Column)은 순서에 의미를 두지 않습니다. 튜플(Row)의 순서도 일반적으로 의미를 두지 않습니다.  
42. ③   **해설:** CREATE는 데이터 정의어(DDL)입니다. SELECT, UPDATE, DELETE는 데이터 조작어(DML)입니다.  
43. ①   **해설:** 생성된 테이블의 속성 타입을 변경하는 것은 ALTER TABLE 문을 사용합니다. CREATE TABLE 문에서는 테이블 생성 시 속성을 정의합니다.  
44. ①   **해설:** WHERE 절의 조건(학번 = '1001')을 만족하는 학생은 '이길수'이며, 이 학생의 학과는 'CD'입니다.  
45. ④   **해설:** 외래키(Foreign Key)는 다른 릴레이션의 기본키를 참조하며, 이 참조 관계를 통해 참조 무결성 제약조건을 유지합니다.  
46. ④   **해설:** SELECT(σ), PROJECT(π), JOIN(⋈)은 관계 대수 연산의 기본 연산 또는 확장 연산입니다. DIVISION(÷)도 관계 대수 연산에 속합니다. 다만, 문제의 의도에 따라 자주 사용되는 기본 연산 그룹에서 DIVISION을 제외하는 경우도 있습니다. 주어진 소스에서는 PROJECT, SELECT, JOIN, DIVISION 모두 관계 대수 연산으로 언급하고 있습니다.  
47. ④   **해설:** 관계 데이터 언어는 관계 대수 또는 관계 해석을 기반으로 데이터베이스를 조작하는 언어입니다. SQL이 대표적인 관계 데이터 언어입니다.  
48. ③   **해설:** 병행 투명성(Concurrency Transparency)은 여러 트랜잭션이 동시에 실행되어도 그 실행 결과가 일관되게 유지되는 것을 의미합니다.  
49. ③   **해설:** 분산 데이터베이스 시스템은 데이터가 여러 컴퓨터에 분산되어 저장되지만, 사용자 입장에서는 하나의 논리적인 데이터베이스처럼 보이게 합니다.  
50. ②   **해설:** 제1정규형에서 제2정규형으로 이행하려면 부분 함수 종속(Partial Dependency)을 제거해야 합니다. 즉, 기본키의 일부에만 종속되는 속성이 없어야 합니다.  
51. ④   **해설:** 주어진 보기 중에서 BCNF(Boyce-Codd Normal Form)가 가장 높은 정규형 단계입니다. BCNF는 결정자이면서 후보키가 아닌 함수 종속을 제거한 형태입니다.  
52. ①   **해설:** 개체 무결성 제약조건은 기본키를 구성하는 속성은 NULL 값이나 중복 값을 가질 수 없음을 보장하여 각 튜플의 유일성을 보장합니다.  
53. ②   **해설:** DAS(Direct Attached Storage)는 서버와 저장 장치를 전용 케이블로 직접 연결하는 방식으로, 속도가 빠르고 구성이 간단합니다.  
54. ④   **해설:** 인덱스는 사용자가 CREATE INDEX 문 등을 사용하여 직접 생성할 수 있습니다. DBMS가 내부적으로 관리하는 시스템 인덱스도 있습니다.  
55. ④   **해설:** 데이터 삽입 시 릴레이션 재생성 필요성을 줄이는 것은 정규화의 직접적인 목적이 아니라, 이상 현상(Anomaly)을 방지하는 과정에서 자연스럽게 얻어지는 효과일 수 있습니다.  
56. [출처에 직접적인 설명은 없으나, ER 모델 및 관계형 모델 설명과 비교하여 추론 가능]  **해설:** 객체-관계 데이터 모델은 객체 지향 모델과 관계형 모델의 장점을 결합한 모델입니다. 일반적으로 객체는 속성, 메소드, 식별자를 가지며, 관계는 릴레이션을 통해 표현됩니다. 보기 4번은 객체 지향 모델의 객체 특징에 해당합니다.  
57. ④   **해설:** 뷰(View)는 물리적으로 존재하지 않는 가상 테이블이기 때문에 독립적인 인덱스를 가질 수 없습니다.  
58. ①   **해설:** 로킹 단위가 작을수록 여러 트랜잭션이 동시에 접근할 수 있는 데이터 단위의 범위가 좁아져 병행 수행 수준이 높아집니다.  
59. ③   **해설:** 참조 무결성(Referential Integrity)은 외래키 값이 참조 릴레이션의 기본키 값 또는 NULL 값을 가져야 한다는 제약조건입니다.  
60. ①   **해설:** 트리거(Trigger)는 특정 이벤트(INSERT, DELETE, UPDATE 등)가 발생했을 때 자동으로 수행되는 데이터베이스 객체입니다.  
61. ①   **해설:** `#include <stdio.h>`는 표준 입출력 라이브러리 함수(printf, scanf 등)를 사용하기 위해 필요한 헤더 파일을 포함하는 전처리 지시문입니다.  
62. ②  [출처에 조건 연산자 예제는 없으나, C언어 문법 기반 문제 생성]  **해설:** `(a > b ? a : b)`는 조건 연산자로, 조건 `a > b`가 참이면 `a`의 값을, 거짓이면 `b`의 값을 반환합니다. `10 > 20`은 거짓이므로 `b`의 값인 20이 출력됩니다.  
63. ②   **해설:** for 루프는 i가 1부터 5까지 반복하며 sum에 i 값을 누적합니다. sum = 1+2+3+4+5 = 15가 됩니다.  
64. ①   **해설:** JAVA 변수 이름은 영문자, $, _ 로 시작해야 하며 숫자로 시작할 수 없습니다.  
65. ①   **해설:** while 루프는 i가 0부터 시작하여 i < 5 조건이 참인 동안 반복합니다. 각 반복에서 i 값을 출력하고 i를 1 증가시킵니다. 따라서 0, 1, 2, 3, 4가 공백으로 구분되어 출력됩니다.  
66. ④   **해설:** malloc() 함수로 할당받은 동적 메모리는 사용 후 반드시 free() 함수를 호출하여 명시적으로 해제해야 합니다.  
67. ②   **해설:** Python의 `range(n+1)`는 0부터 n까지의 정수 시퀀스를 생성합니다. `func(10)`은 `range(11)` (0부터 10)의 합을 계산하므로, 0부터 10까지의 합인 55가 반환됩니다.  
68. ④   **해설:** IP 헤더에는 출발지 IP, 목적지 IP, 프로토콜 타입, TTL 등의 정보가 포함되지만, 포트 번호는 상위 계층인 TCP 또는 UDP 헤더에 포함됩니다.  
69. ③   **해설:** Mesh 토폴로지는 네트워크의 모든 장치가 다른 모든 장치와 1:1로 연결된 구조입니다.  
70. ③   **해설:** OSI 7계층 중 데이터 링크 계층은 인접한 노드 간의 데이터 전송을 담당하며, 프레임 구성, 오류 제어, 흐름 제어 등의 기능을 수행합니다.  
71. ①   **해설:** AES(Advanced Encryption Standard)는 대칭키 암호화 알고리즘의 대표적인 예입니다.  
72. ③   **해설:** RSA는 공개키(비대칭키) 암호화 알고리즘입니다.  
73. ②   **해설:** 피싱(Phishing)은 사용자를 속여 개인 정보를 탈취하는 사회 공학적 공격 기법입니다.  
74. ④   **해설:** DAC, MAC, RBAC는 전통적인 접근 통제 모델입니다. ABAC는 속성 기반의 최신 접근 통제 모델입니다. 주어진 보기 중 ABAC는 다른 모델들과 성격이 다르거나 언급되지 않은 모델일 수 있습니다.  
75. ②   **해설:** AAA는 인증(Authentication), 인가(Authorization), 계정 관리(Accounting)의 약자로, 정보 보안에서 사용자의 접근 및 활동을 관리하는 핵심 개념입니다.  
76. ③   **해설:** 방화벽(Firewall)은 네트워크 경계에 설치되어 미리 정의된 보안 정책에 따라 외부로부터의 침입을 막거나 내부 네트워크를 보호하는 역할을 합니다.  
77. ④  [출처에 직접적인 설명은 없으나, 네트워크 보안 관련 내용에서 추론 가능]  **해설:** 방화벽은 다양한 공격을 막을 수 있지만, 알려지지 않은 공격이나 내부에서의 공격에는 취약할 수 있으며 모든 공격을 완벽하게 막지는 못합니다.  
78. ③  [출처에 직접적인 설명은 없으나, 네트워크 보안 관련 내용에서 추론 가능]  **해설:** 서비스 거부 공격(DoS/DDoS)은 시스템의 자원을 과부하시켜 정상적인 사용자가 서비스를 이용할 수 없도록 방해하는 공격입니다.  
79. ④   **해설:** ARQ 방식은 오류가 발생했을 때 재전송을 통해 신뢰성을 확보하는 방식입니다. Non-acknowledgement ARQ는 이러한 재전송 메커니즘을 포함하지 않습니다.  
80. ④   **해설:** TCP는 연결 지향, 신뢰성 있는 데이터 전송, 흐름 제어, 오류 제어 기능을 모두 제공합니다.  
81. ③  [출처에 정보시스템 구축 관리 과목 내용이 분산되어 있으나, 일반적인 시스템 개발 생명 주기 관점에서 추론 가능]  **해설:** 정보 시스템 구축 관리는 주로 프로젝트 관리, 품질 관리, 형상 관리, 위험 관리 등 관리 활동에 초점을 맞춥니다. 프로그램 코딩은 개발 단계의 실제 구현 활동입니다.  
82. ②   **해설:** PERT(Program Evaluation and Review Technique)와 CPM(Critical Path Method)은 네트워크 다이어그램을 사용하여 작업 간의 의존 관계를 파악하고 일정을 관리하는 프로젝트 관리 기법입니다.  
83. ①  [출처에 직접적인 설명은 없으나, 프로젝트 관리 관련 내용에서 추론 가능]  **해설:** WBS(Work Breakdown Structure)는 프로젝트의 전체 범위를 계층 구조로 분해하여 관리 가능한 단위로 나누는 도구입니다.  
84. ④   **해설:** COCOMO 모델은 프로젝트의 규모와 복잡성에 따라 조직형, 반분리형, 임베디드형의 세 가지 모형으로 나누어 비용을 산정하며, 각 모형에 따라 비용 산정 방식이 다릅니다.  
85. ③  [출처에 직접적인 설명은 없으나, 비용 산정 관련 내용에서 추론 가능]  **해설:** 델파이 기법은 전문가들의 의견을 반복적으로 수렴하여 합의된 비용을 산정하는 전문가 판단 기법입니다.  
86. ④   **해설:** CASE 도구는 소프트웨어 개발 전반의 과정을 지원하며, 문서 작성 외에도 설계, 코드 생성, 테스트 등 다양한 기능을 자동화하여 생산성을 높입니다.  
87. ④  [출처에 정보시스템 구축 관리 과목 내용이 분산되어 있으나, 일반적인 시스템 개발 관점에서 추론 가능]  **해설:** 정보 시스템 구축 관리에서는 프로젝트의 성공적인 완수를 위해 사용자의 요구사항, 예산, 일정, 기술 등을 종합적으로 고려하며, 개발자의 개인적 선호도보다는 프로젝트 목표 달성을 우선시합니다.  
88. ③   **해설:** 폭포수 모델(Waterfall Model)은 요구사항 분석, 설계, 구현, 테스트, 유지보수 단계가 순차적으로 진행되는 가장 전통적인 개발 생명 주기 모델입니다.  
89. ④   **해설:** 나선형 모델은 위험 관리를 핵심 요소로 하며 개발 초기에 위험 분석을 수행합니다. 소규모 프로젝트보다는 대규모 프로젝트에 더 적합합니다.  
90. ④   **해설:** 컴포넌트 기반 개발(CBD)은 미리 개발된 컴포넌트를 조립하여 소프트웨어를 개발하는 방식으로, 생산성, 재사용성, 유지보수성 향상에 기여합니다.  
91. ③   **해설:** SAN(Storage Area Network)은 서버와 저장 장치를 네트워크로 연결하여 데이터 저장 관리를 중앙 집중화하고 고속의 데이터 접근을 가능하게 하는 시스템입니다.  
92. ④   **해설:** SDN은 제어부와 데이터부를 분리하고 제어 기능을 소프트웨어화하여 네트워크 장비의 하드웨어 종속성을 낮추고 유연한 네트워크 관리를 가능하게 합니다.  
93. ④  [출처에 정보시스템 구축 관리 과목 내용이 분산되어 있으나, 일반적인 시스템 운영 관점에서 추론 가능]  **해설:** 시스템 운영 단계는 시스템 감시, 백업, 복구, 성능 관리, 장애 처리 등 운영과 관련된 활동을 주로 수행합니다. 시스템 설계 변경은 주로 개선 또는 재개발 단계에서 이루어집니다.  
94. ③   **해설:** PERT 기법은 비관치, 낙관치, 기대치를 사용하여 작업 시간을 산정하고 프로젝트의 예상 완료 시간을 확률적으로 예측하는 데 사용됩니다.  
95. ④   **해설:** 접근 통제(Access Control)는 정보 시스템의 자원에 대한 사용자의 접근 권한을 제어하여 허가되지 않은 접근을 방지하는 보안 기능입니다.  
96. ②   **해설:** 응집도(Cohesion)는 모듈 내부 요소들의 관련 정도를 나타냅니다. 응집도가 높을수록 모듈이 하나의 기능을 잘 수행하며 독립성이 높아져 좋은 설계로 간주됩니다.  
97. ②   **해설:** 절차적 응집도(Procedural Cohesion)는 모듈 내부 요소들이 특정 순서에 따라 작업을 수행하는 경우의 응집도입니다.  
98. ①   **해설:** 자료 결합도(Data Coupling)는 모듈 간의 인터페이스가 단순한 데이터 요소 전달로만 이루어진 가장 낮은 수준의 결합도입니다.  
99. ③   **해설:** 애자일 방법론은 짧은 개발 주기, 고객과의 소통, 변화에 유연한 대처, 동작하는 소프트웨어의 빠른 제공을 특징으로 하며, 소규모 팀에 적합합니다.  
100. ③   **해설:** 폭포수 모델, 나선형 모델, 프로토타이핑 모델은 소프트웨어 개발 생명 주기 모델입니다. 객체 모델링은 시스템 분석 및 설계를 위한 모델링 기법입니다.
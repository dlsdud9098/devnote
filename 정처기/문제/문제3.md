## 정보처리기사 기출문제 (2021년 ~ 2024년)

**1과목 소프트웨어 설계**

1.  다음 중 애자일(Agile) 소프트웨어 개발에 대한 설명으로 **틀린** 것은?  
    ① 공정과 도구보다 개인과 상호작용을 더 가치 있게 여긴다.  
    ② 동작하는 소프트웨어보다는 포괄적인 문서를 더 가치 있게 여긴다.  
    ③ 계약 협상보다는 고객과의 협력을 더 가치 있게 여긴다.  
    ④ 계획을 따르기보다는 변화에 대응하기를 더 가치 있게 여긴다.  
   

2.  HIPO(Hierarchy Input Process Output)에 대한 설명으로 옳은 것은?  
    ① 상향식 소프트웨어 개발을 위한 문서화 도구이다.  
    ② HIPO 차트 종류에는 가시적 도표, 총체적 도표, 세부적 도표가 있다.  
    ③ 기능과 자료의 관련 관계를 표현할 수 있다.  
    ④ 보기 쉽고 이해하기 어렵다.  
   

3.  다음 중 디자인 패턴에 해당되지 **않는** 것은?  
    ① Observer  
    ② Decorator  
    ③ Adapter  
    ④ Proxy  
   

4.  트리(Tree)에 대한 설명으로 **틀린** 것은?  
    ① 루트 노드(Root Node): 트리의 맨 위에 있는 노드  
    ② 단말 노드(Terminal Node): 자식이 하나도 없는 노드, 즉 차수가 0인 노드  
    ③ 차수(Degree): 노드의 단말 노드 수를 말한다.  
    ④ 트리의 차수: 트리 내의 모든 노드 중에서 차수가 가장 큰 노드의 차수  
   

5.  프로토타이핑 모형(Prototyping Model)에 대한 설명으로 옳지 **않은** 것은?  
    ① 설계 단계는 소프트웨어에 대한 일반적인(Generic) 모형을 만들어 최종 결과물을 예측하는 모형이다.  
    ② 의뢰자나 개발자 모두에게 공동의 참조 모델을 제공한다.  
    ③ 프로토타이핑이 진행되는 과정에서 새로운 요구사항이 도출되지 않아도 된다.  
    ④ 단기간 제작 목적으로 하여 비효율적인 언어나 알고리즘을 사용할 수 있다.  
   

6.  다음 중 스크럼(Scrum)에 대한 설명으로 **잘못된** 것은?  
    ① 스크럼은 제품 책임자(Product Owner), 스크럼 마스터(Scrum Master), 개발팀(Development Team)으로 구성된다.  
    ② 스프린트 회고를 통해 개선할 점은 없는지 등을 확인하여 기록한다.  
    ③ 스크럼 이벤트에는 스프린트 계획 회의, 일별 스크럼 회의, 스프린트 회고, 스프린트 검토 회의가 있다.  
    ④ 스크럼 마스터는 스크럼 팀이 목표를 달성하도록 지시하는 역할을 한다.  
   

7.  다음 중 비기능 요구사항(Nonfunctional Requirements)에 대한 설명으로 옳은 것은?  
    ① 시스템 처리량(Throughput), 반응 시간 등의 성능 요구 사항은 비기능 요구사항에 해당된다.  
    ② 시스템이 제공하는 모든 화면은 3초 이내에 사용자에게 보여야 한다는 비기능 요구사항이다.  
    ③ 시스템 구축과 관련된 보안, 안전에 대한 사항은 비기능 요구사항에 해당된다.  
    ④ 금융 시스템은 조회, 입금, 출금 기능이 있어야 한다는 비기능 요구사항이다.  
   

8.  UI 설계 원칙 중 누구나 쉽게 이해하고 사용할 수 있어야 한다는 원칙은?  
    ① 최소성  
    ② 유연성  
    ③ 직관성  
    ④ 만족성  
   

9.  다음 중 SOLID 원칙에 속하지 **않는** 것은?  
    ① ISP(Interface Segregation Principle)  
    ② LSP(Liskov Substitution Principle)  
    ③ DIP(Dependency Injection Principle)  
    ④ SSO(Single Sign On)  
   

10. UML 모델에서 한 사물의 명세가 바뀌면 다른 사물에 영향을 주며, 일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 매개 변수나 리턴 값으로 사용하는 경우에 나타나는 관계는?  
    ① Association  
    ② Dependency  
    ③ Realization  
    ④ Generalization  
   

11. 다음 중 객체 지향 프로그래밍에서 데이터가 추상화되는 단위로 옳은 것은?  
    ① 메소드  
    ② 클래스  
    ③ 상속성  
    ④ 메시지  
   

12. 다음 중 GoF(Gang of Four)의 디자인 패턴에서 생성(Creational) 패턴에 속하는 것은?  
    ① Builder  
    ② Visitor  
    ③ Prototype  
    ④ Bridge  
   

13. 소프트웨어 아키텍처 설계 중 **MVC(Model-View-Controller)**와 관련한 설명으로 **틀린** 것은?  
    ① MVC 모델은 사용자 인터페이스를 담당하는 계층의 응집도를 높일 수 있고, 여러 개의 다른 UI를 만들어 그 사이에 결합도를 낮출 수 있다.  
    ② 모델(Model)은 뷰(View)와 제어기(Controller) 사이에서 정보의 접근을 담당하며, 뷰와 제어기에게 모델의 변화를 알려준다.  
    ③ 뷰(View)는 모델(Model)에 있는 데이터를 사용자 인터페이스에 보이는 형태로 담당한다.  
    ④ 제어기(Controller)는 모델(Model)에 명령을 보냄으로써 모델의 상태를 변경할 수 있다.  
   

14. 요구사항 검증(Requirements Validation)에 대한 설명으로 **틀린** 것은?  
    ① 요구사항 검증은 정해진 원칙을 따르는 시스템을 개발하기 위한 필수 과정이다.  
    ② 개발 완료 후에 문제점이 발견된 경우 막대한 재작업 비용이 들 수 있기 때문에 요구사항 검증은 매우 중요하다.  
    ③ 요구사항은 실제로 요구사항 정의 및 변경 사항 등을 관리하는 도구를 사용해야 한다.  
    ④ 요구사항 검증 과정을 통해 모든 요구사항 문제를 발견할 수 있다.  
   

15. 다음 중 Rumbaugh 객체 분석 기법에 대한 설명으로 **틀린** 것은?  
    ① 기능 모델링(Functional Modeling): 자료 흐름도(DFD)를 이용하여 다수의 프로세스 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링이다.  
    ② 동적 모델링(Dynamic Modeling): 상태 다이어그램(State Diagram)을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 정보 흐름, 동작 순서 등을 표현한 모델링이다.  
    ③ 객체 모델링(Object Modeling): 객체 다이어그램(Object Diagram)을 이용하여 시스템에서 요구하는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것이다.  
    ④ 분석 활동의 세 가지 모델 중 가장 중요하며 선행되어야 할 모델링이다.  
   

16. 다음 중 순차 다이어그램(Sequence Diagram)에 대한 설명으로 **틀린** 것은?  
    ① 객체들 간의 상호 작용을 나타내기 위해 사용한다.  
    ② 시간의 흐름에 따라 객체들이 주고 받는 메시지의 전달 과정을 강조한다.  
    ③ 동적 다이어그램보다는 정적 다이어그램에 가깝다.  
    ④ 교류 다이어그램(Interaction Diagram)의 한 종류로 볼 수 있다.  
   

17. 소프트웨어 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동을 뜻하는 것은?  
    ① 복호화  
    ② 형상 관리  
    ③ 저작권  
    ④ 크랙  
   

18. 다음은 워크스루(Walkthrough)에 대한 설명이다. 거리가 **먼** 것은?  
    ① 사후 검토를 통하여 잠재적인 문제점을 찾아낸다.  
    ② 전문가 또는 검토팀이 설명하면서 검토를 진행한다.  
    ③ 오류를 조기에 발견하여 개발 비용을 절감한다.  
    ④ 발견된 오류를 수정하고 다음 단계로 넘어간다.  
   

19. 다음 중 클린 코드(Clean Code) 작성 원칙에 대한 설명으로 **틀린** 것은?  
    ① 가독성이 좋다.  
    ② 중복 코드를 최대한 제거한다.  
    ③ 누구나 쉽게 읽을 수 있도록 작성한다.  
    ④ 간단하게 작성한다.  
   

20. 객체 지향 기법에서 클래스들 사이의 '부분-전체(Part-Whole)' 관계 또는 '부분(is-a-part-of)'의 관계로 표현될 수 있는 용어는?  
    ① 일반화  
    ② 추상화  
    ③ 캡슐화  
    ④ 집단화  
   

**2과목 소프트웨어 개발**

21. XP(eXtreme Programming)의 5가지 가치에 속하지 **않는** 것은?  
    ① 용기  
    ② 의사소통  
    ③ 실행 분석  
    ④ 피드백  
   

22. 다음 자료에 대하여 **Selection(선택) 정렬**을 이용하여 오름차순으로 정렬하고자 한다. 3회전 수행 결과는?  
    초기 상태: 8, 3, 4, 9, 7  
    ① 1, 3, 4, 7, 8, 9  
    ② 3, 4, 7, 9, 8  
    ③ 3, 8, 4, 9, 7  
    ④ 3, 4, 8, 9, 7  
   

23. 해싱 함수(Hashing Function)의 종류가 아닌 것은?  
    ① Mid-Square  
    ② Digit Analysis  
    ③ 개방 주소법(Open Addressing)  
    ④ 재산법(Division)  
   

24. 다음 중 인터페이스 구현 검증 도구에 대한 설명으로 옳지 **않은** 것은?  
    ① STAF : Ruby를 사용하는 애플리케이션 테스트 프레임워크이다.  
    ② xUnit : C++, C# (.NET), Java, JUnit, NUnit 등의 다양한 언어를 지원하는 단위 테스트 프레임워크이다.  
    ③ FitNesse : 웹 기반 테스트 케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크이다.  
    ④ NTAF : NHN의 자동화 테스트 프레임워크이다.  
   

25. McCabe의 순환 복잡도(Cyclomatic Complexity)에 대한 설명으로 옳은 것은?  
    ① 소스 라인 수로 복잡도를 측정하는 기법이다.  
    ② 제어 흐름 그래프를 사용하여 계산한다.  
    ③ 프로그램의 논리적 복잡도가 낮을수록 순환 복잡도는 높다.  
    ④ 순환 복잡도가 높을수록 테스트 케이스 수가 적어도 된다.  
   

26. 다음 중 소프트웨어 개발 도구 선정 시 고려사항으로 거리가 **먼** 것은?  
    ① 성능이나 편의성뿐만 아니라 범용성도 고려하여 개발 도구를 선정해야 한다.  
    ② IDE는 개발자가 편리하게 컴파일 및 디버깅할 수 있도록 지원하는 도구이다.  
    ③ 외부의 플러그인과 연계하여 적용할 수 있는 IDE를 선정해야 한다.  
    ④ 코드 품질 및 인터페이스 검사 도구는 모든 코딩을 완료한 후에 실행하는 것이 좋다.  
   

27. 다음 중 테스트 케이스 자동 생성 도구를 이용하여 테스트 데이터를 생성하는 방법이 아닌 것은?  
    ① 스텁(Stub)과 드라이버(Driver)  
    ② 입력 도메인 분석  
    ③ 랜덤(Random) 테스트  
    ④ 자료 흐름  
   

28. 블랙박스 테스트로 발견하기 어려운 오류는?  
    ① 비정상적인 자료를 입력해도 오류 처리를 수행하지 않는 경우  
    ② 정상적인 자료를 입력해도 요구된 기능이 제대로 수행되지 않는 경우  
    ③ 요구된 기능 외 불필요한 기능이 추가된 경우  
    ④ 인터페이스 연동 오류  
   

29. 버전 관리 중 저장소(Repository)의 파일 갱신을 의미하는 것은?  
    ① Check-in  
    ② Rollback  
    ③ Commit  
    ④ Update  
   

30. 다음 자료에 대하여 **Bubble Sort(버블 정렬)**를 이용하여 오름차순 정렬을 수행할 경우, 1회전 후의 결과는?  
    초기 상태: 9, 6, 7, 3, 5  
    ① 6, 7, 3, 5, 9  
    ② 6, 3, 5, 7, 9  
    ③ 3, 5, 6, 7, 9  
    ④ 9, 6, 7, 3, 5  
   

31. 코드 인스펙션(Inspection) 과정에 대한 설명으로 **틀린** 것은?  
    ① 1~3명으로 진행하는 비공식적인 검토 방법이다.  
    ② 요구사항 명세서, 소스 코드 등을 대상으로 진행한다.  
    ③ 코드의 오류뿐만 아니라 문서화 오류도 발견할 수 있다.  
    ④ 동료 검토, 워크스루보다 더 공식적인 검토 방법이다.  
   

32. 다음 자료 구조 중 트리의 **차수(Degree)**와 **단말 노드(Terminal Node)**의 수는?  
    [이미지 설명: 루트 노드 H, 자식 노드 C, G. C의 자식 노드 A, B. G의 자식 노드 D, E, F. A, B, D, E, F는 자식 노드가 없음.]  
    ① 차수: 2, 단말 노드: 4  
    ② 차수: 4, 단말 노드: 8  
    ③ 차수: 3, 단말 노드: 5  
    ④ 차수: 4, 단말 노드: 5  
   

33. 소프트웨어 공학에서 워크스루(Walkthrough)에 대한 설명으로 **틀린** 것은?  
    ① 사용자를 포함하여 명세서나 설계 다이어그램, 원시 코드, 테스트 케이스 등에 적용할 수 있다.  
    ② 복잡한 알고리즘 또는 반복, 실시간 동작, 병행 처리와 같은 기능이나 동작을 이해하려고 할 때 유용하다.  
    ③ 인스펙션(Inspection)과 동일한 의미를 가진다.  
    ④ 단순한 테스트 케이스를 이용하여 프로젝트를 수작업으로 수행해 보는 것이다.  
   

34. EAI(Enterprise Application Integration)의 구조 유형으로 거리가 **먼** 것은?  
    ① Point-to-Point  
    ② Hub & Spoke  
    ③ Message Bus  
    ④ Tree  
   

35. 다음은 Preorder Traversal 순회 결과이다. 결과는?  
    [이미지 설명: 루트 노드 *. 왼쪽 자식 노드 +. 오른쪽 자식 노드 E. 왼쪽 자식 노드 +의 왼쪽 자식 노드 A, 오른쪽 자식 노드 B. 오른쪽 자식 노드 +의 왼쪽 자식 노드 C, 오른쪽 자식 노드 D.]  
    ① + * + A B C D E  
    ② * + A B + C D E  
    ③ A B + C D + E *  
    ④ A B C D E + + *  
   

36. 통합 테스트(Integration Test)에 대한 설명으로 **틀린** 것은?  
    ① 시스템을 구성하는 모듈의 인터페이스와 결함을 테스트하는 것이다.  
    ② 하향식 통합 테스트의 경우 우선(Breadth First) 방식으로 테스트를 한 모듈을 선택할 수 있다.  
    ③ 상향식 통합 테스트의 경우 시스템 구조도의 최상위에 있는 모듈을 먼저 구현하여 테스트한다.  
    ④ 모든 단위의 인터페이스와 시스템의 동작이 정상적으로 잘 되고 있는지를 빨리 파악하고자 할 때 상향식보다는 하향식 통합 테스트를 사용하는 것이 좋다.  
   

37. COCOMO 모델의 규모 산정 모형 중 원시 코드 라인(Source Lines of Code) 수에 따라 규모를 산정하고, 개발 기간과 비용을 계산하는 모형은?  
    ① Embedded  
    ② Organic  
    ③ Semi-detached  
    ④ Simple  
   

38. 소프트웨어 생명 주기 모델 중 가장 오래된 모델로, 많은 적용 사례가 있지만 요구사항 변경이 어렵고 각 단계의 결과가 확인되어야 다음 단계로 넘어갈 수 있는 선형 순차적, 고전적 생명 주기 모형이라고도 하는 것은?  
    ① Waterfall Model  
    ② Prototype Model  
    ③ Cocomo Model  
    ④ Spiral Model  
   

39. Postfix 연산식의 결과 값은?  
    3 4 * 5 6 + *  
    ① 35  
    ② 42  
    ③ 360  
    ④ 77  
   

40. 다음 중 소프트웨어 품질 표준인 ISO/IEC 25010에 대한 설명으로 옳지 **않은** 것은?  
    ① ISO/IEC 9126의 개정판이며 소프트웨어 품질 특성에 대한 내용을 포함하고 있다.  
    ② 소프트웨어 품질 평가 모델과 소프트웨어 품질 평가 지표를 통합하였다.  
    ③ 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성, 보안성, 호환성을 주요 품질 특성으로 제시한다.  
    ④ ISO/IEC 25010은 소프트웨어 외부 품질과 내부 품질에 대한 모델을 통합하였다.  
   

**3과목 데이터베이스 구축**

41. DDL(Data Definition Language)의 명령어 중 **REVOKE**와 관련한 설명으로 옳은 것은?  
    ① 사용자의 테이블 생성 권한을 부여한다.  
    ② 사용자의 뷰 생성 권한을 회수한다.  
    ③ 사용자의 권한을 회수한다.  
    ④ 사용자의 테이블 삭제 권한을 부여한다.  
   

42. 트랜잭션(Transaction)의 특성 중 트랜잭션 실행이 성공적으로 완료되면 언제나 일관성 있는 데이터베이스 상태로 변환되는 특성은?  
    ① 원자성(Atomicity)  
    ② 일관성(Consistency)  
    ③ 격리성(Isolation)  
    ④ 영속성(Durability)  
   

43. 다음 중 릴레이션(Relation)의 특징에 대한 설명으로 **틀린** 것은?  
    ① 한 릴레이션에는 동일한 이름의 속성이 올 수 없다.  
    ② 릴레이션에 포함된 튜플은 모두 상이하다.  
    ③ 릴레이션에 포함된 튜플 사이에는 순서가 없다.  
    ④ 속성 간에는 순서가 없다.  
   

44. 다음 중 정규화 과정에서 **2NF**가 되기 위한 조건으로 옳은 것은?  
    ① 1NF를 만족하고, 모든 도메인이 원자값이어야 한다.  
    ② 1NF를 만족하고, 키가 아닌 모든 애트리뷰트들이 기본키에 완전 함수적 종속해야 한다.  
    ③ 2NF를 만족하고, 기본키가 아닌 모든 속성이 기본키에 대해 완전 함수적 종속을 만족해야 한다.  
    ④ 2NF를 만족하고, 결정자가 후보키가 아닌 함수 종속 관계를 제거해야 한다.  
   

45. 다음 중 데이터 무결성 제약 조건 중 **개체 무결성** 제약 조건에 대한 설명으로 옳은 것은?  
    ① 릴레이션 내의 튜플들이 각 속성의 도메인에 지정된 값만을 가져야 한다.  
    ② 기본 테이블의 기본키를 구성하는 어떤 속성도 NULL 값이나 중복 값을 가질 수 없다.  
    ③ 외래키는 참조할 수 없는 외래키 값을 가질 수 없다.  
    ④ 외래키 값은 참조 릴레이션의 기본키 값과 동일해야 한다.  
   

46. 다음은 트랜잭션 상태에 대한 설명이다. 트랜잭션 실행이 실패하여 Rollback 연산이 수행된 상태는?  
    ① Active  
    ② Partially Committed  
    ③ Failed  
    ④ Aborted  
   

47. 다음 중 시스템 카탈로그(System Catalog)에 대한 설명으로 **틀린** 것은?  
    ① 사용자가 직접 시스템 카탈로그의 내용을 갱신하여 데이터를 검색할 수 있다.  
    ② 시스템 카탈로그에 저장된 정보는 메타 데이터라고도 한다.  
    ③ 시스템 카탈로그는 DBMS가 스스로 생성하고 유지한다.  
    ④ 데이터베이스에 포함되는 데이터 객체에 대한 정의나 명세에 대한 정보를 포함한다.  
   

48. 다음 중 분산 데이터베이스의 특징에 대한 설명으로 **틀린** 것은?  
    ① 물리적으로 떨어진 여러 컴퓨터 사이트에 분산되어 있어도 사용자는 하나의 시스템처럼 사용할 수 있다.  
    ② 위치 투명성, 복제 투명성, 병행 투명성, 장애 투명성을 목표로 한다.  
    ③ 데이터베이스 시스템의 주요 구성 요소는 분산 처리기, 분산 데이터베이스, 통신 네트워크 등이다.  
    ④ 분산 데이터베이스 시스템은 개발 및 관리가 용이하다.  
   

49. 다음 중 DDL(Data Definition Language)에 해당되는 명령어는?  
    ① SELECT  
    ② INSERT  
    ③ CREATE  
    ④ UPDATE  
   

50. 릴레이션 연산 중 셀렉션(Selection)에 대한 설명으로 옳은 것은?  
    ① 릴레이션에서 하나 이상의 속성 값을 조합하여 새로운 튜플을 생성하는 연산이다.  
    ② 릴레이션에서 특정 조건에 맞는 튜플을 선택하는 연산이다.  
    ③ 두 릴레이션의 공통된 튜플을 선택하는 연산이다.  
    ④ 두 릴레이션의 카티션 프로덕트 결과에서 특정 속성만 선택하는 연산이다.  
   

51. 다음 중 이상(Anomaly) 현상이 발생하는 원인이 아닌 것은?  
    ① 삽입 이상  
    ② 갱신 이상  
    ③ 삭제 이상  
    ④ 분산 이상  
   

52. 다음 중 데이터베이스 물리 설계 단계의 특징으로 옳은 것은?  
    ① 물리적인 저장 구조 및 접근 경로를 설계한다.  
    ② 개념 스키마를 DBMS에 독립적으로 설계한다.  
    ③ 트랜잭션 인터페이스 설계를 진행한다.  
    ④ 요구사항 분석을 통해 개념 모델을 설계한다.  
   

53. 다음 중 데이터베이스 설계 단계에 대한 설명으로 **틀린** 것은?  
    ① 개념 설계 단계에서 트랜잭션 인터페이스를 설계한다.  
    ② 논리 설계 단계에서는 목표 DBMS에 맞는 논리적 스키마를 설계한다.  
    ③ 물리 설계 단계에서는 저장 레코드 양식, 접근 경로 등을 설계한다.  
    ④ 요구사항 분석 단계는 데이터베이스 개발의 첫 단계이다.  
   

54. 다음 중 View에 대한 설명으로 **틀린** 것은?  
    ① 뷰는 물리적으로 존재하지 않고, 사용자에게는 있는 것처럼 간주된다.  
    ② 기본 테이블로부터 유도된 테이블이기 때문에 기본 테이블과 같은 형태의 구조를 사용한다.  
    ③ 뷰는 저장장치에 물리적으로 구현된다.  
    ④ 뷰가 정의된 기본 테이블이나 다른 뷰를 삭제하면 뷰도 자동으로 삭제된다.  
   

55. 다음 중 ER 모델의 표기법으로 옳지 **않은** 것은?  
    ① 개체 타입 - 사각형  
    ② 속성 - 타원  
    ③ 관계 집합 - 마름모  
    ④ 연결 - 삼각형  
   

56. 다음 SQL 명령 실행 결과로 옳은 것은?  
    [이미지 설명: Table 'R' (A, B), Table 'S' (A, B). R 데이터: (1, 1), (1, 2), (3, 3). S 데이터: (1, 1), (2, 2), (3, 1).]  
    SELECT A FROM R  
    UNION ALL  
    SELECT A FROM S;  
    ① 1, 1, 3, 1, 2, 3  
    ② 1, 3  
    ③ 1, 2, 3  
    ④ 1, 1, 3, 1, 2, 3 (순서 다름)  
   

57. 다음 중 병행 제어 기법이 아닌 것은?  
    ① 로킹(Locking)  
    ② 타임 스탬프 기법(Timestamp Ordering)  
    ③ 낙관적 기법(Optimistic Concurrency Control)  
    ④ 분산 기법  
   

58. 다음 중 분산 데이터베이스 시스템의 투명성(Transparency)에 해당되지 **않는** 것은?  
    ① Location Transparency  
    ② Replication Transparency  
    ③ Failure Transparency  
    ④ Media Access Transparency  
   

59. 다음 중 병행 제어의 목적으로 **틀린** 것은?  
    ① 시스템 활용도 최대화  
    ② 사용자 응답 시간 최소화  
    ③ 데이터베이스 일관성 유지  
    ④ 데이터베이스 입출력 최소화  
   

60. 다음 SQL 문에서 ( )에 들어갈 내용으로 옳은 것은?  
    UPDATE 인사급여  
    SET ( ) = 호봉 = 15  
    WHERE 성명 = '홍길동';  
    ① IN  
    ② PROM  
    ③ SET  
    ④ INTO  
   

**4과목 프로그래밍 언어 활용**

61. 다음 Python 프로그램 실행 결과는?  
    ```python
    a =
    >>> a[2:]
    ```  
    ①  
    ②  
    ③  
    ④  
   

62. C 언어에서 정수 변수의 선언과 초기화에 사용되는 키워드는?  
    ① int  
    ② char  
    ③ float  
    ④ double  
   

63. 다음 C 언어 프로그램 실행 결과는?  
    ```c
    #include <stdio.h>

    int main(void) {
        int n = 4;
        int *pt = NULL;
        pt = &n;
        printf("%d, %d", &n + 1, pt + 1);
        return 0;
    }
    ```  
    (단, int 형의 크기는 4Byte로 가정)  
    ① 0, 4  
    ② 4, 8  
    ③ 8, 12  
    ④ 14, 18  
   

64. 다음 JAVA 프로그램 실행 결과는?  
    ```java
    class Sample {
        public static void main(String[] args) {
            int n = 5;
            System.out.println(n++ + ++n);
        }
    }
    ```  
    ① 10  
    ② 12  
    ③ 13  
    ④ 14  
   

65. C 언어에서 사용되는 입출력 함수를 사용하기 위해 반드시 포함해야 하는 헤더 파일은?  
    ① #include <stdio.h>  
    ② #include <string.h>  
    ③ #include <io.h>  
    ④ #include <math.h>  
   

66. JAVA의 변수명 작성 규칙에 대한 설명으로 옳지 **않은** 것은?  
    ① 변수 이름의 첫 글자는 숫자를 사용할 수 없다.  
    ② 첫 자리 외에는 숫자를 사용할 수 있다.  
    ③ 예약어는 변수명으로 사용할 수 없다.  
    ④ 대·소문자를 구분한다.  
   

67. 다음 C 언어 프로그램 실행 결과는?  
    ```c
    #include <stdio.h>

    int main() {
        int r = 0;
        do {
            r = r + 1;
        } while (r < 0);
        if (r == 1) {
            r++;
        } else {
            r = r + 3;
        }
        printf("%d", r);
        return 0;
    }
    ```  
    ① 0  
    ② 1  
    ③ 2  
    ④ 4  
   

68. C 언어에서 두 개의 피연산자 중 하나라도 참이면 참을 반환하는 연산자는?  
    ① !  
    ② &&  
    ③ ||  
    ④ &  
   

69. 다음 C 언어 프로그램 실행 결과는?  
    ```c
    #include <stdio.h>

    int main() {
        int a = 4, b = 4, c = 5;
        int r1, r2, r3;
        r1 = (a < b) && (b < c);
        r2 = (a == b) || (b > c);
        r3 = !c;
        printf("%d", r1 - r2 + r3);
        return 0;
    }
    ```  
    ① -1  
    ② 0  
    ③ 1  
    ④ 2  
   

70. 다음 Python 프로그램 실행 결과는?  
    ```python
    def func(n):
        sum = 0
        for i in range(n + 1):
            sum = sum + i
        return sum

    r = func(11)
    print(r)
    ```  
    ① 55  
    ② 66  
    ③ 78  
    ④ 91  
   

71. C 언어에서 동적 메모리 할당에 사용되는 함수는?  
    ① calloc()  
    ② malloc()  
    ③ realloc()  
    ④ free()  
   

72. 다음 중 스케줄링 기법에 대한 설명으로 옳지 **않은** 것은?  
    ① 선점 스케줄링은 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 있다.  
    ② 선점 스케줄링은 비선점 스케줄링에 비해 응답 시간이 짧다.  
    ③ 비선점 스케줄링은 일괄 처리 시스템에 유용하다.  
    ④ 비선점 스케줄링은 시스템 처리율이 높다.  
   

73. ARP(Address Resolution Protocol)에 대한 설명으로 옳은 것은?  
    ① 논리적 주소(IP 주소)를 물리적 주소(MAC 주소)로 변환하는 프로토콜이다.  
    ② 물리적 주소(MAC 주소)를 논리적 주소(IP 주소)로 변환하는 프로토콜이다.  
    ③ 라우팅 프로토콜의 한 종류이다.  
    ④ 네트워크 장비 간의 연결 상태를 확인하는 데 사용되는 프로토콜이다.  
   

74. 다음 중 IP 프로토콜의 특징으로 옳지 **않은** 것은?  
    ① 비연결형 서비스를 제공한다.  
    ② 단순한 헤더로 오버헤드가 적다.  
    ③ 주소 지정을 제공하고, 경로를 설정하는 기능을 한다.  
    ④ TCP와 같이 트랜스포트 계층에 존재한다.  
   

75. 다음 중 **CSMA/CA**에 대한 설명으로 옳은 것은?  
    ① 충돌이 발생하면 재전송 전에 대기 시간을 랜덤하게 설정하여 다시 전송한다.  
    ② 유선 LAN 환경에서 주로 사용되는 접근 방식이다.  
    ③ 무선 LAN 환경에서 주로 사용되는 접근 방식이다.  
    ④ 캐리어 감지 기능만 사용하여 전송한다.  
   

76. TCP 프로토콜에 대한 설명으로 **틀린** 것은?  
    ① 신뢰성 있는 연결 지향 전송 서비스를 제공한다.  
    ② 흐름 제어(Flow Control) 기능을 제공한다.  
    ③ 전이중(Full Duplex) 방식의 양방향 통신을 제공한다.  
    ④ 데이터 전송과 응답 데이터를 함께 전송할 수 없다.  
   

77. ARQ(Automatic Repeat reQuest) 종류 중 수신 측으로부터 NAK(Negative Acknowledgement)을 받으면 오류가 발생한 프레임 이후의 모든 프레임을 재전송하는 방식은?  
    ① Stop-and-wait ARQ  
    ② Go-back-N ARQ  
    ③ Selective-Repeat ARQ  
    ④ Non-Acknowledgement ARQ  
   

78. UNIX/Linux 운영체제에서 **Shell** 변수를 외부 프로그램이나 스크립트에서 사용할 수 있도록 만드는 명령어는?  
    ① echo  
    ② env  
    ③ set  
    ④ export  
   

79. 다음 중 SQL문에 사용되는 산술 연산자의 우선순위가 가장 높은 것은?  
    ① +  
    ② %  
    ③ *  
    ④ -  
   

80. FLSM(Fixed Length Subnet Masking) 기법을 적용하여 192.168.1.0/24 네트워크를 4개의 서브넷으로 나눌 때, 각 서브넷의 최대 IP 주소 수는?  
    ① 64  
    ② 62  
    ③ 32  
    ④ 30  
   

**5과목 정보시스템 구축 관리**

81. PERT 기법에 대한 설명으로 옳은 것은?  
    ① 각 작업들 간의 의존 관계를 파악하여 네트워크(Network)를 구성한다.  
    ② 시간의 흐름을 나타내는 타임라인(Time-Line) 차트로도 불린다.  
    ③ 각 작업의 순서와 일정을 수립하는 데 사용된다.  
    ④ 작업들 간의 상호 관련성, 결정 경로, 경계 시간, 자원 할당 등을 명시한다.  
   

82. 소프트웨어 개발 방법론 중 SDx(Software Defined Everything)에 해당되지 **않는** 것은?  
    ① SDN(Software Defined Networking)  
    ② NFS(Network File System)  
    ③ Network Mapper  
    ④ AOE Network  
   

83. 다음 중 지식 자산을 기반으로 사용자를 인증하는 방식은?  
    ① Something You Know  
    ② Something You Have  
    ③ Something You Are  
    ④ Somewhere You Are  
   

84. 다음 중 스크래치(Scratch) 프로그램에 대한 설명으로 옳지 **않은** 것은?  
    ① Cscribe  
    ② Scratch  
    ③ Flume  
    ④ Chukwa  
   

85. 위험 관리(Risk Management) 프로세스 중 프로젝트에 내재된 위험 요소를 식별하고, 그 영향력을 분석하여 이를 관리하는 활동으로 가장 적절한 것은?  
    ① Critical Path Method  
    ② Risk Analysis  
    ③ Work Breakdown Structure  
    ④ Waterfall Model  
   

86. 다음 중 보안의 3요소에 해당되지 **않는** 것은?  
    ① 가용성  
    ② 무결성  
    ③ 기밀성  
    ④ 보안성  
   

87. 다음 중 BitLocker에 대한 설명으로 옳은 것은?  
    ① Windows 환경에서 저장된 볼륨을 암호화하는 기능이다.  
    ② 블록체인을 기반으로 한 분산 원장 기술이다.  
    ③ BaaS(Blockchain as a Service)의 한 종류이다.  
    ④ VPN을 통해 데이터를 암호화하는 기능이다.  
   

88. 접근 통제 모델 중 벨-라파둘라 모델(Bell-LaPadula Model)에 대한 설명으로 옳은 것은?  
    ① 주체는 자신보다 높은 등급의 객체를 읽을 수 있다.  
    ② 주체는 자신보다 낮은 등급의 객체에 쓸 수 없다.  
    ③ 기밀성보다 무결성을 중시하는 모델이다.  
    ④ 주체는 자신과 같거나 낮은 등급의 객체에서만 읽을 수 있다.  
   

89. ISO 12207 표준의 기본 생명 주기 프로세스에 해당되지 **않는** 것은?  
    ① 획득 프로세스  
    ② 개발 프로세스  
    ③ 성능 평가 프로세스  
    ④ 유지보수 프로세스  
   

90. 다음 중 SAN(Storage Area Network)에 대한 설명으로 옳은 것은?  
    ① 근거리 통신망(LAN) 환경에서 서버와 저장장치를 연결하는 방식이다.  
    ② 서버와 저장장치를 고속 네트워크를 통해 연결하는 방식이다.  
    ③ 파일 단위로 저장장치에 접근하는 방식이다.  
    ④ 네트워크를 통해 서버와 저장장치를 연결하는 방식이다.  
   

91. 다음 중 시스템 내부의 **오직 인가된 사용자만 수정**할 수 있는 보안 요소는?  
    ① 기밀성  
    ② 무결성  
    ③ 가용성  
    ④ 부인방지  
   

92. 다음 중 법적으로 허용되지 않은 방법으로 개인 정보를 탈취하는 사이버 공격 기법은?  
    ① Ransomware  
    ② Phishing  
    ③ Pharming  
    ④ XSS  
   

93. 공개키 암호 방식에 대한 설명으로 옳지 **않은** 것은?  
    ① 대표적으로 RSA 기법이 있다.  
    ② 키의 분배가 용이하다.  
    ③ 사용자가 증가할수록 관리해야 할 키의 수가 많아진다.  
    ④ 암호화 속도가 복호화 속도보다 빠르다.  
   

94. 다음 중 PaaS-TA에 대한 설명으로 옳은 것은?  
    ① PaaS-TA는 개방형 클라우드 컴퓨팅 플랫폼으로, 정보처리기사 실기 시험 대비 기술요소로 활용된다.  
    ② 개방형 클라우드 컴퓨팅 플랫폼 표준으로 한국 정보통신기술협회(TTA)에서 개발하였다.  
    ③ 메타버스, 가상현실 등의 신기술 요소를 활용하여 현실 세계를 확장하는 기술이다.  
    ④ 마린 네트워크(Marine Network) 통신 기술이다.  
   

95. 소프트웨어 프레임워크에 대한 설명으로 **틀린** 것은?  
    ① 제품 상태의 변화를 도메인 모델로 표현한 서비스 컴포넌트를 사용하여 재사용성 확보 및 성능을 보장받을 수 있게 하는 소프트웨어이다.  
    ② 개발해야 할 애플리케이션의 일부 기능이 이미 구현되어 있어 동일한 로직 반복을 줄일 수 있다.  
    ③ 라이브러리와 달리 사용자가 직접 호출하여 사용하며, 애플리케이션 개발 프레임워크가 직접 코드의 실행 흐름을 제어할 수 없다.  
    ④ 생산성 향상과 유지보수성 향상 등의 장점이 있다.  
   

96. 다음 중 **랜섬웨어(Ransomware)**에 대한 설명으로 옳은 것은?  
    ① 컴퓨터 시스템에 침입하여 파일을 암호화하여 사용자의 접근을 방해하고, 복구 대가로 금전을 요구하는 악성 소프트웨어이다.  
    ② 사용자에게 스팸 메시지를 보내 악성 코드를 다운로드하도록 유도하는 공격이다.  
    ③ 가짜 웹사이트로 유도하여 개인 정보를 탈취하는 공격이다.  
    ④ 시스템 취약점을 이용해 권한을 획득하고 시스템을 제어하는 공격이다.  
   

97. COCOMO 모형의 종류 중 규모가 **30만 라인(KLOC)** 이하인 중간 규모의 소프트웨어 개발에 적합한 것은?  
    ① Embedded  
    ② Organic  
    ③ Semi-detached  
    ④ Simple  
   

98. 다음 중 방화벽(Firewall)에 대한 설명으로 옳지 **않은** 것은?  
    ① 네트워크 보안 시스템의 가장 일반적인 형태이다.  
    ② 미리 정의된 규칙에 따라 패킷을 허용하거나 차단한다.  
    ③ IP 주소, 포트 번호, 프로토콜 등을 기반으로 제어한다.  
    ④ 내부 네트워크에서 외부 네트워크로의 접근은 허용하지만, 외부에서 내부로의 접근은 모두 차단한다.  
   

99. 다음 중 백도어(Back Door)에 대한 설명으로 옳은 것은?  
    ① 시스템 침투 후 나중에 다시 접근하기 위해 미리 만들어 놓은 통로이다.  
    ② 사용자의 개인 정보를 몰래 수집하는 프로그램이다.  
    ③ 컴퓨터 시스템을 감염시켜 자원을 사용하지 못하게 만드는 악성 프로그램이다.  
    ④ 정상적인 파일처럼 위장하여 실행되도록 만든 악성 프로그램이다.  
   

100. 다음 중 정보 시스템 감리에 대한 설명으로 옳지 **않은** 것은?  
    ① 감리 대상 사업 범위 및 규모에 따라 투입되는 감리원의 수가 달라진다.  
    ② 감리원은 해당 사업에 대한 전문 지식과 경험이 풍부해야 한다.  
    ③ 감리는 정보 시스템 구축 전 과정에 걸쳐 독립적이고 전문적인 시각으로 문제점을 도출한다.  
    ④ 감리 결과를 바탕으로 개선 계획을 수립하고 이행 여부를 관리한다.  
    (Source does not explicitly define "정보 시스템 감리", but covers related concepts like project management, risk management, testing, etc. This question topic doesn't appear directly in the provided excerpts within the relevant timeframe).

---

## 정답 및 해설

**1과목 소프트웨어 설계**

1.  **정답:** ②  
    **해설:** 애자일 방법론에서는 동작하는 소프트웨어 > 포괄적인 문서, 개인과 상호작용 > 공정과 도구, 고객과의 협력 > 계약 협상, 변화에 대한 대응 > 계획을 핵심 가치로 둡니다. 따라서 동작하는 소프트웨어보다 포괄적인 문서를 더 가치 있게 여긴다는 설명은 틀렸습니다.  
   

2.  **정답:** ①  
    **해설:** HIPO는 상향식이 아닌 하향식 소프트웨어 개발을 위한 문서화 도구입니다. 가시적 도표, 총체적 도표, 세부적 도표로 구성되며, 기능과 자료의 관계를 표현할 수 있습니다. 보기 쉽고 이해하기 쉽다는 장점이 있습니다.  
   

3.  **정답:** ④  
    **해설:** 디자인 패턴은 생성(Creational), 구조(Structural), 행위(Behavioral) 패턴으로 분류됩니다. Observer, Decorator, Adapter는 GoF 디자인 패턴에 해당됩니다. Proxy도 구조 패턴에 해당됩니다. '프록시'는 디자인 패턴의 한 종류입니다. 보기 4 'Proxy'는 디자인 패턴의 종류 중 하나입니다. 따라서 해당되지 않는 것은 없습니다. (Note: There seems to be a discrepancy between the question asking which is NOT a design pattern and all options *being* design patterns based on source. Source Q17 asks which is NOT among the listed options as a design pattern. The provided options in the question are all listed as design patterns in. However, the provided solution for Q17 in is ① Observer. This suggests the original question in source was different, or there's an error in the provided source's question text or options for Q17 relative to the stated answer. Based *strictly* on the text provided for Q17 and the list of design patterns, all options *are* design patterns. Assuming the user expects a valid question *from* the source, there might be an error in this specific question's transcription or the source itself. Given the task is to use the source *exactly*, I will transcribe the question and options as given, but note this potential issue based on the source's *answer*. The correct answer from the source is ① Observer, which implies ① was *not* one of the design patterns *in the original question's list of options*, despite being a design pattern itself. Let's re-examine source Q17. Ah, source Q17 asks "다음 디자인 패턴 중 생성(Creational) 패턴에 속하지 않는 것은?". The options are ① Observer, ② Decorator, ③ Adapter, ④ Proxy. None of these are Creational patterns listed in. The solution is ①. This implies Observer was the expected answer, possibly because the original question or options were different or the classification assumed by the test is different from the provided text's full list. Let's use the original question from source Q17 and its given answer. Original question from Q17 is "다음 디자인 패턴 중 생성(Creational) 패턴에 속하지 않는 것은?". Options are ① Observer, ② Decorator, ③ Adapter, ④ Proxy. The solution in is ①. I will use this exact question and answer.)  
    **정정된 해설:** 디자인 패턴은 생성(Creational), 구조(Structural), 행위(Behavioral) 패턴으로 분류됩니다. 생성 패턴에는 Factory Method, Abstract Factory, Builder, Prototype, Singleton이 있습니다. 구조 패턴에는 Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy가 있습니다. 행위 패턴에는 Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor가 있습니다. 주어진 보기 중 Observer는 행위 패턴, Decorator, Adapter, Proxy는 구조 패턴입니다. 모두 생성 패턴에 속하지 않습니다. 주어진 소스에서 이 문제의 정답은 ① Observer로 제시되어 있습니다. 이는 문제나 보기의 구성, 또는 문제 출제 시점에 따른 분류 기준이 다를 수 있음을 시사합니다. **제공된 소스의 문제 및 정답에 따라 정답은 ① Observer입니다.**  
   

4.  **정답:** ③  
    **해설:** 트리의 차수는 노드의 단말 노드 수를 말하는 것이 아니라, 노드의 자식 노드 수를 말합니다. 단말 노드의 차수는 0입니다.  
   

5.  **정답:** ③  
    **해설:** 프로토타이핑 모델은 새로운 요구사항이 발생할 때마다 이를 반영한 프로토타입을 계속해서 만들면서 소프트웨어를 구현하는 방법입니다. 프로토타이핑 과정에서 새로운 요구사항이 도출될 수 있으며, 이를 반영해야 합니다.  
   

6.  **정답:** ④  
    **해설:** 스크럼 마스터는 팀을 이끌거나 지시하는 역할이 아니라, 팀이 스크럼 프레임워크 내에서 효과적으로 작동하도록 돕는 **촉진자(Facilitator)** 역할을 합니다.  
   

7.  **정답:** ①, ②, ③  
    **해설:** 비기능 요구사항은 시스템의 성능, 보안, 사용성, 신뢰성 등 **품질 속성**과 관련된 요구사항입니다. 보기 ①, ②, ③은 비기능 요구사항에 해당합니다. 보기 ④는 시스템의 주요 기능을 설명하는 것으로 **기능 요구사항**에 해당합니다. (Note: The source and list 1, 2, 3 as correct options for question asking which is correct description of non-functional requirements. This implies there are multiple correct options among 1, 2, 3. The question asks for the *correct* description. Let's check the source's answer key for this question number. Source lists 3번으로 정답이 나와있습니다. Source lists 1.3으로 정답이 나와있습니다. This indicates inconsistency in the source documents or question numbering. Let's assume the question asks to select all correct options from the choices, or there's a single best answer intended. Given the provided solution in is ③, and in is 1, 3, let's assume the question intends to ask which is/are correct. Based on the definition of non-functional requirements, ①, ②, and ③ all describe non-functional requirements. Since I must use the source, and there's inconsistency, I will present all three as correct descriptions based on the definition and the provided options, noting the inconsistency in the original source's single-choice answer format if necessary. However, the usual format is single choice. Let's assume the question is "다음 중 비기능 요구사항에 대한 설명으로 옳은 것을 **모두** 고른 것은?" or there's a single intended answer. Let's look at the explanations again. Explanation for Q3 says "비기능 요구사항입니다." for 1, 2, 3. Explanation for Q5 says "비기능 요구사항에 해당됩니다." for 1, 2, 3. Both explicitly state 1, 2, 3 are correct descriptions of non-functional requirements. Since the original question format implies a single answer (1, 2, 3, 4 options), there must be an intended best answer or error. Given the provided answer keys point to 1 and/or 3 being correct in the source, and the definition supports 1, 2, 3, I will select the most comprehensive correct option or note the ambiguity if strictly following the single-choice format. Let's assume the original question intended one answer. Option ③ (보안, 안전) is often a key non-functional requirement category. Option ① (성능, 반응 시간) is also key. Option ② (응답 시간 3초) is a specific example of a performance requirement (subset of ①). Between ① and ③, both are major categories. Source answer is 3. Source answer is 1,3. Let's rely on the explicit answer keys when they exist for the specific question number. Let's assume the question was "다음 중 비기능 요구사항에 대한 설명으로 **가장** 옳은 것은?". Given the inconsistency, I will list all three as correct descriptions as per the expert opinion and provide the likely intended single answer based on the source's answer key if available for this exact question number. Source Q3 answer is 3. Source Q5 answer is 1,3. Let's use the full set of correct descriptions as per the expert opinion.)  
    **정정된 해설:** 비기능 요구사항은 시스템이 수행해야 하는 기능적인 측면을 제외한 성능, 보안, 사용성, 신뢰성 등 품질 속성과 관련된 요구사항입니다. 보기 ① (성능), 보기 ② (성능), 보기 ③ (보안, 안전)은 모두 비기능 요구사항에 대한 올바른 설명입니다. 보기 ④는 기능 요구사항입니다. 주어진 소스에서는 이 문제에 대해 여러 정답이 제시되어 있어, 복수 정답 문제이거나 출제 오류일 수 있습니다. 여기서는 **보기 ①, ②, ③ 모두 비기능 요구사항에 대한 올바른 설명입니다.**  
   

8.  **정답:** ③  
    **해설:** UI 설계 4가지 원칙은 직관성(Intuitive), 유효성(Effective), 학습성(Learnable), 유연성(Flexible)입니다. 누구나 쉽게 이해하고 사용할 수 있다는 것은 **직관성**에 해당됩니다.  
   

9.  **정답:** ④  
    **해설:** SOLID 원칙은 객체 지향 설계의 5가지 원칙으로 SRP(단일 책임), OCP(개방-폐쇄), LSP(리스코프 치환), ISP(인터페이스 분리), DIP(의존 역전)입니다. SSO(Single Sign On)는 인증 기술입니다.  
   

10. **정답:** ②  
    **해설:** 객체 간의 관계 중 Association은 두 객체가 서로 연관되어 있음을 나타내며, Dependency는 한 객체의 명세 변경이 다른 객체에 영향을 주는 관계를 나타냅니다. 특히 한 클래스가 다른 클래스를 오퍼레이션의 매개 변수나 리턴 값으로 사용하는 경우는 Dependency 관계에 해당됩니다.  
   

11. **정답:** ②  
    **해설:** 객체 지향 프로그래밍에서 데이터와 데이터를 처리하는 함수(메소드)를 묶어 놓은 논리적인 단위는 **클래스(Class)**입니다.  
   

12. **정답:** ①, ③  
    **해설:** GoF 디자인 패턴 중 생성(Creational) 패턴에는 Factory Method, Abstract Factory, Builder, Prototype, Singleton이 있습니다. 보기 중 Builder와 Prototype은 생성 패턴에 해당됩니다. Observer는 행위 패턴, Bridge는 구조 패턴입니다. (Note: Source lists Q1 answer as ①. Source Q1 answer is ①. Both sources list Builder and Prototype as Creational patterns. There might be an issue with the original question or options in the source excerpts provided if only one answer is expected and both Builder and Prototype are listed as Creational in the source itself. Assuming the single-choice format from the source, I will provide the answer key's answer if available for this exact question. Source Q1 is 1. Source Q1 is 1. So, ① Builder is the intended answer.)  
    **정정된 해설:** GoF 디자인 패턴 중 생성(Creational) 패턴에는 Factory Method, Abstract Factory, Builder, Prototype, Singleton이 있습니다. 보기 중 Builder와 Prototype은 생성 패턴입니다. Observer는 행위 패턴, Bridge는 구조 패턴입니다. **제공된 소스의 정답은 ① Builder입니다.**  
   

13. **정답:** ②  
    **해설:** MVC 모델에서 Model은 데이터 및 비즈니스 로직을 담당하며, View는 사용자 인터페이스를, Controller는 사용자의 입력을 받아 Model이나 View를 업데이트하는 역할을 합니다. Model은 View와 Controller에게 변화를 **알려주는(Notify)** 역할은 하지만, View와 Controller **사이에서 정보의 접근을 담당**하는 것은 주 역할이 아닙니다. 정보 접근은 Model 자체의 역할입니다.  
   

14. **정답:** ④  
    **해설:** 요구사항 검증은 요구사항 단계에서 발견될 수 있는 오류를 최소화하는 데 목적이 있지만, 모든 요구사항 문제를 100% 완벽하게 발견할 수는 없습니다.  
   

15. **정답:** ④  
    **해설:** Rumbaugh 객체 분석 기법에서는 객체 모델링, 동적 모델링, 기능 모델링 세 가지 모델을 사용하며, 이 중 **객체 모델링이 가장 중요**하고 분석의 기초가 됩니다. 세 모델 간의 상호 보완적 관계는 있지만, 특정 모델이 다른 모델에 선행되어야 하는 엄격한 순서는 없습니다.  
   

16. **정답:** ③  
    **해설:** 순차 다이어그램은 객체들 간의 **상호 작용(Interaction)**을 시간의 흐름에 따라 표현하는 **동적(Dynamic)** 다이어그램입니다. 정적 다이어그램(예: 클래스 다이어그램)과 구별됩니다.  
   

17. **정답:** ②  
    **해설:** 소프트웨어 개발 과정에서 발생하는 변경 사항을 체계적으로 관리하고 통제하는 일련의 활동은 **형상 관리(Configuration Management)**입니다.  
   

18. **정답:** ④  
    **해설:** 워크스루는 검토 회의를 통해 소프트웨어 개발 과정의 산출물(문서, 코드 등)을 검토하여 오류를 발견하고 개선하는 방법입니다. 발견된 오류 목록을 기록하고 회의가 끝나면 수정은 개별적으로 진행하며, 다음 단계로 넘어갈지 여부는 판단하지만 **워크스루 자체에서 오류를 직접 수정하지는 않습니다.**  
   

19. **정답:** ②  
    **해설:** 클린 코드 작성 원칙에는 가독성, 단순성, 의존성 최소화, 중복성 최소화 등이 있습니다. 중복 코드를 **최대한 제거**하는 것은 클린 코드의 중요한 원칙입니다. 보기 ②의 설명은 맞는 내용입니다. (Note: The question asks which is FALSE. Option ② says "중복 코드를 최대한 제거한다." which is a correct principle of Clean Code. So this option is TRUE. This implies the question or options are problematic or I have misinterpreted the nuance. Let's check the source Q21 and Q21 and Q36. All three sources ask the same question "클린 코드 작성 원칙으로 틀린 것은?". Source Q21 options are 1. 가독성 좋다. 2. 의존성 최소화. 3. 누구나 쉽게 읽을 수 있도록 작성. 4. 간단하게 작성. Answer: 2. Source Q21 options are 1. 추상화... 2. 의존성 최소화. 3. 누구나 쉽게... 4. 중복 최소화. Answer: 1. Source Q36 options are 1. 코드를 복잡하게 작성. 2. 코드 중복 최소화. 3. 누구나 쉽게... 4. 간단하게 작성. Answer: 1. The question in the prompt uses option ② from and other options seem mixed. Let's use the question from as it's explicitly about the principles being wrong. Q36 in asks for the *wrong* principle. Option 1 is "코드를 복잡하게 작성". This is clearly WRONG. The source answer is 1. Let's use this question and options as it has a clear wrong answer.)  
    **정정된 문제 및 해설:** (Adjusting question based on a clearer version from source)  
    **19. 다음 중 클린 코드(Clean Code) 작성 원칙에 대한 설명으로 **틀린** 것은?**  
    ① 코드를 복잡하게 작성한다.  
    ② 코드의 중복을 최소화한다.  
    ③ 누구나 쉽게 읽을 수 있도록 작성한다.  
    ④ 간단하게 작성한다.  
    **정답:** ①  
    **해설:** 클린 코드는 코드를 복잡하게 작성하는 것이 아니라, 코드를 단순하고 명료하며 읽기 쉽게 작성하여 이해하고 수정하기 쉽게 만드는 것입니다. 코드의 중복을 최소화하고, 누구나 쉽게 읽을 수 있도록 작성하며, 간단하게 작성하는 것은 클린 코드의 올바른 원칙입니다.  
   

20. **정답:** ④  
    **해설:** 객체 지향 기법에서 클래스들 사이의 '부분-전체(Part-Whole)' 관계, 즉 어떤 객체가 다른 객체의 부분으로서 포함되는 관계는 **집단화(Aggregation)** 또는 **합성(Composition)**으로 표현되며, 이를 총칭하여 **집단화**로 볼 수 있습니다.  
   

**2과목 소프트웨어 개발**

21. **정답:** ③  
    **해설:** XP(eXtreme Programming)의 5가지 핵심 가치는 의사소통(Communication), 단순성(Simplicity), 용기(Courage), 존중(Respect), 피드백(Feedback)입니다. 실행 분석은 XP의 핵심 가치에 해당되지 않습니다.  
   

22. **정답:** ③  
    **해설:** 선택 정렬(Selection Sort)은 배열의 최소값을 찾아 가장 앞 요소와 교환하며 정렬하는 방식입니다.  
    초기: 8, 3, 4, 9, 7  
    1회전: 최소값 3을 찾아 첫 번째 8과 교환 -> 3, 8, 4, 9, 7  
    2회전: 1회전 결과에서 두 번째 요소(8)부터 최소값 4를 찾아 두 번째 8과 교환 -> 3, 4, 8, 9, 7  
    3회전: 2회전 결과에서 세 번째 요소(8)부터 최소값 7을 찾아 세 번째 8과 교환 -> 3, 4, 7, 9, 8  
    3회전 후 결과는 3, 4, 7, 9, 8 입니다.  
   

23. **정답:** ③  
    **해설:** 해싱 함수(Hashing Function)는 키 값을 해시 테이블의 주소로 변환하는 방식입니다. 개방 주소법(Open Addressing)은 해시 충돌 발생 시 해결하는 방법이지, 해싱 함수의 종류는 아닙니다. 해싱 함수의 종류에는 제산법, 제곱법, 폴딩법, 기수 변환법, 숫자 분석법, 계수 분석법, 무작위법 등이 있습니다.  
   

24. **정답:** ①  
    **해설:** STAF는 Ruby뿐만 아니라 Perl, Python, Tcl, Java, C++, C#, DCL 등 다양한 언어를 지원하는 자동화 테스트 프레임워크입니다. xUnit은 단위 테스트, FitNesse는 웹 기반 인수 테스트, NTAF는 NHN의 자동화 테스트 프레임워크입니다.  
   

25. **정답:** ②  
    **해설:** McCabe의 순환 복잡도는 프로그램의 **제어 흐름 그래프**를 기반으로 계산하여 프로그램의 논리적인 복잡도를 측정하는 지표입니다. 복잡도가 낮을수록 이해하기 쉽고 테스트하기 용이하며, 테스트 케이스 수도 줄어듭니다.  
   

26. **정답:** ④  
    **해설:** 코드 품질 및 인터페이스 검사 도구는 코딩과 **동시에** 또는 코딩 **직후**에 사용하는 것이 좋습니다. 모든 코딩이 완료된 후에는 오류 수정 비용이 커질 수 있습니다.  
   

27. **정답:** ①  
    **해설:** 테스트 케이스 자동 생성 기법에는 입력 도메인 분석, 랜덤 테스트, 자료 흐름, 상태 기반, 명세 기반 등이 있습니다. 스텁(Stub)과 드라이버(Driver)는 테스트를 위해 **임시로 작성되는 코드**로, 테스트 자동 생성 기법 자체는 아닙니다.  
   

28. **정답:** ③  
    **해설:** 블랙박스 테스트는 내부 구조나 구현을 알지 못하고 사용자의 요구사항을 기준으로 테스트합니다. 따라서 요구된 기능 외 불필요한 기능이 추가된 경우와 같이 **명세에는 없지만 실제 구현된 오류**는 블랙박스 테스트로 발견하기 어렵습니다.  
   

29. **정답:** ①  
    **해설:** 버전 관리 시스템에서 저장소(Repository)에 파일을 등록하거나 변경하는 행위는 **Check-in** 또는 Commit(커밋)이라고 합니다. Commit은 변경 사항을 저장소에 반영하는 것이고, Check-in은 작업 공간의 파일을 저장소에 등록하는 행위입니다. 소스에서는 Check-in을 저장소 파일 갱신으로 설명하고 있습니다.  
   

30. **정답:** ①  
    **해설:** 버블 정렬(Bubble Sort)은 인접한 두 요소의 크기를 비교하여 위치를 교환하며 정렬하는 방식입니다.  
    초기: 9, 6, 7, 3, 5  
    1회전: (9,6)->(6,9), (9,7)->(7,9), (9,3)->(3,9), (9,5)->(5,9). 결과: 6, 7, 3, 5, 9  
   

31. **정답:** ①  
    **해설:** 코드 인스펙션은 보통 3~5명 정도의 인원으로 진행되는 **공식적인** 검토 방법입니다. 1~3명의 비공식적인 검토는 패어 프로그래밍이나 데스크 체킹에 가깝습니다.  
   

32. **정답:** ④  
    **해설:**  
    *   **차수(Degree):** 노드의 자식 노드 수. 트리의 차수는 노드들의 차수 중 가장 큰 값입니다.  
        H: 2, C: 2, G: 3, A: 0, B: 0, D: 0, E: 0, F: 0.  
        가장 큰 차수는 3 (G의 차수) 입니다. (Note: Source states the answer is 4, meaning the tree's degree is 3 and terminal nodes are 5. Let's re-examine the source image and its explanation. The explanation says "트리의 차수는 3, 단말 노드는 5개." Let's count again from the image. Nodes are H, C, G, A, B, D, E, F. H has children C, G (degree 2). C has children A, B (degree 2). G has children D, E, F (degree 3). A, B, D, E, F have no children (degree 0). Maximum degree is 3. Terminal nodes are nodes with degree 0: A, B, D, E, F. There are 5 terminal nodes. So, 차수: 3, 단말 노드: 5. The source answer is 4, which corresponds to option ④, 차수: 4, 단말 노드: 5. This contradicts the source's own explanation and the standard definition of tree degree. Assuming the explanation is correct and the provided answer key is wrong for this question, the answer should be "차수: 3, 단말 노드: 5". However, I must use the provided source's answer key. Let's assume there's a mistake in my understanding or the source's question/options/answer. Let's look at the options again. Option ③ says 차수: 3, 단말 노드: 5. This matches my calculation based on the explanation. Option ④ says 차수: 4, 단말 노드: 5. The difference is only in the degree. Could "차수" refer to something else? No, standard definition is clear. Could the diagram be misleading? No, it seems standard. Let's trust the provided answer key from the source which states ④ is correct. This implies the tree's degree is considered 4 in this context, or there's an error in the question/explanation/answer. Given the instruction to rely *only* on the source, I will state the answer according to the source's answer key, but note the discrepancy with the explanation.)  
    **정정된 해설:** 주어진 트리의 차수(Tree Degree)는 노드들(H, C, G, A, B, D, E, F)의 차수 중 최댓값입니다. H(2), C(2), G(3), A(0), B(0), D(0), E(0), F(0) 이므로 트리의 차수는 3입니다. 단말 노드(Terminal Node)는 자식이 없는 노드로, A, B, D, E, F 총 5개입니다. 따라서 "차수: 3, 단말 노드: 5"가 맞습니다. 그러나 **제공된 소스에서는 정답을 ④ (차수: 4, 단말 노드: 5)로 제시하고 있습니다.** 이는 소스의 오류일 가능성이 높지만, 소스를 기반으로 답변해야 하므로 소스의 정답을 따릅니다.  
   

33. **정답:** ③  
    **해설:** 워크스루와 인스펙션은 모두 소프트웨어 개발 산출물을 검토하여 오류를 찾는 방법이지만, **동일한 의미는 아닙니다.** 인스펙션은 체크리스트를 사용하고 더 정형화된 절차를 따르는 반면, 워크스루는 비교적 비공식적인 검토 방식입니다.  
   

34. **정답:** ④  
    **해설:** EAI(Enterprise Application Integration)는 기업 내 여러 애플리케이션과 플랫폼 간의 정보 연동을 지원하는 시스템을 통합하는 기술입니다. EAI의 구조 유형에는 Point-to-Point, Hub & Spoke, Message Bus(ESB), Hybrid가 있으며, Tree는 일반적인 네트워크나 데이터 구조의 형태이며 EAI 구조 유형에 직접 해당되지 않습니다.  
   

35. **정답:** ②  
    **해설:** Preorder Traversal은 트리를 순회하는 방법 중 하나로, **Root - Left - Right** 순서로 노드를 방문합니다.  
    주어진 트리:  
    Root: *  
    Left subtree Root: + (왼쪽 자식)  
    Right subtree Root: E (오른쪽 자식)  
    Left subtree of + Root: A (왼쪽 자식)  
    Right subtree of + Root: B (오른쪽 자식)  
    Left subtree of + Root: C (왼쪽 자식)  
    Right subtree of + Root: D (오른쪽 자식)  
    순회 순서:  
    1. Root 방문: *  
    2. Root의 왼쪽 서브트리 순회: Root(+) -> Left(A) -> Right(B) -> 결과: + A B  
    3. Root의 오른쪽 서브트리 순회: Root(+) -> Left(C) -> Right(D) -> 결과: + C D  
    4. E 방문  
    전체 결과: * + A B + C D E  
   

36. **정답:** ④  
    **해설:** 하향식 통합 테스트는 상위 모듈에서 하위 모듈 방향으로 통합하며 테스트하는 기법입니다. 하향식 테스트에서는 주로 상위 모듈을 먼저 구현하고 테스트하므로, 하위 모듈에 대한 **스텁(Stub)**이 필요합니다. 시스템의 주요 기능이 모듈 간의 연동 클러스터로 구현되었을 때 주로 사용됩니다. 상향식 테스트는 하위 모듈부터 테스트하여 통합하므로 하위 기능의 정확성을 빨리 파악하는 데 유리합니다.  
   

37. **정답:** ②  
    **해설:** COCOMO 모델의 규모 산정 모형은 조직형(Organic), 반분리형(Semi-detached), 임베디드형(Embedded)으로 구분됩니다. 조직형은 규모가 작고 개발 인력이 적은 경우, 반분리형은 중간 규모, 임베디드형은 대규모 시스템 개발에 적합합니다. 30만 라인 이하의 중간 규모 프로젝트는 주로 **반분리형(Semi-detached)** 모델에 해당됩니다.  
   

38. **정답:** ①  
    **해설:** 소프트웨어 생명 주기 모델 중 가장 고전적인 모델은 **폭포수 모델(Waterfall Model)**입니다. 요구사항 분석, 설계, 구현, 테스트, 유지보수 등의 단계를 선형적으로 진행하며, 각 단계의 결과가 다음 단계로 넘어가는 형식입니다. 요구사항 변경이 어렵고 유연성이 부족하다는 단점이 있습니다.  
   

39. **정답:** ③  
    **해설:** Postfix 연산은 피연산자 뒤에 연산자가 오는 방식입니다. 스택을 사용하여 계산합니다.  
    3 4 * 5 6 + *  
    1. 3, 4 스택에 push  
    2. * 연산자: 4, 3을 pop하여 3 * 4 = 12 계산 후 push -> 스택: 12  
    3. 5, 6 스택에 push -> 스택: 12, 5, 6  
    4. + 연산자: 6, 5를 pop하여 5 + 6 = 11 계산 후 push -> 스택: 12, 11  
    5. * 연산자: 11, 12를 pop하여 12 * 11 = 132 계산 후 push -> 스택: 132 (Wait, let's recheck the problem and solution from source. Problem is 3 4 * 5 6 + *. Options are 1. 35, 2. 42, 3. 360, 4. 77. The solution provided in is ③, which is 360. Let's re-calculate based on the standard postfix evaluation. (3 4 *) results in 12. (5 6 +) results in 11. The expression becomes 12 11 *. Then 12 * 11 = 132. This doesn't match the source's answer 360. Let me re-read the source explanation in. Ah, the source explanation shows the calculation as ((3 * 4) * (5 + 6)). This means the original expression was likely intended to be (3 4 * ) (5 6 +) *. Let's re-evaluate with the structure implied by the source explanation.  
    (3 4 *) -> 12  
    (5 6 +) -> 11  
    Then the expression is 12 11 *.  
    This still gives 132.  
    Let's check the source again. The source calculation shows:  
    3 4 * -> 스택에 3, 4 푸시, * 연산 -> 3 * 4 = 12, 12 푸시  
    5 6 + -> 스택에 5, 6 푸시, + 연산 -> 5 + 6 = 11, 11 푸시  
    * 연산 -> 스택에 현재 12, 11이 있으므로 11, 12를 팝하여 12 * 11 = 132.  
    The source explanation itself calculates 132! However, the provided answer for Q40 is 360. This indicates a clear error in the source document itself (either the question, options, explanation, or answer key). I must follow the instruction to draw *only* on the source. Given the explicit answer key says ③ (360), I will provide that answer, but must note the discrepancy with the calculation shown in the explanation.  
    **정정된 해설:** Postfix 연산은 피연산자 뒤에 연산자가 오는 방식입니다. 스택을 사용하여 계산합니다.  
    3 4 * 5 6 + *  
    1. 3, 4 스택에 push  
    2. * 연산자: 4, 3을 pop하여 3 * 4 = 12 계산 후 push -> 스택: 12  
    3. 5, 6 스택에 push -> 스택: 12, 5, 6  
    4. + 연산자: 6, 5를 pop하여 5 + 6 = 11 계산 후 push -> 스택: 12, 11  
    5. * 연산자: 11, 12를 pop하여 12 * 11 = 132 계산 후 push -> 스택: 132  
    계산 결과는 132입니다. **그러나 제공된 소스에서는 정답을 ③ (360)으로 제시하고 있습니다.** 이는 소스의 오류로 보입니다. 소스를 기반으로 답변해야 하므로 소스의 정답인 **③ 360**을 제시합니다.  
   

40. **정답:** ④  
    **해설:** ISO/IEC 25010은 소프트웨어 제품의 품질 특성을 정의한 국제 표준으로, ISO/IEC 9126을 대체합니다. 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성, 보안성, 호환성을 품질 특성으로 제시하며, 소프트웨어 **제품** 품질 모델, **품질 시스템** 모델, 품질 **프로세스** 모델 등 다양한 측면을 다룹니다. 소스 Q38 해설에 따르면, ISO/IEC 25010은 소프트웨어 외부 품질과 내부 품질에 대한 모델을 통합한 표준입니다. 보기 ④는 이 내용을 잘 설명하고 있습니다. (Let's re-check source Q38 options and explanation carefully. The question asks what is WRONG about ISO/IEC 25010. Option 4 says "ISO/IEC 25010은 소프트웨어 외부 품질과 내부 품질에 대한 모델을 통합하였다." and the explanation says "ISO/IEC 25010은 소프트웨어 외부 품질과 내부 품질에 대한 모델을 통합한 표준입니다." followed by a list of characteristics. This means option 4 is a CORRECT statement according to the source explanation. The source's answer is ④. This implies option ④ is the *wrong* description among the choices, meaning it's false. But the explanation says it's true. This is another inconsistency. Let's look at other options. ① is true, ② is true based on the standard's purpose. ③ lists the characteristics, which are correct. Therefore, if the answer is ④, the statement in ④ must be false. However, the explanation contradicts this. Let's assume the question or options have a typo, or there's a subtle nuance missed. Given the direct contradiction between option 4 and the explanation, and the provided answer being 4, I cannot provide a coherent explanation based solely on the source. Let me look for another question on ISO/IEC 25010 or quality. Source Q37 asks which is NOT a characteristic of ISO/IEC 9126 functional quality. The options are ① 학습성, ② 적합성, ③ 정확성, ④ 보안성. The answer is ①. Source Q38 explicitly talks about 25010. Given the direct contradiction, I will state the source's provided answer but highlight the issue with the explanation.)  
    **정정된 해설:** ISO/IEC 25010은 소프트웨어 제품 품질 특성을 정의한 국제 표준입니다. 보기 ①, ②, ③은 ISO/IEC 25010에 대한 올바른 설명입니다. 보기 ④ "ISO/IEC 25010은 소프트웨어 외부 품질과 내부 품질에 대한 모델을 통합하였다."라는 설명은 소스의 해설에서 **맞는 설명**으로 언급되어 있습니다. **그러나 제공된 소스의 정답은 ④로 제시되어 있습니다.** 이는 소스 자체의 오류일 가능성이 높습니다. 소스를 기반으로 답변해야 하므로 소스의 정답인 **④**를 제시합니다.  
   

**3과목 데이터베이스 구축**

41. **정답:** ③  
    **해설:** DDL(Data Definition Language)은 데이터베이스 스키마, 도메인, 인덱스 등을 정의하거나 수정, 삭제하는 명령어입니다. GRANT는 권한 부여, **REVOKE는 권한 회수** 명령어입니다.  
   

42. **정답:** ②  
    **해설:** 트랜잭션의 4가지 주요 특성은 Atomicity(원자성), Consistency(일관성), Isolation(격리성), Durability(영속성)입니다. **일관성(Consistency)**은 트랜잭션이 성공적으로 완료되면 언제나 일관된 데이터베이스 상태를 유지하는 특성입니다.  
   

43. **정답:** ①  
    **해설:** 릴레이션은 테이블 형태의 구조입니다.  
    ① 한 릴레이션에는 **동일한 이름의 속성이 올 수 없습니다.** 속성(Column)은 고유한 이름을 가집니다.  
    ② 릴레이션에 포함된 튜플(행)은 모두 상이해야 합니다 (개체 무결성).  
    ③ 튜플 사이에는 순서가 없습니다.  
    ④ 속성 간에는 순서가 중요하지 않습니다.  
   

44. **정답:** ③  
    **해설:** 정규화 과정에서 정규형의 정의는 다음과 같습니다.  
    - 1NF: 모든 도메인이 원자값  
    - 2NF: 1NF를 만족하고, **부분 함수 종속 제거** (기본키가 아닌 속성이 기본키의 일부에만 종속되지 않아야 함)  
    - 3NF: 2NF를 만족하고, **이행 함수 종속 제거** (기본키가 아닌 속성이 기본키가 아닌 다른 속성에 종속되지 않아야 함)  
    - BCNF: 3NF를 만족하고, **결정자가 후보키가 아닌 함수 종속 제거** (모든 결정자가 후보키이어야 함)  
    따라서 2NF가 되기 위한 조건은 1NF를 만족하고, 기본키가 아닌 모든 속성이 기본키에 대해 **완전** 함수적 종속해야 합니다.  
   

45. **정답:** ②  
    **해설:** 무결성 제약 조건에는 개체 무결성, 참조 무결성, 도메인 무결성 등이 있습니다.  
    - **개체 무결성(Entity Integrity):** 기본 테이블의 기본키를 구성하는 어떤 속성도 NULL 값이나 중복 값을 가질 수 없다. 즉, 기본키는 유일성과 최소성을 만족해야 한다.  
    - 참조 무결성(Referential Integrity): 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 한다.  
    - 도메인 무결성(Domain Integrity): 속성 값은 정의된 도메인에 속해야 한다.  
    보기 ②는 개체 무결성 제약 조건에 대한 설명입니다.  
   

46. **정답:** ④  
    **해설:** 트랜잭션의 주요 상태는 Active, Failed, Aborted, Partially Committed, Committed입니다.  
    - Active: 트랜잭션이 실행 중인 상태  
    - Failed: 트랜잭션 실행 중 오류가 발생한 상태  
    - Aborted: 트랜잭션 실행이 비정상적으로 종료되어 Rollback 연산을 수행한 상태  
    - Partially Committed: 트랜잭션 실행이 성공적으로 완료되었으나 Commit 연산 직전 상태  
    - Committed: 트랜잭션 실행이 성공적으로 완료되어 Commit 연산까지 마친 상태  
    따라서 Rollback 연산이 수행된 상태는 **Aborted**입니다.  
   

47. **정답:** ①  
    **해설:** 시스템 카탈로그(System Catalog)는 DBMS가 데이터베이스 시스템에 대한 정보를 저장하고 있는 메타 데이터의 집합입니다. 사용자는 SQL을 사용하여 카탈로그의 내용을 **검색**할 수는 있지만, 내용을 직접 **갱신하거나 수정할 수는 없습니다.** 갱신 및 수정은 DBMS가 스스로 수행합니다.  
   

48. **정답:** ④  
    **해설:** 분산 데이터베이스 시스템은 여러 위치에 분산된 데이터베이스를 논리적으로 통합하여 하나의 시스템처럼 사용하게 하는 기술입니다. 분산 투명성을 목표로 하며, 관리 및 개발이 어렵고 비용이 많이 드는 단점이 있습니다. 개발 및 관리가 용이하다는 설명은 **틀렸습니다.**  
   

49. **정답:** ③  
    **해설:** SQL 명령어는 DDL(정의), DML(조작), DCL(제어), TCL(트랜잭션 제어)로 구분됩니다. DDL 명령어는 CREATE, ALTER, DROP 등 데이터베이스 객체를 정의하는 데 사용됩니다. SELECT, INSERT, DELETE, UPDATE는 DML에 해당됩니다.  
   

50. **정답:** ②  
    **해설:** 관계 대수 연산에는 Selection(선택), Projection(프로젝트), Join(결합), Division(나눗셈) 등이 있습니다.  
    - Selection: 릴레이션에서 **특정 조건에 맞는 튜플(행)을 선택**하는 연산 (σ)  
    - Projection: 릴레이션에서 **특정 속성(열)을 선택**하는 연산 (π)  
    - Join: 두 릴레이션에서 **공통된 속성을 기준으로 튜플을 연결**하여 새로운 릴레이션을 생성하는 연산  
    - Division: 두 릴레이션에서 특정 속성을 기준으로, 첫 번째 릴레이션의 모든 튜플이 두 번째 릴레이션의 모든 튜플과 관련된 경우에만 결과를 반환하는 연산  
    보기 ②는 Selection에 대한 설명입니다.  
   

51. **정답:** ④  
    **해설:** 데이터베이스에서 발생하는 이상(Anomaly) 현상에는 삽입 이상, 삭제 이상, 갱신 이상이 있습니다. 이는 데이터의 중복으로 인해 발생하며, 주로 함수적 종속성으로 인한 정규화되지 않은 테이블에서 발생합니다. 분산 이상은 표준적인 데이터베이스 이상 현상에 해당되지 않습니다.  
   

52. **정답:** ①  
    **해설:** 데이터베이스 설계 단계는 개념 설계, 논리 설계, 물리 설계 순서로 진행됩니다. 물리 설계 단계에서는 목표 DBMS에 맞는 물리적인 구조, 즉 테이블이나 인덱스의 **저장 구조 및 접근 경로** 등을 구체적으로 설계합니다.  
   

53. **정답:** ①  
    **해설:** 데이터베이스 설계 단계는 요구사항 분석 -> 개념 설계 -> 논리 설계 -> 물리 설계 순서로 진행됩니다. 트랜잭션 인터페이스 설계는 일반적으로 논리 설계 단계에서 수행됩니다. 개념 설계 단계에서는 요구사항을 기반으로 독립적인 개념 모델을 설계합니다.  
   

54. **정답:** ③  
    **해설:** View는 기본 테이블로부터 유도된 가상 테이블로, 실제 저장 공간을 차지하지 **않습니다**. 즉, 물리적으로 존재하지 않습니다.  
   

55. **정답:** ④  
    **해설:** ER 다이어그램에서 개체 타입은 사각형, 속성은 타원(복합 속성은 이중 타원), 관계 집합은 마름모로 표기하며, 개체 타입과 관계 집합은 선으로 연결합니다. 삼각형은 ER 모델의 표준 표기법에 사용되지 않습니다.  
   

56. **정답:** ①  
    **해설:** UNION ALL 연산은 두 SELECT 문의 결과를 합집합으로 만들되, **중복된 튜플을 제거하지 않고** 모두 포함시킵니다.  
    SELECT A FROM R 결과: 1, 1, 3  
    SELECT A FROM S 결과: 1, 2, 3  
    UNION ALL 결과: 1, 1, 3, 1, 2, 3  
   

57. **정답:** ④  
    **해설:** 병행 제어 기법에는 로킹(Locking), 타임 스탬프(Timestamp Ordering), 낙관적 병행 제어(Optimistic Concurrency Control) 등이 있습니다. 분산 기법은 데이터베이스 설계나 시스템 구성 방식에 가깝고 병행 제어 기법 자체는 아닙니다.  
   

58. **정답:** ④  
    **해설:** 분산 데이터베이스의 투명성에는 위치 투명성(데이터의 물리적 위치를 몰라도 접근 가능), 복제 투명성(데이터가 복제되어 있어도 사용자에게는 하나만 있는 것처럼 보임), 병행 투명성(여러 트랜잭션이 동시에 실행되어도 결과는 일관성 있게 보임), 장애 투명성(일부 시스템 장애에도 전체 시스템은 정상 작동)이 있습니다. Media Access Transparency는 네트워크 접근 방식과 관련이 있습니다.  
   

59. **정답:** ④  
    **해설:** 병행 제어의 목적은 여러 트랜잭션이 동시에 수행될 때 데이터베이스의 일관성을 유지하고 시스템의 활용도와 성능을 높이는 것입니다. 시스템 활용도 최대화, 사용자 응답 시간 최소화, 데이터베이스 일관성 유지는 병행 제어의 주요 목적입니다. 데이터베이스 입출력 최소화는 직접적인 병행 제어의 목적이라기보다는 효율적인 데이터 처리를 위한 목표에 가깝습니다.  
   

60. **정답:** ③  
    **해설:** UPDATE 문의 SET 절은 테이블의 특정 속성(열)의 값을 변경할 때 사용합니다. 형태는 `SET 속성명 = 값` 또는 `SET (속성명1, 속성명2, ...) = (값1, 값2, ...)` 입니다. 주어진 SQL 문에서는 여러 속성(`호봉`)의 값을 변경하므로 `SET` 절이 와야 합니다.  
   

**4과목 프로그래밍 언어 활용**

61. **정답:** ③  
    **해설:** Python에서 `a[2:]`는 리스트 `a`의 인덱스 2부터 **끝까지** 슬라이싱한 결과를 반환합니다. 인덱스는 0부터 시작하므로 인덱스 2는 세 번째 요소인 30을 의미합니다.  
   

62. **정답:** ①  
    **해설:** C 언어에서 정수형 변수를 선언할 때 사용하는 키워드는 `int`, `short`, `long`, `long long` 등이 있습니다. `int`는 기본적인 정수형 키워드입니다.  
   

63. **정답:** ③  
    **해설:** C 언어에서 포인터에 정수를 더하거나 빼면, 포인터가 가리키는 자료형의 **크기(Byte)**만큼 주소가 이동합니다. `int` 형의 크기가 4Byte이므로, `&n`이 변수 `n`의 주소라면 `&n + 1`은 `&n` 주소에서 4Byte만큼 증가한 주소를 가리킵니다. `pt`는 `&n`을 가리키므로 `pt + 1`도 마찬가지로 `&n + 1`과 같은 주소를 가리킵니다. `printf("%d", 주소)` 형태로 출력하면 해당 주소 값이 정수로 출력됩니다.  
    예시: `&n`의 주소가 1000이라면, `&n + 1`은 1000 + 4 = 1004, `pt + 1`도 1000 + 4 = 1004를 출력합니다.  
    소스 해설에서 예시 주소를 14, 18로 제시하고 있습니다. 이는 첫 번째 `&n`의 주소를 14로 가정하고, `&n + 1`과 `pt + 1`이 14 + 4 = 18이 되는 것을 보여줍니다.  
    따라서 실행 결과는 **14, 18** 또는 이와 유사한 주소 값이 출력됩니다. 옵션 ③이 이 형태를 따릅니다.  
   

64. **정답:** ③  
    **해설:** JAVA에서 `n++`는 현재 값 5를 먼저 사용한 후 n을 6으로 증가시킵니다. `++n`는 n의 값을 6으로 증가시킨 후(이전 연산에서 n은 이미 6), 증가된 값 7을 사용합니다. 따라서 연산 결과는 5 (n++) + 7 (++n) = 12가 됩니다.  
    (Note: Source Q77 options are 1. 10, 2. 12, 3. 13, 4. 14. The source explanation shows the result is 13. Let's re-evaluate. Initial n = 5. `n++` uses the current value of n (5) and then increments n (n becomes 6). `++n` increments n first (n becomes 7) and then uses the new value (7). So, 5 (from n++) + 7 (from ++n) = 12. The source explanation's calculation trace `5 + 8 = 13` seems incorrect based on standard operator precedence and side effects. Let's check the source image again. Yes, the source image shows n++ -> 5 (and n becomes 6). Then ++n -> (n becomes 7) and uses 7. So 5 + 7 = 12. The explanation diagram shows `(n=5)` -> `n++` -> `5` (and `n` becomes 6) -> `++n` -> `(n` becomes 7) -> `8`. The final result in the diagram is `5+8=13`. The diagram's calculation of `++n` is wrong if n was 6; `++n` should make it 7. There seems to be an error in the source's explanation diagram/calculation trace, contradicting standard operator rules. However, the *final result* shown in the source explanation is 13. I must follow the source. So, the answer is 13, corresponding to option ③.)  
    **정정된 해설:** JAVA에서 `n++`는 현재 n의 값(5)을 먼저 사용한 후 n을 1 증가시킵니다 (n=6). `++n`는 n의 값을 먼저 1 증가시킨 후(n=7) 증가된 값을 사용합니다. 따라서 계산 결과는 5 (n++) + 7 (++n) = 12가 되어야 합니다. **하지만 제공된 소스의 해설에서는 5 + 8 = 13으로 계산되어 결과가 13으로 제시되어 있습니다.** 이는 소스 자체의 오류로 보이지만, 소스를 기반으로 답변해야 하므로 소스의 정답인 **③ 13**을 제시합니다.  
   

65. **정답:** ①  
    **해설:** C 언어에서 표준 입출력 함수(예: `printf`, `scanf`, `getchar`, `putchar` 등)를 사용하려면 표준 입출력 라이브러리 헤더 파일인 `<stdio.h>`를 포함해야 합니다.  
   

66. **정답:** ④  
    **해설:** JAVA의 변수명 작성 규칙은 다음과 같습니다. 첫 글자는 문자, 밑줄(_), 달러 기호($)만 가능하며 숫자는 올 수 없습니다. 두 번째 자리부터는 숫자, 문자, 밑줄, 달러 기호 모두 가능합니다. 예약어는 사용할 수 없습니다. 대소문자를 구분합니다. 보기 ④는 맞는 설명입니다. (Note: The question asks which is FALSE. Option ④ says "대·소문자를 구분한다." which is TRUE in Java. So ④ is the correct answer to "틀린 것은?" if the statement itself is FALSE. But the statement is TRUE. This is another "틀린 것은?" question where the option is actually TRUE based on the source. Let's re-check the source Q66 options and explanation. Q66 asks "JAVA의 변수명 작성 규칙에 대한 설명으로 옳지 않은 것은?". Options are: 1. 변수 이름의 첫 자리는 숫자를 사용할 수 없다. (TRUE). 2. 첫 자리 외에는 숫자를 사용할 수 있다. (TRUE). 3. 예약어는 변수명으로 사용할 수 없다. (TRUE). 4. 대·소문자를 구분한다. (TRUE). The source answer is ④. This implies the statement "대·소문자를 구분한다" is considered WRONG in the context of this question, despite being a core feature of Java. This is a significant error in the source. As instructed, I must use the source. Therefore, I will state the source's answer but highlight the error.)  
    **정정된 해설:** JAVA에서 변수명 작성 시 대소문자를 구분합니다. 즉, `myVar`와 `myvar`는 다른 변수로 인식됩니다. 따라서 "대·소문자를 구분한다"는 설명은 **올바른 설명**입니다. **그러나 제공된 소스에서는 이 문제의 정답을 ④로 제시하고 있습니다.** 이는 소스 자체의 오류로 보입니다. 소스를 기반으로 답변해야 하므로 소스의 정답인 **④**를 제시합니다.  
   

67. **정답:** ③  
    **해설:**  
    ```c
    #include <stdio.h>

    int main() {
        int r = 0; // r = 0
        do {
            r = r + 1; // r = 0 + 1 = 1
        } while (r < 0); // r = 1이므로 조건 (1 < 0)은 거짓. do-while 루프 종료
        if (r == 1) { // r이 1이므로 조건 (1 == 1)은 참
            r++; // r = 1 + 1 = 2
        } else {
            r = r + 3; // 실행되지 않음
        }
        printf("%d", r); // r 값 2를 출력
        return 0;
    }
    ```  
    do-while 루프는 조건을 검사하기 전에 최소 한 번 실행됩니다. 초기 `r`은 0이지만, 첫 번째 루프에서 `r`은 1이 됩니다. `while (r < 0)` 조건에서 `1 < 0`은 거짓이므로 루프는 한 번만 실행됩니다. 이후 `if (r == 1)` 조건에서 `r`은 1이므로 조건이 참이 되어 `r++`가 실행되어 `r`은 2가 됩니다. 최종적으로 2가 출력됩니다.  
   

68. **정답:** ③  
    **해설:** C 언어에서 논리 연산자는 다음과 같습니다.  
    - `!` (NOT): 논리 부정. 참이면 거짓, 거짓이면 참.  
    - `&&` (AND): 두 피연산자 모두 참일 때만 참.  
    - `||` (OR): **두 피연산자 중 하나라도 참이면 참**.  
    - `&` (Bitwise AND): 비트 단위 AND 연산.  
    두 피연산자 중 하나라도 참이면 참을 반환하는 연산자는 논리 OR 연산자인 `||`입니다.  
   

69. **정답:** ①  
    **해설:**  
    ```c
    #include <stdio.h>

    int main() {
        int a = 4, b = 4, c = 5;
        int r1, r2, r3;
        r1 = (a < b) && (b < c); // (4 < 4) -> 거짓 (0). (4 < 5) -> 참 (1). 0 && 1 -> 거짓 (0). r1 = 0.
        r2 = (a == b) || (b > c); // (4 == 4) -> 참 (1). (4 > 5) -> 거짓 (0). 1 || 0 -> 참 (1). r2 = 1.
        r3 = !c; // !5. C 언어에서는 0 이외의 모든 값은 참으로 간주됩니다. 따라서 !참 -> 거짓 (0). r3 = 0.
        // 다른 해석: !는 논리 부정 연산자. 정수 0은 거짓, 0이 아닌 수는 참. c=5는 참. !c는 !참 -> 거짓(0). r3=0.
        // 소스 해설의 계산: r3 = !c = !5 -> 0. r3=0
        // r1 = (4 < 4) && (4 < 5) = 0 && 1 = 0. r1 = 0.
        // r2 = (4 == 4) || (4 > 5) = 1 || 0 = 1. r2 = 1.
        // printf("%d", r1 - r2 + r3); // 0 - 1 + 0 = -1
        printf("%d", r1 - r2 + r3); // 0 - 1 + 0 = -1
        return 0;
    }
    ```  
    `r1`은 `(a < b)` (4 < 4)가 거짓(0)이므로 `&&` 연산 결과는 거짓(0)이 되어 `r1`은 0입니다.  
    `r2`는 `(a == b)` (4 == 4)가 참(1)이므로 `||` 연산 결과는 참(1)이 되어 `r2`는 1입니다.  
    `r3`는 `!c`입니다. C 언어에서 0이 아닌 모든 수는 참으로 간주되므로 `c = 5`는 참입니다. `!c`는 `!참`이 되어 거짓(0)이 됩니다. 따라서 `r3`는 0입니다.  
    최종 출력 값은 `r1 - r2 + r3 = 0 - 1 + 0 = -1`입니다.  
   

70. **정답:** ②  
    **해설:** Python 코드에서 `func(n)` 함수는 0부터 n까지의 정수 합을 계산합니다. `range(n + 1)`은 0부터 n까지의 숫자를 생성합니다. `func(11)`을 호출하면 0부터 11까지의 정수 합을 계산합니다.  
    0 + 1 + 2 + ... + 11 = (11 * 12) / 2 = 66.  
    결과적으로 66이 출력됩니다.  
   

71. **정답:** ②  
    **해설:** C 언어에서 동적으로 메모리를 할당하는 함수에는 `malloc()`, `calloc()`, `realloc()`이 있습니다. `malloc()`은 지정된 크기(바이트 단위)만큼 메모리를 할당합니다. `calloc()`은 할당과 동시에 0으로 초기화하며, 요소의 개수와 크기를 인자로 받습니다. `realloc()`은 이미 할당된 메모리의 크기를 변경합니다. `free()`는 동적으로 할당된 메모리를 해제하는 함수입니다. 문제에서 요구하는 동적 메모리 할당 함수는 `malloc()`입니다.  
   

72. **정답:** ④  
    **해설:** 비선점 스케줄링은 한 번 CPU를 할당받은 프로세스가 스스로 CPU를 반납할 때까지 실행되므로, 문맥 전환 오버헤드는 적지만, CPU 사용 시간이 긴 프로세스가 CPU를 독점하여 다른 프로세스의 대기 시간이 길어질 수 있습니다. 이는 시스템의 **처리율(Throughput)을 저하시킬 수 있습니다.** 응답 시간은 선점 스케줄링에 비해 일반적으로 깁니다.  
   

73. **정답:** ①  
    **해설:** ARP(Address Resolution Protocol)는 **IP 주소를 기반으로 해당 장치의 물리적인 MAC 주소를 찾는** 프로토콜입니다. IP 네트워크 환경에서 통신을 위해 필수적인 역할을 합니다. RARP(Reverse Address Resolution Protocol)는 MAC 주소로 IP 주소를 찾는 프로토콜입니다.  
   

74. **정답:** ④  
    **해설:** IP 프로토콜은 네트워크 계층(Layer 3)에서 작동하는 프로토콜로, **TCP는 트랜스포트 계층(Layer 4)**에서 작동합니다. IP는 비연결형 패킷 전달 서비스를 제공하며, 헤더 오버헤드가 적고 주소 지정 및 라우팅 기능을 수행합니다.  
   

75. **정답:** ③  
    **해설:** CSMA/CA (Carrier Sense Multiple Access with Collision Avoidance)는 주로 **무선 LAN 환경**에서 충돌을 회피하기 위해 사용되는 매체 접근 방식입니다. CSMA/CD는 유선 LAN (이더넷)에서 사용됩니다. CSMA/CA는 충돌을 감지하는 대신 충돌이 발생하기 전에 회피하려는 시도를 합니다.  
   

76. **정답:** ④  
    **해설:** TCP(Transmission Control Protocol)는 신뢰성 있는 연결 지향 프로토콜로, 흐름 제어, 오류 제어, 순서 제어, 혼잡 제어 등의 기능을 제공합니다. 전이중(Full Duplex) 통신을 지원하며, 데이터 전송과 응답(ACK) 데이터를 **함께 전송**할 수 있습니다 (Piggybacking).  
   

77. **정답:** ②  
    **해설:** ARQ(Automatic Repeat reQuest) 방식에는 Stop-and-wait, Go-back-N, Selective-Repeat이 있습니다. Go-back-N ARQ는 수신 측에서 오류가 발생하거나 순서에 맞지 않는 프레임을 받으면 NAK를 보내고, 송신 측은 오류가 발생한 프레임부터 **이후에 전송된 모든 프레임을 재전송**하는 방식입니다. Selective-Repeat ARQ는 오류가 발생한 프레임만 선택적으로 재전송합니다.  
   

78. **정답:** ④  
    **해설:** Unix/Linux Shell에서 `export` 명령어는 Shell 변수를 환경 변수로 등록하여, 현재 Shell에서 실행되는 자식 프로세스나 스크립트에서 해당 변수에 접근하고 사용할 수 있도록 합니다.  
   

79. **정답:** ③  
    **해설:** SQL에서 산술 연산자의 우선순위는 `*, /, %`가 `+, -`보다 높습니다. `*`는 곱셈, `/`는 나눗셈, `%`는 나머지 연산입니다.  
   

80. **정답:** ②  
    **해설:** 192.168.1.0/24 네트워크는 C 클래스 네트워크이며, 24비트가 네트워크 주소, 나머지 8비트가 호스트 주소입니다. 4개의 서브넷으로 나누려면 2비트의 호스트 주소를 서브넷 주소로 사용해야 합니다 (2^2 = 4). 따라서 서브넷 마스크는 24 + 2 = 26비트가 됩니다 (/26).  
    /26 마스크는 26비트가 네트워크/서브넷 주소, 나머지 32 - 26 = 6비트가 호스트 주소입니다. 호스트 주소 비트가 6개이므로 서브넷당 할당 가능한 IP 주소 수는 2^6 = 64개입니다. 여기서 네트워크 주소와 브로드캐스트 주소를 제외하면 실제 호스트에 할당 가능한 IP 주소는 64 - 2 = **62개**입니다.  
   

**5과목 정보시스템 구축 관리**

81. **정답:** ①, ④  
    **해설:** PERT(Program Evaluation and Review Technique)는 프로젝트 일정 관리를 위해 사용하는 기법입니다.  
    ① 각 작업들 간의 의존 관계를 파악하여 **네트워크(Network)** 형태로 표현합니다.  
    ② 시간의 흐름을 나타내는 것은 **간트 차트(Gantt Chart)**의 특징입니다.  
    ③ PERT는 각 작업의 순서와 일정을 수립하는 데 사용되지만, 특히 **불확실한** 작업 시간에 대한 예측과 관리에 강점이 있습니다.  
    ④ 작업들 간의 상호 관련성, **결정 경로(Critical Path)**, 경계 시간 등을 명시하고 자원 할당을 관리하는 데 활용될 수 있습니다.  
    (Note: Source Q96 and Q100 ask about PERT. Source answer is ①. Source answer is ①, ④. Both sources state that PERT represents tasks and their relationships as a network. Source additionally states that PERT clarifies relationships, critical path, and schedules, and manages resources. Option ① and ④ are both correct descriptions based on. Option ① is correct based on. Given the inconsistency in single vs multiple answers, I will present both ① and ④ as correct based on, as it provides a more detailed explanation.)  
    **정정된 해설:** PERT(Program Evaluation and Review Technique)는 프로젝트 일정 관리를 위해 사용하는 기법입니다.  
    - 각 작업들 간의 **관계**를 네트워크 형태로 표현합니다.  
    - 작업들 간의 상호 관련성, **결정 경로(Critical Path)**, 경계 시간, 자원 할당 등을 명시합니다.  
    - 불확실한 활동 기간을 예측하는 데 유용하며, 낙관치, 기대치, 비관치를 사용하여 활동 기간을 산정합니다.  
    - **보기 ①과 ④는 PERT에 대한 올바른 설명입니다.**  
   

82. **정답:** ②, ③, ④  
    **해설:** SDx(Software Defined Everything)는 데이터 센터, 네트워크, 스토리지 등 IT 인프라 전체를 소프트웨어 기반으로 제어하고 관리하는 기술 개념입니다. SDN(Software Defined Networking), SDS(Software Defined Storage), SDDC(Software Defined Data Center) 등이 이에 해당됩니다. NFS(Network File System), Network Mapper, AOE Network는 직접적으로 SDx 개념에 포함되는 기술은 아닙니다. (Note: Source Q100 asks which is NOT SDx. Options are 1. SDN, 2. NFS, 3. Network Mapper, 4. AOE Network. The provided answer is ②, ③, ④. This indicates that 2, 3, and 4 are NOT SDx, and 1 is SDx. This matches the definition.)  
    **정정된 해설:** SDx(Software Defined Everything)는 데이터 센터, 네트워크, 스토리지 등 IT 인프라 전체를 소프트웨어 기반으로 제어 및 관리하는 개념입니다. SDN(Software Defined Networking)은 SDx의 한 종류입니다. NFS(Network File System), Network Mapper, AOE Network는 SDx에 해당되지 **않습니다**. 따라서 보기 ②, ③, ④가 정답입니다.  
   

83. **정답:** ①  
    **해설:** 사용자를 인증하는 방식에는 크게 3가지가 있습니다.  
    - Something You Know (지식 기반): 비밀번호, PIN 등 알고 있는 정보.  
    - Something You Have (소유 기반): 스마트 카드, OTP 등 소유하고 있는 물건.  
    - Something You Are (존재 기반): 지문, 홍채 등 사용자의 생체 정보.  
    Somewhere You Are는 사용자의 위치를 기반으로 하는 인증 방식입니다. 문제에서 지식 자산을 기반으로 하는 인증 방식은 **Something You Know**입니다.  
   

84. **정답:** ①, ③, ④  
    **해설:** 스크래치(Scratch)는 MIT 미디어 랩에서 개발한 블록 기반 교육용 프로그래밍 언어입니다. 보기 ① Cscribe, ③ Flume, ④ Chukwa는 스크래치 프로그램이 아닙니다. 이들은 데이터 수집, 전송, 처리 등 빅데이터 관련 도구의 이름일 수 있습니다. (Note: Source Q99 asks which is NOT a Scratch program. Options are 1. Cscribe, 2. Scratch, 3. Flume, 4. Chukwa. The answer is ①, ③, ④. This means Scratch is a Scratch program (obviously), and the others are not. This matches the explanation.)  
    **정정된 해설:** 스크래치(Scratch)는 블록 기반 프로그래밍 언어입니다. 보기 ② Scratch는 스크래치 프로그램입니다. 보기 ① Cscribe, ③ Flume, ④ Chukwa는 스크래치 프로그램이 **아닙니다**.  
   

85. **정답:** ②  
    **해설:** 위험 관리(Risk Management)는 프로젝트 수행 중 발생할 수 있는 위험을 식별, 분석, 평가하고 이에 대한 대응 계획을 수립하는 일련의 활동입니다. 위험 요소를 식별하고 영향력을 분석하는 활동은 **위험 분석(Risk Analysis)** 단계에 해당됩니다.  
   

86. **정답:** ④  
    **해설:** 정보 보안의 3요소는 기밀성(Confidentiality), 무결성(Integrity), 가용성(Availability)입니다. 보안성은 정보 보안의 넓은 개념이며, 기밀성, 무결성, 가용성이 보안성을 이루는 핵심 요소입니다.  
   

87. **정답:** ①  
    **해설:** BitLocker는 Microsoft Windows 운영체제에 포함된 기능으로, 전체 디스크 드라이브 또는 특정 볼륨을 암호화하여 데이터를 보호합니다.  
   

88. **정답:** ④  
    **해설:** 벨-라파둘라 모델(Bell-LaPadula Model)은 기밀성(Confidentiality)을 중시하는 접근 통제 모델입니다.  
    - 읽기 정책: 주체는 자신과 **같거나 낮은** 등급의 객체만 읽을 수 있다 (No Read Up).  
    - 쓰기 정책: 주체는 자신과 **같거나 높은** 등급의 객체에만 쓸 수 있다 (No Write Down).  
    따라서 보기 ④는 올바른 설명입니다.  
   

89. **정답:** ③  
    **해설:** ISO/IEC 12207은 소프트웨어 생명 주기 프로세스 표준입니다. 기본 생명 주기 프로세스에는 획득, 공급, 개발, 운영, 유지보수 프로세스가 있습니다. 성능 평가 프로세스는 기본 프로세스에 해당되지 **않습니다**.  
   

90. **정답:** ②  
    **해설:** SAN(Storage Area Network)은 서버와 저장장치를 **고속 네트워크**를 통해 연결하는 방식입니다. 네트워크 장비가 스토리지 역할까지 담당하며 여러 저장장치를 통합 관리할 수 있는 시스템입니다. NAS(Network Attached Storage)는 네트워크를 통해 파일 단위로 접근하는 방식이며, DAS(Direct Attached Storage)는 서버와 저장장치를 직접 연결하는 방식입니다.  
   

91. **정답:** ②  
    **해설:** 시스템 내부 정보 자산이 인가되지 않은 사용자로부터 **수정되지 않도록** 보장하는 보안 요소는 **무결성(Integrity)**입니다. 기밀성은 인가된 사용자만 정보에 접근할 수 있도록 하는 것이고, 가용성은 인가된 사용자가 필요할 때 정보에 접근할 수 있도록 하는 것입니다. 부인방지는 사용자의 행위를 부인할 수 없도록 하는 것입니다.  
   

92. **정답:** ①  
    **해설:**  
    ① **랜섬웨어(Ransomware):** 시스템 파일 암호화 후 복구 대가로 금전을 요구하는 악성 코드입니다.  
    ② 피싱(Phishing): 이메일, SMS 등을 통해 가짜 사이트로 유도하여 개인 정보를 탈취하는 사기 수법입니다.  
    ③ 파밍(Pharming): 사용자가 정확한 웹 주소를 입력해도 가짜 사이트로 접속되도록 유도하는 사기 수법입니다.  
    ④ XSS(Cross-Site Scripting): 웹사이트의 취약점을 이용하여 사용자에게 악성 스크립트를 주입하는 공격입니다.  
    문제에서 "법적으로 허용되지 않은 방법"으로 개인 정보 탈취를 언급하고 있으므로, 모든 보기는 불법적인 행위입니다. 문제의 의도는 악성 소프트웨어 중 파일 암호화를 통해 금전을 요구하는 유형을 묻는 것으로 해석되며, 이는 랜섬웨어에 해당됩니다.  
   

93. **정답:** ④  
    **해설:** 공개키 암호 방식은 암호화 키와 복호화 키가 다른 비대칭 암호 방식입니다. 키 분배가 용이하고 사용자 증가에 따른 키 관리 부담이 적다는 장점이 있습니다. 그러나 암호화/복호화 연산 속도가 대칭키 방식보다 **느리다**는 단점이 있습니다. 따라서 보기 ④는 틀린 설명입니다.  
   

94. **정답:** ①  
    **해설:** PaaS-TA는 국내 기술로 개발된 개방형 클라우드 컴퓨팅 플랫폼 표준입니다.  
   

95. **정답:** ③  
    **해설:** 소프트웨어 프레임워크는 라이브러리와 달리 애플리케이션의 **전체 구조**를 제공하며, 프레임워크가 애플리케이션의 실행 흐름을 **제어**합니다 (IoC: Inversion of Control). 사용자는 프레임워크가 정해놓은 구조에 따라 코드를 작성하고, 프레임워크가 필요에 따라 사용자의 코드를 호출하여 실행합니다.  
   

96. **정답:** ①  
    **해설:** 랜섬웨어(Ransomware)는 컴퓨터 시스템의 파일들을 암호화하여 사용자에게 접근 권한을 박탈하고, 복호화 대가로 금전 등을 요구하는 악성 소프트웨어입니다.  
   

97. **정답:** ③  
    **해설:** COCOMO 모델의 규모 산정 모델은 조직형(Organic), 반분리형(Semi-detached), 임베디드형(Embedded)이 있습니다. 조직형은 소규모(3만 라인 이하), 임베디드형은 대규모(30만 라인 이상), 반분리형은 **중간 규모(30만 라인 이하)** 프로젝트에 적합합니다.  
   

98. **정답:** ④  
    **해설:** 방화벽(Firewall)은 네트워크 보안 시스템으로, 미리 정의된 규칙에 따라 패킷을 허용하거나 차단합니다. IP 주소, 포트 번호, 프로토콜 등을 기준으로 제어합니다. 일반적으로 내부 네트워크에서 외부로의 접근은 허용하지만, 외부에서 내부로의 접근은 엄격히 통제하거나 차단합니다. 그러나 **외부에서 내부로의 모든 접근을 차단하는 것은 아니며**, 허용된 서비스(예: 웹 서버 접근)에 대한 접근은 규칙에 따라 허용합니다.  
   

99. **정답:** ①  
    **해설:** 백도어(Back Door)는 시스템에 대한 비인가 접근을 위해 시스템 침투 후 몰래 만들어 놓은 통로입니다. 시스템 관리자가 시스템 유지보수를 위해 의도적으로 만들거나, 악성 공격자가 시스템 침투 후 영구적인 접근을 위해 만들기도 합니다.  
   

100. **정답:** (해설 참고)  
    **해설:** 제공된 소스에서는 정보 시스템 감리에 대한 직접적인 설명이나 문제가 포함되어 있지 않습니다. 따라서 이 문제에 대한 정답과 해설은 소스를 기반으로 제공하기 어렵습니다. 정보 시스템 감리는 독립적인 전문가가 정보 시스템의 효율성, 안정성, 보안성 등을 점검하고 개선 방안을 제시하는 활동입니다. 일반적으로 사업 전 과정에 걸쳐 수행되며, 감리 결과는 개선 활동으로 이어집니다.  
    (Source does not contain information for this specific question topic within the requested timeframe. I must state this limitation as per instructions.)  
    [Sources do not contain relevant information for this query]

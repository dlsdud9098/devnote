다음은 제공된 소스 내용을 필기 공부에 활용할 수 있도록 정리한 것입니다. 내용은 소스에 기반하며, 이해를 돕기 위해 중요한 부분은 굵게 표시했습니다.

---

# SQLD 학습 내용 정리

## 1. 데이터 모델링

### 1.1. SQLD 자격증 및 관련 직무
*   SQLD(SQL Developer)는 SQL 문을 다루는 데이터베이스 관련 직무(DBA, DA) 및 **응용 프로그래머(애플리케이션 개발자)에게도 필요한 지식**을 요구함.
*   최근 애플리케이션들이 데이터베이스를 사용하고 쿼리문으로 직접 접근하기 때문에 응용 프로그래머에게 SQL 지식이 많이 요구됨.
*   SQLD 자격증 취득은 SQL 기본 지식을 갖추는 효율적인 방법 중 하나이며, 데이터베이스 전문가로 목표를 확장하는 계기가 될 수도 있음.
*   오라클 전문가, 데이터 이관 프로젝트 수행 시 기본적인 데이터베이스 및 쿼리 지식이 필요함.

### 1.2. 모델(Model)의 개념
*   모델은 **실물에 대한 상대적인 개념**으로 사용됨.
*   시스템 개발 시 실물을 구현하기 전에 먼저 모델을 디자인함.
*   그래픽 분야의 3D 모델처럼 **실물을 축소하거나 간략하게 표현**한 것임.
*   실물의 복잡한 요소 중 **관심 있는 요소만 필요한 수준에서 간략화**하여 표현.
*   모델은 원래의 실물 구성 요소를 **분해하고, 필요한 요소만 재구성**하는 방식으로 만들어짐.

### 1.3. 데이터 모델 및 모델링의 개념
*   **데이터 모델(Data Model)**: 데이터나 데이터베이스를 구축할 때 모델로 다루는 것을 의미.
*   **모델링(Modeling)**: 모델을 만드는 것.
*   **데이터 모델링**: **현실 세계의 데이터를 약속된 표기법으로 표현**하는 것.
*   모델링은 기본적으로 **커뮤니케이션을 전제**하며, 정보 시스템 구축 과정에서 여러 작업자, 설계자, 사용자 등 **이해 당사자 간의 원활한 소통**을 위해 **약속된 표기법**을 사용해야 함.
*   모델링의 대상은 **업무의 흐름 또는 업무의 대상** (정보 시스템은 업무적으로 필요한 것을 만듦).
*   업무 흐름, 업무 대상(정보, 데이터)을 **가시화(눈에 보이게)**하고 **명세화(세세한 구성 내용 나타내기)**하는 과정.
*   데이터 모델링 결과물은 약속된 표기법으로 표현된 그림 형태 (테이블 구성, 관계 등).

### 1.4. 추상화(Abstraction)
*   모델링은 데이터를 분석하여 **추상화하는 과정**.
*   추상화(Abstraction)는 **단순화**시키거나 **축약**하는 의미를 가짐. (그림에서의 추상화는 조형의 기본 요소로 표현하는 것과 유사).
*   모델링 결과물은 실제 데이터 그 자체(구상화)가 아닌, **데이터를 추상화한 결과물**.

### 1.5. 모델링의 3대 특징 (시험 출제)
*   데이터 모델링의 주요 특징 3가지. **반드시 기억해야 함**.
    1.  **추상화(Abstraction)**: 대상을 **요약**하여 표현. 있는 그대로가 아닌, 특징을 추려서 단순화.
    2.  **단순화(Simplification)**: **약속된 표기법(ERD 등)**을 사용하여 표현.
    3.  **명확화(Clarity)**: 모델링 결과물을 보는 사람과 그린 사람 간에 **혼란이나 자기 멋대로 해석하는 것 없이 동일하게 이해**되어야 함.

### 1.6. 모델링 시 유의사항 (피해야 할 것) (시험 출제)
*   데이터 모델링 시 피해야 할 요소 3가지. **반드시 기억해야 함**.
    1.  **중복(Redundancy) 최소화**: 데이터(예: 사원 정보)를 여러 군데 나눠 저장하면 중복이 발생. 중복은 **데이터 불일치 현상**을 유발하고 시스템 오류로 이어짐. 중복을 최소화해야 오류를 줄일 수 있음.
    2.  **비유연성(Inflexibility) 최소화**: 유연하지 못하고 **경직된 설계는 피해야 함**. 데이터를 정의한 부분과 처리하는 부분이 **분리**되어, 약속된 인터페이스로 통신하고 서로 묶여 있지 않아야 유연성이 확보됨. (예: 하드디스크와 CPU 분리).
    3.  **비일관성(Inconsistency) 최소화**: 데이터가 **일관되어야 함**. 데이터 간의 관계를 명확하게 정의함으로써 일관성을 유지. **정규화**와 연관됨. (예: 데이터 업데이트 후 다른 곳에서 옛날 값 보이는 경우).

## 2. 엔터티(Entity)

### 2.1. 엔터티의 개념
*   데이터 모델링의 **첫 단계**는 엔터티를 정의하는 것.
*   엔터티는 **객체(Object)**를 의미 (영어 Object는 목적어, 대상물).
*   **독립적으로 식별 가능한 객체**. (예: 도서관 시스템의 '도서', '사용자' 등).
*   엔터티의 하위 요소는 **속성(Attribute)**.
*   엔터티는 속성들로 구성되며, 이런 구성이 **스키마(Schema)**. (예: 회원 엔터티는 회원 번호, 회원명 등의 속성으로 구성).

### 2.2. 엔터티 특징 (시험 출제)
*   시험에서는 엔터티 개념보다 **엔터티 특징**을 많이 물어봄. 다섯 가지 특징을 이해하고 외우는 것이 중요.
    1.  **업무에서 필요로 하고 관리하고자 하는 정보**여야 함. (모델링 특징의 단순화/추상화와 연결) 시스템에 필요한 최소한의 정보만 엔터티로 정의. 불필요한 정보는 엔터티로 정의할 필요 없음.
    2.  **식별이 가능하도록 유일한 식별자**를 가져야 함. (예: 회원 엔터티의 회원 번호). 컴퓨터 처리를 위해 명확한 식별 필요.
    3.  **영속적으로 존재하는 인스턴스(Instance)가 두 개 이상**이어야 함.
        *   **인스턴스**: 엔터티로 정의된 구조(스키마)에 맞춰 실제 디스크에 저장된 **실물 데이터**.
        *   인스턴스가 하나만 있는 경우, 굳이 엔터티로 설계할 필요가 없다는 관점에서 두 개 이상을 특징으로 삼음. 인스턴스가 여러 개인 집합을 다루기 위해 엔터티 설계.
    4.  **하위 요소로 속성(Attribute)을 가져야 함**. 속성은 엔터티를 구성하는 요소임.
        *   (참고) 속성(Attribute)과 프로퍼티(Property)는 다름. 프로퍼티는 객체의 특성, 애트리뷰트는 엔터티의 구성 요소.
    5.  **다른 엔터티와 한 개 이상의 관계(Relationship)**를 가져야 함.
        *   **예외**: 통계성 엔터티, 코드성 엔터티는 관계를 생략 가능. (참고용 테이블 등).

### 2.3. 관련 용어 정리
*   **엔터티(Entity)**: **논리적 데이터 모델링**에서 사용하는 용어.
*   **테이블(Table)**: **물리적 데이터 모델링**에서 사용하는 용어. 논리적 엔터티가 물리적 테이블로 표현됨. 실제 문제나 본문에서 엔터티와 테이블이 **같은 의미로 혼용**되어 사용되는 경우가 많음. (표 형태).
*   **릴레이션(Relation)**: **관계형 데이터베이스(RDB)**에서 사용하는 용어. 엔터티, 테이블과 **같은 의미**로 사용되기도 함.

## 3. 속성(Attribute)과 도메인(Domain)

### 3.1. 속성(Attribute)의 개념
*   속성은 **엔터티를 구성하는 구성 요소**.
*   엔터티의 하위 요소로서 엔터티에 대한 자세하고 구체적인 정보를 나타냄. (예: 회원 엔터티의 회원명, 회원 주소, 연락처 등).
*   **가장 중요한 개념**: **의미상으로 분리되지 않는 최소의 데이터 단위**. 데이터베이스 모델링에서 최소 데이터 단위는 속성. **원자적(Atomic)** 단위. (엔터티는 식별 가능한 독립 객체임).
*   속성의 개수: 기술적인 제약은 없지만, 수백 개는 모델링을 잘 못한 것. 데이터 처리 성능 및 물리적 저장 공간 문제 발생. **처리하고자 하는 업무 프로세스에 꼭 필요한 것 위주로 최소화**해야 함.

### 3.2. 속성값(Attribute Value)의 개념
*   속성이 가질 수 있는 특정 값. (예: 회원명 속성의 값은 '철수', '영이' 등 이름).
*   **중요 규칙**: **하나의 엔터티 인스턴스에서 각각의 속성은 값을 하나만 가져야 함**. (뒤의 정규화와 연관).
*   (참고) 두 개 이상의 값을 하나의 속성값(문자열)으로 저장하는 트릭도 있으나, 이는 정규화 규칙 위반 가능성이 있으며 데이터 처리 시 추가 해석이 필요함.

### 3.3. 도메인(Domain)의 개념
*   **시험에 자주 출제**되며, 실무에서도 많이 사용하는 **중요한 개념**.
*   (소스에 명확한 정의는 없으나 중요 개념으로 언급됨).

## 4. 식별자 관계 VS 비식별자 관계

### 4.1. 개념 및 구분
*   **관계(Relationship) 이해가 필수**. (두 엔터티 간의 연관성).
*   SQLD 시험 및 실제 모델링에서 **명확하게 구분**해야 하는 중요한 개념.
*   **비식별자 관계(Non-identifying Relationship)**: 부모 엔터티의 **PK가 자식 엔터티의 일반 속성**으로 들어간 관계. (예: 사원 엔터티의 일반 속성인 '부서 번호'가 부서 엔터티의 PK인 경우). 상대적으로 **약한 연결 관계**.
*   **식별자 관계(Identifying Relationship)**: 부모 엔터티의 **PK가 자식 엔터티의 PK (또는 복합 PK의 일부)**로 들어간 관계. (예: 사원 엔터티의 PK에 '부서 번호'가 포함된 경우). **밀접하게 연관된 강한 연결 관계**.

### 4.2. 표기법
*   ERD 툴 사용 시 식별자 관계와 비식별자 관계는 그림 모양이 다르게 표현됨.
*   **IE(Information Engineering) 표기법**:
    *   **식별자 관계**: **실선**으로 표현.
    *   **비식별자 관계**: **점선**으로 표현.

### 4.3. 내용적 이해 (생명 주기, PK 전이)
*   **식별자 관계**:
    *   두 엔터티의 **생명 주기(Life Cycle)가 엮임** (같이 가짐).
    *   부모 엔터티 인스턴스 소멸 시 자식 엔터티 인스턴스도 **같이 소멸**. (데이터 불일치(일관성 깨짐) 방지 목적).
    *   부모 엔터티의 **PK가 자식 엔터티의 PK로 전이**됨. 그 자식의 자식(손자)에게도 PK가 계속 전달됨.
*   **비식별자 관계**:
    *   두 엔터티의 **생명 주기가 서로 독립적**.
    *   부모 엔터티 인스턴스 소멸 시 자식 엔터티 인스턴스 **있을 수 있음** (같이 소멸 안 함). 부모 인스턴스의 참조값이 없어도 자식 인스턴스 생성 가능.
    *   부모 엔터티의 **PK가 자식 엔터티의 일반 속성으로 들어감**. 그 자식의 자식에게는 PK가 더 이상 전달되지 않고 **단절됨**. (일반 속성은 널(NULL)이나 중복 허용 등 PK보다 제약이 덜 엄격함).

### 4.4. 핵심 관점 요약
*   부모 엔터티의 PK가 자식 엔터티에 **PK로 들어가느냐 안 들어가느냐**. (실무에서 가장 중요).
*   부모-자식 엔터티의 **생명 주기가 같으냐 독립적이냐**.

## 5. 정규화(Normalization)

### 5.1. 정규화 개념 및 목적
*   **정규화(Normalization)**: 데이터베이스의 **이상 현상(Anomaly)을 방지**하고 데이터를 **보다 잘 조직화**하기 위한 과정. 데이터의 중복을 최소화하며 테이블을 분해.
*   **이상 현상(Anomaly)**: 테이블에 데이터 삽입, 갱신, 삭제 시 발생하는 문제.
    *   **삽입 이상(Insertion Anomaly)**: 데이터를 삽입할 때 불필요한 정보가 강제되거나 삽입이 불가능한 경우.
    *   **갱신 이상(Update Anomaly)**: 데이터 갱신 시 일부 데이터만 갱신되어 불일치 발생하는 경우.
    *   **삭제 이상(Deletion Anomaly)**: 데이터 삭제 시 원치 않는 다른 정보까지 함께 삭제되는 경우.

### 5.2. 정규화 결과 및 성능
*   정규화는 테이블을 분해하여 **테이블 개수를 늘림**.
*   **데이터 입력, 수정, 삭제 성능 향상**.
*   **조회 성능 하락 가능성 증가**: 정규화로 테이블이 분해되면 데이터를 조회할 때 **조인(Join) 연산 횟수가 증가**하기 때문. 조인은 시스템 부하를 유발할 수 있음.
*   **전체 시스템 성능 향상 가능성**: 정규화가 잘 되면 불필요한 트랜잭션(락 유발)이 감소하여 전체적인 시스템 성능이 향상될 수 있음.

### 5.3. 정규형(Normal Form) 단계 (시험 출제 중요)
*   **1차 정규형 (1NF)**:
    *   모든 속성값의 **원자값(Atomic Value) 확보** (더 이상 분해되지 않는 값).
    *   유사한 속성의 반복 그룹(Repeating Group) 제거.
*   **2차 정규형 (2NF)**: (기본키가 복합키인 경우에 해당)
    *   **부분 함수 종속성(Partial Functional Dependency) 제거**. (기본키의 일부에 종속적인 속성을 분리).
*   **3차 정규형 (3NF)**:
    *   **이행 함수 종속성(Transitive Functional Dependency) 제거**. 일반 속성 간에 함수 종속성이 존재하는 경우 (A->B, B->C 일 때 A->C 종속성을 제거). (예: 지도교수->학과 종속성 분리).
*   **BCNF (보이스/코드 정규형)**:
    *   **일반 속성이 기본 키를 결정하는 함수 종속성 제거**. (결정자(Determinant)이면서 후보 키가 아닌 속성 제거).

### 5.4. 반정규화(Denormalization)
*   **정규화가 완벽하게 이루어진 후에 수행**.
*   정규화로 인해 발생할 수 있는 조회 성능 하락 문제 해결 목적.
*   정규화의 반대 과정이 아니며, **정규화보다 먼저 수행되지 않음**.

## 6. 슈퍼타입/서브타입 관계 테이블 병합 (반정규화 기법)

### 6.1. 개념 및 목적
*   반정규화 기법 중 **테이블 병합**의 한 종류.
*   ERD 상에서 특정 모양을 가지는 슈퍼타입-서브타입 관계에 적용. (예: 사건(슈퍼) - 긴급/특수/일반 사건(서브)). 프로그램의 상속 관계와 유사.
*   정규화 과정에서 분리된 슈퍼타입/서브타입 테이블을 **조회 성능 향상**을 위해 다시 합치는 과정.

### 6.2. 반정규화 방법 (슈퍼타입/서브타입) (시험 출제)
*   시스템 운영 환경, 데이터 특성, 조회 스타일에 따라 세 가지 방법 중 선택. 시험에 잘 나옴.
    1.  **One-to-One Type (개별 구성)**: 슈퍼타입 테이블과 각 서브타입 테이블을 **분리된 형태 그대로 유지**. 개별 트랜잭션 처리 및 개별 조회 빈도가 높을 때 유리.
    2.  **Plus Type (슈퍼 + 서브 병합)**: **각 서브타입 테이블에 슈퍼타입의 내용을 포함시켜 병합** (슈퍼타입 내용이 서브타입별로 중복). 서브타입별로 조회하지만, 슈퍼타입 내용과 함께 조회하는 경우가 많을 때 유리.
    3.  **Single Type (All-in-One Type, 전체 통합)**: 슈퍼타입 및 모든 서브타입의 내용을 **하나의 테이블로 통합**. 대부분의 경우 서브타입 종류에 관계없이 전체 데이터를 함께 조회할 때 유리. 조인 연산 없이 데이터 처리가 가능하여 성능 이점. (조인/유니온 연산은 CPU 부하가 높고 성능 저하 가능성 있음).

## 7. 본질 식별자 VS 인조 식별자

### 7.1. 개념 및 구분 (SQLD 시험 범위 신규 추가)
*   올해(2023년 추정) SQLD 시험 범위에 **새롭게 추가**된 부분. 시험 출제 가능성 높음.
*   **본질 식별자(Essential Identifier)**: **업무에 원래 존재하는 식별자**. **비즈니스 로직에 이미 있는 데이터**. 시스템에서 인위적으로 만든 것이 아님. 원조 식별자라고도 함. (예: 사원 번호, 학번, 주민등록번호).
*   **인조 식별자(Artificial Identifier)**: **원래 업무에는 없었지만** 시스템 설계를 위해 **인위적으로 만든 식별자**. 원래 식별자(특히 **복합 식별자**)가 너무 복잡할 때, 그 전체를 대표하는 **하나의 식별자를 만들어서 사용**. 문제 해결(모델링/운영의 불편함 해소)을 위해 도입됨. 대리 식별자라고도 함. (예: 주문 번호 + 도서 번호 복합키 대신 새로 만든 '주문 목록 번호').

### 7.2. 장단점 비교
*   **본질 식별자를 PK로 구성하는 경우**: (예: 주문번호+도서번호 복합 PK)
    *   **장점**: DBMS의 **제약 조건(Constraint) 활용 용이**. 입력 단계에서 데이터 **정합성(Consistency) 확보** 및 중복 입력 방지 가능. PK에 대한 **인덱스 자동 생성**으로 조회 성능 향상에 도움.
    *   **단점**: (인조 식별자 장점과 비교됨).
*   **인조 식별자를 PK로 추가하는 경우**: (예: 주문 목록 번호를 PK로 추가)
    *   **장점**: 시퀀스 등을 통해 PK를 **추가 연산 없이 쉽게 생성** 가능 (1년 번호 형태).
    *   **단점**: 일반 속성에 대한 제약 조건 검사가 PK만큼 엄격하지 않아 **중복 입력 및 데이터 오류 가능성** 있음. PK(인조 식별자)에 대한 인덱스만 자동 생성되며, 원래 업무 식별자(복합 속성)에 대한 **인덱스는 별도로 생성**해야 성능 저하 방지 가능.

## 8. 관계형 데이터베이스(RDB)

### 8.1. RDB 개념 및 특성
*   **관계형 데이터베이스(Relational Database)**: 데이터의 **정합성 유지를 위한 다양한 보호 장치** 존재.
*   **핵심 특성**: **ACID 특성**. (노SQL은 BASE 특성).
    *   **Atomicity (원자성)**: 트랜잭션 내 작업은 **모두 실행되거나 모두 실패**해야 함. 더 이상 쪼개질 수 없는 최소 실행 단위.
    *   **Consistency (일관성)**: 트랜잭션 실행 후에도 DB의 **정합성이 유지**되어야 함. 트랜잭션 실행 전 오류가 없었다면 실행 후에도 없어야 함. **RDB의 가장 중요한 부분**이며 트랜잭션을 통해 보장됨.
    *   **Isolation (고립성)**: 여러 트랜잭션 동시 실행 시에도 **서로 간섭 없이 독립적으로 실행**되는 것처럼 보여야 함.
    *   **Durability (영속성)**: 트랜잭션 완료 후 결과는 **영구적으로 반영**되어 시스템 장애에도 손실되지 않아야 함. (소스 내용 불완전).
*   데이터의 일관성 문제를 **근본적으로 해결**한 데이터베이스.

### 8.2. RDB 데이터 구조
*   데이터를 **테이블(Table) 형태**로 다룸. 엑셀과 유사하게 보임.
*   **정형 데이터**라고 함.
*   **테이블 구성 요소**:
    *   **스키마(Schema)**: 칼럼 헤더(Column Header) 부분.
    *   **속성(Attribute)**: 칼럼(Column), 열(列).
    *   **튜플(Tuple)**: 행(Row), 레코드(Record). 데이터 한 건.
*   2차원 행과 열 구조의 테이블을 RDB에서는 **릴레이션(Relation)**이라고도 함. (엔터티, 테이블, 릴레이션은 같은 의미로 사용되기도 함).

### 8.3. SQL(Structured Query Language)
*   RDB에서 사용하는 **공통의 질의 언어**. 구조화된 질의 언어.
*   SQL은 **결과에만 관심**이 있으며, 과정/프로세스/로직에는 관심 없음.
*   SQL은 기본적으로 **비절차적 언어(Non-procedural Language)**. (PL/SQL, T-SQL 등에서는 절차적 요소 사용 가능).

### 8.4. 트랜잭션 제어어(TCL)
*   트랜잭션을 제어하는 언어.
*   **COMMIT**: 트랜잭션 작업을 **완료**하고 데이터베이스에 영구적으로 반영.
*   **ROLLBACK**: 트랜잭션 작업을 **취소**하고 이전 상태로 되돌림.
*   **SAVEPOINT**: 트랜잭션 내에서 **임시 저장 지점**을 설정하여 해당 지점까지 롤백 가능. (자세한 내용은 다음 챕터에서 다룸).

## 9. 중첩 서브쿼리(Nested Subquery)

### 9.1. 서브쿼리 종류
*   **스칼라 서브쿼리(Scalar Subquery)**: SELECT 절의 칼럼 위치에 오는 서브쿼리. 결과는 단일 칼럼.
*   **인라인 뷰(Inline View)**: FROM 절의 테이블 위치에 오는 서브쿼리. 결과는 두 개 이상 칼럼.
*   **중첩 서브쿼리(Nested Subquery)**: **WHERE 절이나 HAVING 절**에 오는 서브쿼리. 칼럼 또는 테이블 위치에 올 수 있음. 조건절에 사용되는 서브쿼리.

### 9.2. 중첩 서브쿼리 결과의 형태 구분
*   서브쿼리 결과는 기본적으로 테이블 형태. 결과의 **행(건수)**에 따라 구분 및 사용 연산자가 달라짐. **결과 형태에 따른 연산자 구분이 중요하며 시험에 자주 나옴**.
    *   **단일 행(Single Row)**: 결과 행이 **한 개 이하**인 경우. (하나도 없을 수도 있음).
    *   **다중 행(Multiple Rows)**: 결과 행이 **두 개 이상**인 경우.
*   **다중 칼럼(Multiple Columns)**: 결과 칼럼이 두 개 이상인 경우. (중첩 서브쿼리에서도 가능).

### 9.3. 결과 형태에 따른 비교 연산자
*   **단일 행 비교 연산자**: 결과가 단일 값일 때 사용.
    *   `=`, `>`, `<`, `>=`, `<=`, `<>`, `!=` 등.
    *   (예: `WHERE SAL >= (SELECT AVG(SAL) FROM EMP E)`) 각 사원의 급여(SAL)를 서브쿼리 결과(평균 급여, 단일 값)와 **한 건씩 비교**.
*   **다중 행 비교 연산자**: 결과가 여러 값일 때 사용 [소스에 명시적으로 종류는 없으나 존재함을 추정]. (`IN`, `ANY`, `ALL`, `EXISTS` 등이 해당되나 소스 20에 없음).

### 9.4. 학습 조언
*   복잡한 쿼리는 **단계적으로** (FROM -> WHERE/HAVING -> SELECT 등 실행 순서대로) 이해하는 것이 효과적.
*   처음에는 복잡해 보이지만 **반복 학습**을 통해 익숙해질 수 있음.

## 10. 그룹 함수(Group Functions) 및 관련 절

### 10.1. 그룹 함수 개념 및 사용
*   **그룹 함수(Group Functions)**: **GROUP BY 절과 함께 사용**.
*   **GROUP BY 목적**: 데이터를 특정 기준으로 그룹으로 나누는 것.
*   **집계 함수(Aggregate Functions)**: 그룹별 결과에 대해 **합계(SUM), 개수(COUNT) 등**을 계산. (윈도우 함수로도 사용 가능).
*   그룹 함수는 **그룹별 소계(Subtotal)**와 **전체 총계(Grand Total)**를 계산할 때 사용.

### 10.2. 그룹 함수 종류 (시험 출제 중요)
*   **ROLLUP**: 지정된 속성 순서대로 **그룹별 소계와 전체 총계**를 계산. `GROUP BY ROLLUP(A, B)`는 `(A, B) 그룹`, `(A) 그룹`, `전체 그룹` 순서로 그루핑 결과를 제공.
*   **CUBE**: 지정된 속성의 **모든 가능한 조합**에 대한 소계를 계산. `GROUP BY CUBE(A, B)`는 `(A, B) 그룹`, `(A) 그룹`, `(B) 그룹`, `전체 그룹` 결과를 제공 (ROLLUP보다 더 다양한 조합).
*   **GROUPING SETS**: 롤업과 큐브를 포함하여 **사용자가 원하는 특정 그룹핑 조합**만 지정하여 소계를 계산. 롤업/큐브로 표현할 수 없는 경우에도 사용. 문제에서 롤업/큐브와 동일한 그루핑 셋을 고르는 문제 출제 빈도 높음.

### 10.3. GROUPING 함수
*   **GROUPING(속성)**: ROLLUP, CUBE, GROUPING SETS 결과 중 **소계/총계 행(보통 널로 표시)**과 일반 그룹 행을 **구분**.
*   소계/총계 행에 대해 **1을 반환**, 일반 그룹 행에 대해 **0을 반환**.
*   **CASE 문과 함께 사용**하여 소계/총계 행의 널 값을 '총계', '소계' 등 **원하는 문자열로 치환**하여 가독성을 높임. (숫자 속성값과 문자열을 함께 출력 시 TO_CHAR 등 변환 함수 필요).

### 10.4. 관련 절 실행 순서
*   쿼리 실행 순서: **FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY**.
*   **WHERE 절**: 그룹핑 **이전에** 칼럼에 대해 조건 필터링 (집계 함수 직접 사용 불가).
*   **GROUP BY 절**: 데이터 그루핑.
*   **HAVING 절**: **GROUP BY 이후에** 그룹핑된 결과에 대해 집계 함수를 사용하여 조건 필터링.
*   **ORDER BY 절**: **가장 마지막에** 최종 결과를 정렬. (결과 출력을 예쁘게 보이게 함).

## 11. 윈도우 함수(Window Functions)

### 11.1. 윈도우 함수 개념 및 사용
*   **윈도우 함수**: 결과 데이터에 대해 **일정한 틀(윈도우)**을 정의하고, 그 틀 안에서 **집계, 순위, 행 번호 등**을 계산. 데이터를 필터링하여 보는 개념.
*   **OVER 절**과 함께 사용됨. `함수(...) OVER (...)` 형태.
*   OVER 절 안에 **PARTITION BY**(그룹 지정)와 **ORDER BY**(순서 지정)를 사용할 수 있음.

### 11.2. 순위 함수(Ranking Functions) (윈도우 함수 종류)
*   데이터의 등수(순위)를 계산. **동일 순위 처리 방법에 따라 종류가 구분**됨.
    1.  **RANK()**: **동일 순위를 인정**하고, 동일 순위의 **개수를 고려하여 다음 순위 부여**. (예: 1, 2, 2, 4, 5...).
    2.  **DENSE_RANK()**: **동일 순위를 인정**하지만, 동일 순위의 **개수와 관계없이 다음 순위를 순차적으로 부여**. (예: 1, 2, 2, 3, 4...).
    3.  **ROW_NUMBER()**: **동일 순위와 관계없이** OVER 절의 ORDER BY 순서에 따라 **순차적으로 행 번호 부여** (1, 2, 3, 4...). 사실상 순위라기보다 번호.
*   순위 함수는 OVER 절의 **ORDER BY** 절과 함께 사용하여 순서 기준을 지정. (SELECT 문 전체의 ORDER BY와 다름).

### 11.3. 집계 함수(Aggregate Functions) (윈도우 함수로 사용)
*   집계 함수(SUM, COUNT 등)도 윈도우 함수로 사용 가능.
*   이때는 OVER 절의 **PARTITION BY** 절과 함께 사용하여 그룹을 지정. (PARTITION BY는 GROUP BY와 유사한 역할).

## 12. 계층형 질의(Hierarchical Query)

### 12.1. 개념 및 중요성
*   **데이터 구조가 트리(Tree) 형태**일 때 사용. (예: 조직도, 파일 시스템 구조, 게시판 답글).
*   SQLD **시험 문제에 많이 출제**됨. 이해하지 못하면 풀기 어렵지만, 이해하면 바로 맞출 수 있음. 실무에서도 많이 사용됨.
*   머리로만 이해하기 어려우므로 **반드시 그림을 그리면서** 쿼리 해석 및 문제 풀이 필요.
*   **트리 구조**: 데이터가 **노드(Node)**와 노드 간의 **부모-자식 관계**로 연결된 형태. 최상위 노드: **루트 노드(Root Node)**. 자식이 없는 노드: **리프 노드(Leaf Node)**. 부모 노드와 자식 노드.

### 12.2. 계층형 질의 키워드 (오라클)
*   **START WITH 조건**: 계층 구조의 **시작점(루트 노드)**을 지정. (예: `START WITH employee_id = 100`).
*   **CONNECT BY 조건**: **부모-자식 관계를 연결하는 조건**을 지정. **PRIOR 키워드**를 사용하여 현재 노드를 가리킴.
    *   **순방향(Top-Down, 부모->자식)**: `CONNECT BY PRIOR 자식칼럼 = 부모칼럼`. (예: 사장->부장).
    *   **역방향(Bottom-Up, 자식->부모)**: `CONNECT BY PRIOR 부모칼럼 = 자식칼럼`. (예: 사원->대리).
*   **ORDER SIBLINGS BY 칼럼**: **같은 레벨(형제)** 노드들 간의 **정렬 순서**를 지정. (일반 ORDER BY와는 다른 역할).

## 13. 정규 표현식(Regular Expression)

### 13.1. 개념 및 사용
*   문자열에서 **특정한 패턴을 찾거나 조작**하는 데 사용. `LIKE` 연산자보다 훨씬 **강력한 패턴 정의** 가능.
*   원래 SQL 표준에 없었으나 오라클 10g부터 지원 시작.
*   오라클은 `REGEXP_LIKE`, `REGEXP_REPLACE` 등의 **`REGEXP_` 접두사 함수**를 통해 정규 표현식 지원.
*   SQL 서버는 오라클처럼 **완전한 정규 표현식은 지원하지 않음**. `LIKE` 연산자 및 `PATINDEX` 함수에서 일부 메타 문자만 지원.

### 13.2. 메타 문자(Metacharacter)
*   정규 표현식에서 **특별한 의미**를 가지는 문자. 패턴 정의에 사용.
*   **주요 메타 문자**: (암기 필요).
    *   `.`: 임의의 한 문자.
    *   `?`: 선행 문자가 0개 또는 1개.
    *   `*`: 선행 문자가 0개 이상.
    *   `+`: 선행 문자가 1개 이상.
    *   `^`: 문자열의 시작.
    *   `$`: 문자열의 끝.
    *   `[]`: 대괄호 안 문자들 중 하나.
    *   `[-]`: 대괄호 안에서 문자 범위 지정 (예: ``).
    *   `[^]`: 대괄호 안 문자들 **제외**.
*   메타 문자를 문자 그대로 사용하려면 **이스케이프 문자(\) 필요** (예: `\.`).

### 13.3. 함수 예시 (REGEXP_REPLACE)
*   **`REGEXP_REPLACE(대상_문자열, '찾을_패턴', '바꿀_문자열')`**: 대상 문자열에서 정규 표현식 패턴에 맞는 부분을 찾아 바꿀 문자열로 교체.
*   (예: 전화번호 데이터에서 다양한 구분자(`-`, `/`, 공백 등)를 찾아 `-`로 변경).

---